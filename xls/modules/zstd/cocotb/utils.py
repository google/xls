# Copyright 2024 The XLS Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Helpers for setting up and running simulations using Icarus Verilog with Cocotb."""

import os
import pathlib

import subprocess
import cocotb
from cocotb.runner import check_results_file
from cocotb.runner import get_runner
from cocotb.triggers import ClockCycles
import cocotbext.axi.axi_channels as axi

from xls.common import runfiles

import tempfile

def add_to_path(executable):
  dir = str(pathlib.Path(executable).parent)
  os.environ["PATH"] = dir + os.pathsep + os.environ["PATH"]

def setup_verilator():
  build_dir = pathlib.Path("sim_build").absolute()
  build_dir.mkdir(parents=True, exist_ok=True)
  if not os.path.exists(build_dir / "external"):
        # verilator will be launched in build dir. We need to link external there
        # to make relative paths to toolchains (CC and other) work
        os.symlink(os.path.relpath("external", build_dir), build_dir / "external")

  # cocotb does something like `perl $(which verilator) so we have to add both of them to $PATH
  verilator_perl_wrapper_path = runfiles.get_path("bin/verilator", repository = "verilator")
  add_to_path(verilator_perl_wrapper_path)
  add_to_path(os.environ["PERL"])

  # normally verilator's perl wrapper exepects that binary is located next to it under name "verilator_bin"
  # rules_hdl uses different location and name so we have to use $VERILATOR_BIN.
  verilator_binary_path = pathlib.Path(runfiles.get_path("verilator_executable", repository = "verilator"))
  os.environ["VERILATOR_BIN"] = str(verilator_binary_path)

  os.environ.pop("VERILATOR_ROOT", None) # prevent picking wrong env from host

  return build_dir


def setup_com_iverilog():
  iverilog_path = pathlib.Path(
    runfiles.get_path("iverilog", repository = "com_icarus_iverilog")
  )
  vvp_path = pathlib.Path(
    runfiles.get_path("vvp", repository = "com_icarus_iverilog")
  )
  os.environ["PATH"] += os.pathsep + str(iverilog_path.parent)
  os.environ["PATH"] += os.pathsep + str(vvp_path.parent)
  build_dir = pathlib.Path("sim_build").absolute()
  return build_dir


def run_test(toplevel, test_module, verilog_sources, timescale=("1ns", "1ps"), sim="icarus", build_args=[]):
  """Builds and runs a Cocotb testbench"""
  build_dir = setup_verilator() if sim == "verilator" else setup_com_iverilog()
  runner = get_runner(sim)

  if sim == "verilator":
    defines = {"SIMULATION": "1", "ASSERT_ON": "1"}
  else: # icarus does not support concurent assertion generated by xls
    defines = {"SIMULATION": "1"}

  runner.build(
    verilog_sources=verilog_sources,
    hdl_toplevel=toplevel,
    timescale=("1ns", "1ps"),
    build_dir=build_dir,
    defines={"SIMULATION": "1"},
    waves=True,
    build_args=build_args,
  )

  try:
    results_xml = runner.test(
       hdl_toplevel=toplevel,
       test_module=test_module,
       waves=True,
    )
  finally:
    check_results_file(results_xml)

@cocotb.coroutine
async def reset(clk, rst, cycles=1):
  """Cocotb coroutine that performs the reset."""
  rst.value = 1
  await ClockCycles(clk, cycles)
  rst.value = 0

def connect_axi_read_bus(dut, name=""):
  AXI_AR = "axi_ar"
  AXI_R = "axi_r"

  if name != "":
      name += "_"

  bus_axi_ar = axi.AxiARBus.from_prefix(dut, name + AXI_AR)
  bus_axi_r = axi.AxiRBus.from_prefix(dut, name + AXI_R)

  return axi.AxiReadBus(bus_axi_ar, bus_axi_r)

def connect_axi_write_bus(dut, name=""):
  AXI_AW = "axi_aw"
  AXI_W = "axi_w"
  AXI_B = "axi_b"

  if name != "":
      name += "_"

  bus_axi_aw = axi.AxiAWBus.from_prefix(dut, name + AXI_AW)
  bus_axi_b = axi.AxiBBus.from_prefix(dut, name + AXI_B)
  bus_axi_w = axi.AxiWBus.from_prefix(dut, name + AXI_W)

  return axi.AxiWriteBus(bus_axi_aw, bus_axi_w, bus_axi_b)

def connect_axi_bus(dut, name=""):
  bus_axi_read = connect_axi_read_bus(dut, name)
  bus_axi_write = connect_axi_write_bus(dut, name)

  return axi.AxiBus(bus_axi_write, bus_axi_read)
