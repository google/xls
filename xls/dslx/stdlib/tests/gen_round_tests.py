"""Generate DSLX round() tests.

This script produces a comprehensive set of DSLX tests that exercise the
`round` helper over:
  * operand widths from 1 to 5 bits,
  * every possible input value for the corresponding width,
  * each `num_bits_rounded` in {0, 1, …, N, N+1},
  * every rounding mode {RNE, RNA, RTZ, RTN, RTP},
  * the three distinct interpretations requested:
    * unsigned (Sign::NonNegative),
    * sign-and-magnitude with Sign::Negative,
    * signed two's-complement (sN).

Each test function bundles the five rounding-mode checks for a single
(width, value, num_bits_rounded) combination, totalling 372 functions.

The generated DSL lives inside `round_tests.x`; everything between the
"AUTO-GENERATED" markers is replaced when this script runs.
"""

from __future__ import annotations

import argparse
import math
import subprocess
from enum import Enum, auto
from fractions import Fraction
from pathlib import Path

# -------- Helper utilities -------------------------------------------------


class RoundingMode(Enum):
  RNE = auto()  # convergent / bankers-rounding (nearest, ties-to-even)
  RNA = auto()  # away from zero
  RTZ = auto()  # towards zero
  RTN = auto()  # towards -∞
  RTP = auto()  # towards +∞

  def __str__(self) -> str:
    """Return the enum name for DSLX code generation."""
    return self.name


ROUNDING_MODES = [
  RoundingMode.RNE,
  RoundingMode.RNA,
  RoundingMode.RTZ,
  RoundingMode.RTN,
  RoundingMode.RTP,
]

HEADER_BAR = "-" * 75
GENERATED_HEADER = [
  f"// {HEADER_BAR}",
  (
    "// These tests are AUTO-GENERATED by gen_round_tests.py - do not edit "
    "manually."
  ),
  "// Everything below this comment will be overwritten.",
  f"// {HEADER_BAR}",
]
HEADER_TEXT = "\n".join(GENERATED_HEADER)

MIN_WIDTH = 1
MAX_WIDTH = 5


def all_widths() -> range:
  return range(MIN_WIDTH, MAX_WIDTH + 1)


def value_space(width: int) -> range:
  return range(1 << width)


def num_bits_field_width(width: int) -> int:
  # Mirrors DSLX's std::clog2(N + 1) used in round()'s type signature.
  # Ensure at least one bit so we can represent zero.
  return max(1, math.ceil(math.log2(width + 1)))


def nbits_space(width: int) -> list[int]:
  # Include 0, the in-range values, and one value beyond the width.
  in_range = list(range(0, width + 1))
  beyond = width + 1
  max_representable = (1 << num_bits_field_width(width)) - 1
  if beyond <= max_representable:
    in_range.append(beyond)
  return in_range


# ---------------------------------------------------------------------------


def fraction_from_bits(
    bits: int,
    nfrac: int,
    *,
    signed: bool,
    width: int,
) -> Fraction:
  """Return the real value encoded by *bits*.

  Interpret the bits as a fixed-point number with *nfrac* fractional bits.
  Unsigned representation is used unless *signed* is True, in which case
  two's-complement is assumed.
  """
  if signed and bits & (1 << (width - 1)):
    bits -= 1 << width  # sign-extend negative value
  return Fraction(bits, 1 << nfrac)


def round_fraction(value: Fraction, mode: RoundingMode) -> int:
  """Round *value* to the nearest integer according to *mode*.

  Returns the rounded integer (unbounded; overflow is handled separately).
  """
  assert isinstance(mode, RoundingMode)

  # Directed rounding modes.
  if mode == RoundingMode.RTZ:  # truncate towards zero
    return math.trunc(value)
  if mode == RoundingMode.RTN:  # towards -∞
    return math.floor(value)
  if mode == RoundingMode.RTP:  # towards +∞
    return math.ceil(value)

  # The remaining two are 'nearest' variants.
  floor_val = math.floor(value)
  ceil_val = math.ceil(value)
  dist_down = value - floor_val  # always ≥ 0
  dist_up = ceil_val - value  # always ≥ 0

  if dist_down < dist_up:
    return floor_val
  if dist_up < dist_down:
    return ceil_val

  # At a tie - exactly midway between.
  if mode == RoundingMode.RNE:  # tie to even
    return floor_val if floor_val % 2 == 0 else ceil_val
  # RNA - tie away from zero
  return ceil_val if value >= 0 else floor_val


def needs_overflow_unsigned(val: int, int_bits: int) -> bool:
  """Return True if *val* cannot be represented in *int_bits* unsigned bits."""
  return val < 0 or val >= (1 << int_bits)


def needs_overflow_signed(val: int, int_bits: int) -> bool:
  """Return True if *val* cannot be represented in *int_bits* two's-complement.

  The integer part of our fixed-point numbers spans `int_bits` bits, which
  includes the sign bit for two's-complement values. A value is representable
  iff it lies within the conventional two's-complement range

      [ -2^(int_bits-1) , 2^(int_bits-1) - 1 ].

  Special-case `int_bits == 0` (all bits are fractional): in that scenario
  *no* non-zero integer can be represented once the value has been rounded
  (because the subsequent left-shift by `nfrac` would shift the sign bit out of
  the word). Hence every value except 0 overflows.
  """
  if int_bits == 0:
    return val != 0

  min_val = -(1 << (int_bits - 1))
  max_val = (1 << (int_bits - 1)) - 1
  return val < min_val or val > max_val


def bits_literal(bits: int, nfrac: int, width: int) -> str:
  """Return a DSLX binary literal for the given *width*-bit value."""
  mask = (1 << width) - 1
  bin_str = format(bits & mask, f"0{width}b")
  int_bits = max(width - nfrac, 0)
  frac_bits = width - int_bits
  if int_bits == 0 or frac_bits == 0:
    return f"0b{bin_str}"
  return f"0b{bin_str[:int_bits]}_{bin_str[int_bits:]}"


def fmt_real(frac: Fraction) -> str:
  """Nicely format *frac* for human-readable comments."""
  numerator, denominator = frac.numerator, frac.denominator
  if denominator == 1:
    return str(numerator)
  # Use finite decimal if possible (denominator is a power of two ≤ 32).
  return str(float(frac))


# ---------------------------------------------------------------------------


def num_bits_literal(width: int, nfrac: int) -> str:
  """Return the literal string for num_bits_rounded with enough width."""
  default_width = max(1, width.bit_length())
  required_width = max(1, nfrac.bit_length())
  literal_width = max(default_width, required_width)
  return f"u{literal_width}:{nfrac}"


def generate_test_function(width: int, bits: int, nfrac: int) -> str:
  """Return the DSLX source for one test function covering all rounding modes
  under the three interpretations.
  """
  func_lines: list[str] = []
  int_bits = max(width - nfrac, 0)
  func_name = f"test_w{width}_p{bits:02d}_n{nfrac}"

  unrounded_lit = bits_literal(bits, nfrac, width)
  nbr_literal = num_bits_literal(width, nfrac)
  mask = (1 << width) - 1
  func_lines.append("#[test]")
  func_lines.append(f"fn {func_name}() {{")
  func_lines.append(f"    let num_bits_rounded = {nbr_literal};")
  func_lines.append(f"    let unrounded = u{width}:{unrounded_lit};\n")

  # --- unsigned interpretation -----------------------------------------
  real_unsigned = Fraction(bits, 1 << nfrac)
  func_lines.append(
      f"    // unsigned, Real value is {fmt_real(real_unsigned)}"
  )
  for mode in ROUNDING_MODES:
    mode_name = mode.name
    rounded = round_fraction(real_unsigned, mode)
    overflow = needs_overflow_unsigned(rounded, int_bits)
    carry = 1 if overflow else 0
    val_bits = 0 if overflow else ((rounded << nfrac) & mask)
    val_lit = bits_literal(val_bits, nfrac, width)
    ov_comment = " -> overflow" if overflow else ""
    func_lines.append(
        f"    // {mode_name}({fmt_real(real_unsigned)}) = "
        f"{rounded}{ov_comment}"
    )
    func_lines.append(
        f"    assert_eq((u1:{carry}, u{width}:{val_lit}), "
        f"round::round(round::RoundingMode::{mode_name}, "
        "num_bits_rounded, "
        "round::Sign::NonNegative, "
        "unrounded));"
    )
  func_lines.append("")

  # --- sign & magnitude, negative --------------------------------------
  real_sm = -real_unsigned
  func_lines.append(
      f"    // sign & magnitude, Real value is {fmt_real(real_sm)}"
  )
  for mode in ROUNDING_MODES:
    mode_name = mode.name
    rounded = abs(round_fraction(real_sm, mode))  # magnitude only
    overflow = needs_overflow_unsigned(rounded, int_bits)
    carry = 1 if overflow else 0
    val_bits = 0 if overflow else ((rounded << nfrac) & mask)
    val_lit = bits_literal(val_bits, nfrac, width)
    ov_comment = " -> overflow" if overflow else ""
    rounded_display = -rounded if not overflow else f"-{rounded}"
    func_lines.append(
        f"    // {mode_name}({fmt_real(real_sm)}) = "
        f"{rounded_display}{ov_comment}"
    )
    func_lines.append(
        f"    assert_eq((u1:{carry}, u{width}:{val_lit}), "
        f"round::round(round::RoundingMode::{mode_name}, "
        "num_bits_rounded, "
        "round::Sign::Negative, "
        "unrounded));"
    )
  func_lines.append("")

  # --- signed two's-complement ----------------------------------------
  real_signed = fraction_from_bits(bits, nfrac, signed=True, width=width)
  func_lines.append(
      f"    // signed, Real value is {fmt_real(real_signed)}"
  )
  for mode in ROUNDING_MODES:
    mode_name = mode.name
    rounded = round_fraction(real_signed, mode)
    overflow = needs_overflow_signed(rounded, int_bits)
    carry = 1 if overflow else 0
    val_bits = 0 if overflow else (((rounded & mask) << nfrac) & mask)
    val_lit = bits_literal(val_bits, nfrac, width)
    ov_comment = " -> overflow" if overflow else ""
    func_lines.append(
        f"    // {mode_name}({fmt_real(real_signed)}) = "
        f"{rounded}{ov_comment}"
    )
    func_lines.append(
        f"    assert_eq((u1:{carry}, s{width}:{val_lit}), "
        f"round::round(round::RoundingMode::{mode_name}, "
        "num_bits_rounded, "
        "round::Sign::NonNegative, "
        f"unrounded as s{width}));"
    )

  func_lines.append("}")
  return "\n".join(func_lines)


# ---------------------------------------------------------------------------


def build_generated_section() -> tuple[str, int]:
  lines: list[str] = [HEADER_TEXT, ""]
  total_funcs = 0
  for width in all_widths():
    lines.append(
        f"// --- Width {width} bits "
        "--------------------------------------------------------"
    )
    for bits in value_space(width):
      for nfrac in nbits_space(width):
        lines.append(generate_test_function(width, bits, nfrac))
        lines.append("")
        total_funcs += 1
  section = "\n".join(lines).rstrip() + "\n"
  return section, total_funcs


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
  parser = argparse.ArgumentParser(
      description="Generate DSLX round() tests."
  )
  parser.add_argument(
      "--round-tests",
      type=Path,
      default=Path(__file__).with_name("round_tests.x"),
      help=(
          "Path to the round_tests.x file to update "
          "(default: sibling round_tests.x)"
      ),
  )
  parser.add_argument(
      "--dslx-fmt",
      type=Path,
      help=(
          "Optional path to dslx_fmt; if provided, formatted output replaces "
          "round_tests.x"
      ),
  )
  return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> None:
  args = parse_args(argv)
  out_path = args.round_tests
  existing = out_path.read_text()
  section, total_funcs = build_generated_section()

  marker_index = existing.find(HEADER_TEXT)
  if marker_index == -1:
    raise RuntimeError(
        "Generated section header not found in round_tests.x"
    )

  updated = existing[:marker_index] + section
  out_path.write_text(updated)

  if args.dslx_fmt is not None:
    result = subprocess.run(
        [str(args.dslx_fmt), str(out_path)],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=False,
    )
    if result.returncode != 0:
      raise RuntimeError(
          "dslx_fmt failed with exit code "
          f"{result.returncode}: {result.stderr.strip()}"
      )
    if result.stdout:
      out_path.write_text(result.stdout)
    else:
      raise RuntimeError(
          "dslx_fmt produced no output; refusing to overwrite round_tests.x"
      )

  print(f"Updated {out_path} with {total_funcs} test functions.")


if __name__ == "__main__":
  main()
