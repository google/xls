// AUTOMATICALLY GENERATED FILE FROM `xls/dslx/cpp_transpiler`. DO NOT EDIT!
#include <array>
#include <bitset>
#include <string>
#include <string_view>
#include <vector>

#include "fake_path.h"
#include "absl/base/macros.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_format.h"
#include "absl/types/span.h"
#include "xls/public/status_macros.h"
#include "xls/public/value.h"

namespace {

[[maybe_unused]] bool FitsInNBitsSigned(int64_t value, int64_t n) {
  // All bits from [n - 1, 64) must be all zero or all ones.
  if (n >= 64) {
    return true;
  }
  // `mask` is 1111...00000 with n zeros.
  uint64_t mask = ~((uint64_t{1} << n) - 1);
  uint64_t value_as_unsigned = static_cast<uint64_t>(value);
  return (mask & value_as_unsigned) == 0 ||
       (mask & value_as_unsigned) == mask;
}

[[maybe_unused]] bool FitsInNBitsUnsigned(uint64_t value, int64_t n) {
  if (n >= 64) {
    return true;
  }
  return value < (uint64_t{1} << n);
}

[[maybe_unused]] std::string __indent(int64_t amount) {
  return std::string(amount * 2, ' ');
}

}  // namespace

namespace robs::secret::space::my_module {

absl::Status VerifyMyArrayType1(const MyArrayType1& value) {
  for (int64_t i0 = 0; i0 < 8; ++i0) {
    if (!FitsInNBitsUnsigned(value[i0], 31)) {
      return absl::InvalidArgumentError(absl::StrCat("MyArrayType1 value does not fit in 31 bits: ", absl::StrFormat("0x%x", value[i0])));
    }
  }
  return absl::OkStatus();
}

std::string MyArrayType1ToString(const MyArrayType1& value, int64_t indent) {
  std::string result;
  result += "[\n";
  for (int64_t i0 = 0; i0 < 8; ++i0) {
    result += __indent(indent + 1);
      result += "bits[31]:" + absl::StrFormat("0x%x", value[i0]);
  result += ",\n";
  }
  result += __indent(indent) + "]";
  return result;
}

std::string MyArrayType1ToDslxString(const MyArrayType1& value, int64_t indent) {
  std::string result;
  result += "[\n";
  for (int64_t i0 = 0; i0 < 8; ++i0) {
    result += __indent(indent + 1);
      result += "u31:" + absl::StrFormat("0x%x", value[i0]);
  result += ",\n";
  }
  result += __indent(indent) + "]";
  return result;
}

absl::StatusOr<::xls::Value> MyArrayType1ToValue(const MyArrayType1& input) {
  ::xls::Value value;
  {
    std::vector<::xls::Value> elements;
    for (int64_t i0 = 0; i0 < 8; ++i0) {
      ::xls::Value element;
      if (!FitsInNBitsUnsigned(input[i0], 31)) {
        return absl::InvalidArgumentError(absl::StrFormat("Unsigned value %#x does not fit in 31 bits", input[i0]));
      }
      element = ::xls::Value(::xls::UBits(input[i0], 31));
      elements.push_back(element);
    }
    value = ::xls::Value::ArrayOrDie(elements);
  }
  return value;
}

absl::StatusOr<MyArrayType1> MyArrayType1FromValue(const ::xls::Value& value) {
  MyArrayType1 result;
  if (!value.IsArray() || value.size() != 8) {
    return absl::InvalidArgumentError("Value is not a array of 8 elements.");
  }
  for (int64_t i0 = 0; i0 < 8; ++i0) {
    if (!value.element(i0).IsBits() || value.element(i0).bits().bit_count() != 31) {
      return absl::InvalidArgumentError("Value is not a bits type of 31 bits.");
    }
    result[i0] = value.element(i0).bits().ToUint64().value();
  }
  return result;
}

}  // namespace robs::secret::space::my_module
