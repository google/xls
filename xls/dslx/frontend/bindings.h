// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Bindings class (name to defining AST node tracking) for use in parsing.

#ifndef XLS_DSLX_FRONTEND_CPP_BINDINGS_H_
#define XLS_DSLX_FRONTEND_CPP_BINDINGS_H_

#include <string>
#include <string_view>
#include <utility>
#include <variant>

#include "absl/container/flat_hash_map.h"
#include "absl/container/flat_hash_set.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/types/optional.h"
#include "xls/common/logging/logging.h"
#include "xls/dslx/frontend/ast.h"

namespace xls::dslx {

// Bindings (name references in the environment that map back to definition
// points in the AST) resolve to this BoundNode variant, which are all kinds of
// definitions.
using BoundNode =
    std::variant<EnumDef*, TypeAlias*, ConstantDef*, const NameDef*,
                 BuiltinNameDef*, StructDef*, Import*>;

// Returns a string, useful for reporting in error messages, for the type of the
// AST node contained inside of the given BoundNode variant; e.g. "Import".
std::string BoundNodeGetTypeString(const BoundNode& bn);

// Encodes ParseError data in a canonical way inside of an invalid argument
// error.
//
// When these propagate up to a Python boundary we throw them as exceptions
// using the data encoded in the absl::Status message. See ParseErrorGetData()
// for the utility used to extract the data from the error message text.
inline absl::Status ParseErrorStatus(const Span& span,
                                     std::string_view message) {
  return absl::InvalidArgumentError(
      absl::StrFormat("ParseError: %s %s", span.ToString(), message));
}

struct PositionalErrorData {
  Span span;
  std::string message;
  std::string error_type;

  std::string GetMessageWithType() const {
    return absl::StrCat(error_type, ": ", message);
  }

  bool operator==(const PositionalErrorData& other) const {
    return span == other.span && message == other.message &&
           error_type == other.error_type;
  }
};

// Returns parsed error data, or an error status if "status" is not of the
// special "positional error" format; e.g. of the formal generated by
// ParseErrorStatus() above.
absl::StatusOr<PositionalErrorData> GetPositionalErrorData(
    const absl::Status& status,
    std::optional<std::string_view> target_type = std::nullopt);

// Maps identifiers to the AST node that bound that identifier (also known as
// the lexical environment).
//
// The datatype is "stackable" so that we can easily take the bindings at a
// given point in the program (say in a function) and extend it with a new scope
// by stacking a fresh Bindings object on top (also sometimes referred to as a
// "scope chain"). For example:
//
//    Binding builtin_bindings;
//    builtin_bindings.Add("range", m.Make<BuiltinNameDef>("range"));
//
//    // Create a fresh scope, with no need to copy the builtin_bindings object.
//    Bindings function_bindings(&builtin_bindings);
//    XLS_ASSIGN_OR_RETURN(Function* f, ParseFunction(&function_bindings));
//
// We can do this because bindings are immutable and stack according to lexical
// scope; new bindings in the worst case only shadow previous bindings.
class Bindings {
 public:
  explicit Bindings(Bindings* parent = nullptr) : parent_(parent) {}

  // Returns a copy of this bindings object.
  Bindings Clone() const;

  // The "Cronus" method. This adds a child's bindings to this object, i.e., it
  // "commits" changes made in a child Bindings to this parent object.
  void ConsumeChild(Bindings* child) {
    XLS_CHECK_EQ(child->parent_, this);
    local_bindings_.merge(child->local_bindings_);
  }

  // Returns whether there are any local bindings (i.e. bindings that are not
  // set in parent/ancestors).
  bool HasLocalBindings() const { return !local_bindings_.empty(); }

  // Adds a local binding.
  void Add(std::string name, BoundNode binding) {
    local_bindings_[std::move(name)] = binding;
  }

  // fail! labels must be unique within a function.
  absl::Status AddFailLabel(const std::string& label) {
    // Check parents, in case we're contained in a subblock. The root bindings
    // will never contain any fail labels.
    if (ContainsFailLabel(label)) {
      return absl::InvalidArgumentError(
          "A fail label must be unique within a function.");
    }
    fail_labels_.insert(label);
    return absl::OkStatus();
  }

  bool ContainsFailLabel(const std::string& label) {
    if (fail_labels_.contains(label)) {
      return true;
    }
    if (parent_ != nullptr) {
      return parent_->ContainsFailLabel(label);
    }
    return false;
  }

  // Returns the AST node bound to 'name'.
  std::optional<BoundNode> ResolveNode(std::string_view name) const {
    auto it = local_bindings_.find(name);
    if (it == local_bindings_.end()) {
      if (parent_ != nullptr) {
        return parent_->ResolveNode(name);
      }
      return std::nullopt;
    }

    return it->second;
  }

  bool ResolveNodeIsTypeDefinition(std::string_view name) const {
    std::optional<BoundNode> bn = ResolveNode(name);
    if (!bn) {
      return false;
    }
    return std::holds_alternative<EnumDef*>(*bn) ||
           std::holds_alternative<TypeAlias*>(*bn) ||
           std::holds_alternative<StructDef*>(*bn);
  }

  // As above, but flags a ParseError() if the binding cannot be resolved,
  // attributing the source of the binding resolution as span.
  absl::StatusOr<BoundNode> ResolveNodeOrError(std::string_view name,
                                               const Span& span) const {
    std::optional<BoundNode> result = ResolveNode(name);
    if (result.has_value()) {
      return *std::move(result);
    }
    return ParseErrorStatus(
        span,
        absl::StrFormat("Cannot find a definition for name: \"%s\"", name));
  }

  // Resolves "name" as an AST binding and returns the associated NameDefNode.
  //
  // Returns nullopt if no AST node binding is found associated with "name".
  std::optional<AnyNameDef> ResolveNameOrNullopt(std::string_view name) const;

  // As above, but returns a ParseError status.
  absl::StatusOr<AnyNameDef> ResolveNameOrError(std::string_view name,
                                                const Span& span) const;

  // Returns whether there is an AST binding associated with "name".
  bool HasName(std::string_view name) const {
    return ResolveNode(name).has_value();
  }

 private:
  Bindings* parent_;
  absl::flat_hash_map<std::string, BoundNode> local_bindings_;
  absl::flat_hash_set<std::string> fail_labels_;
};

// Returns the name definition node (either builtin or user-defined) associated
// with the given binding data.
AnyNameDef BoundNodeToAnyNameDef(BoundNode bn);

// Returns the text span where the binding data is defined.
//
// For a builtin name definition, a "fake" span is returned (that spans no
// characters in the filename "<builtin>").
Span BoundNodeGetSpan(BoundNode bn);

}  // namespace xls::dslx

#endif  // XLS_DSLX_FRONTEND_CPP_BINDINGS_H_
