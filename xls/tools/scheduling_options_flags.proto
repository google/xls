// Copyright 2023 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package xls;

import "google/api/field_behavior.proto";
import "ortools/math_opt/parameters.proto";

enum ProtoSchedulingStrategy {
  // This is aliased to SCHEDULER_TYPE_SDC.
  SCHEDULER_TYPE_UNSPECIFIED = 0;
  // The SDC (system-of-difference-constraints) scheduler.
  //
  // This scheduler is based on the work in:
  //   https://www.csl.cornell.edu/~zhiruz/pdfs/sdcmod-iccad2013.pdf
  // and is a general-purpose constraint optimizer.
  //
  // This is the default scheduler.
  SCHEDULER_TYPE_SDC = 1;
  // An alternative scheduler which simply attempts to create a feasible
  // schedule.
  //
  // Unlike SDC this scheduler does not attempt to minimize the number of
  // registers or evenly spread delay across the pipeline. Instead this simply
  // forces all computation into the earliest stage where it fits and all
  // predicates are available. As this scheduler is less constrained it is
  // faster to run than the SDC scheduler.
  //
  // This scheduler is primarily intended for use during development when
  // iteration speed is paramount. It should not be used to create the final
  // schedule for a design.
  SCHEDULER_TYPE_ASAP = 2;
  // An alternative scheduler which approximates the minimum number of registers
  // using a min-cut based algorithm.
  SCHEDULER_TYPE_MIN_CUT = 3;
  // A scheduler which randomly schedules nodes. For internal testing only.
  SCHEDULER_TYPE_RANDOM = 4;
}

message SchedulingFailureBehaviorProto {
  optional bool explain_infeasibility = 1
      [(google.api.field_behavior) = REQUIRED];
  optional double infeasible_per_state_backedge_slack_pool = 2
      [(google.api.field_behavior) = OPTIONAL];
}

// Flags passed to the benchmark_codegen_main, codegen_main,
// and sched_printer_main binary.
//
// See scheduling_options_flags.cc ABSL_FLAG()
// definitions for the meaning of these fields.
message SchedulingOptionsFlagsProto {
  optional int64 clock_period_ps = 1;
  optional int64 pipeline_stages = 2;
  optional string delay_model = 3;
  optional int64 clock_margin_percent = 4;
  optional int64 period_relaxation_percent = 5;
  optional int64 worst_case_throughput = 6;
  optional int64 additional_input_delay_ps = 7;
  optional int64 additional_output_delay_ps = 31;
  map<string, int64> additional_channel_delay_ps = 33;
  optional int64 ffi_fallback_delay_ps = 8;
  repeated string io_constraints = 9;
  optional bool receives_first_sends_last = 10;
  optional int64 mutual_exclusion_z3_rlimit = 11;
  optional int64 default_next_value_z3_rlimit = 25;
  optional SchedulingFailureBehaviorProto failure_behavior = 23;
  optional bool use_fdo = 22;
  optional int64 fdo_iteration_number = 12;
  optional int64 fdo_delay_driven_path_number = 13;
  optional int64 fdo_fanout_driven_path_number = 14;
  optional float fdo_refinement_stochastic_ratio = 15;
  optional string fdo_path_evaluate_strategy = 16;
  optional string fdo_synthesizer_name = 17;
  optional string fdo_yosys_path = 18;
  optional string fdo_sta_path = 19;
  optional string fdo_synthesis_libraries = 20;
  optional string fdo_default_driver_cell = 28;
  optional string fdo_default_load = 29;
  optional bool minimize_clock_on_failure = 21;
  optional bool multi_proc = 24;
  optional bool minimize_worst_case_throughput = 26;
  optional bool recover_after_minimizing_clock = 27;
  optional int64 opt_level = 30;
  optional double dynamic_throughput_objective_weight = 32;
  optional bool merge_on_mutual_exclusion = 34;
  optional double sdc_solution_tolerance = 35;
  optional operations_research.math_opt.SolverTypeProto solver_type = 36;
  optional operations_research.math_opt.SolveParametersProto solve_parameters =
      37;
  // What sort of scheduler one should use.
  optional ProtoSchedulingStrategy scheduling_strategy = 38;
}
