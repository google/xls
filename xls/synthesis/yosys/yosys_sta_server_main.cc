// Copyright 2020 Google LLC
//
// Copyright 2021 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/strings/str_join.h"
#include "absl/time/time.h"
#include "grpcpp/security/server_credentials.h"
#include "grpcpp/server.h"
#include "grpcpp/server_builder.h"
#include "grpcpp/server_context.h"
#include "xls/common/file/filesystem.h"
#include "xls/common/file/temp_directory.h"
#include "xls/common/init_xls.h"
#include "xls/common/logging/logging.h"
#include "xls/common/status/ret_check.h"
#include "xls/common/status/status_macros.h"
#include "xls/common/subprocess.h"
#include "xls/synthesis/server_credentials.h"
#include "xls/synthesis/synthesis.pb.h"
#include "xls/synthesis/synthesis_service.grpc.pb.h"
#include "xls/synthesis/yosys/yosys_util.h"

// TODO(meheff): This should be merged with yosys_server_main. The STA aspect
// could be enabled via flags.

const char kUsage[] =
    R"( Launches a XLS synthesis server which uses yosys and OpenSTA for synthesis and STA.

Invocation:
  yosys_sta_server --yosys_path=PATH  --sta_path=PATH --synthesis_libraries="lib1 lib2"  --sta_libraries="lib1 lib2"
)";

ABSL_FLAG(int32_t, port, 10000, "Port to listen on.");
ABSL_FLAG(std::string, yosys_path, "", "The path to the yosys binary.");
ABSL_FLAG(std::string, sta_path, "", "The path to the sta binary.");

ABSL_FLAG(std::string, synthesis_libraries, "",
          "The technology library file to target for synthesis; *.lib");

ABSL_FLAG(
    std::string, sta_libraries, "",
    "The technology library/libraries file to target for STA; *.lib * lib.gz");

ABSL_FLAG(bool, save_temps, false, "Do not delete temporary files.");

ABSL_FLAG(bool, synthesis_only, false, "Perform synthesis but not STA");

ABSL_FLAG(bool, return_netlist, true,
          "Return the netlist generated by synthesis");

namespace xls {
namespace synthesis {
namespace {

class YosysStaServiceImpl : public SynthesisService::Service {
 public:
  explicit YosysStaServiceImpl(std::string_view yosys_path,
                               std::string_view sta_path,
                               std::string_view synthesis_libraries,
                               std::string_view sta_libraries)
      : yosys_path_(yosys_path),
        sta_path_(sta_path),
        synthesis_libraries_(synthesis_libraries),
        sta_libraries_(sta_libraries) {}

  ::grpc::Status Compile(::grpc::ServerContext* server_context,
                         const CompileRequest* request,
                         CompileResponse* result) override {
    auto start = absl::Now();

    // DOTP change to flow status
    absl::Status synthesis_status = RunSynthesisSTA(request, result);
    if (!synthesis_status.ok()) {
      return ::grpc::Status(grpc::StatusCode::INTERNAL,
                            std::string(synthesis_status.message()));
    }

    result->set_elapsed_runtime_ms(
        absl::ToInt64Milliseconds(absl::Now() - start));

    return ::grpc::Status::OK;
  }

  // Run the given arguments as a subprocess with InvokeSubprocess.
  // InvokeSubprocess is wrapped because the error message can be very large (it
  // includes both stdout and stderr) which breaks propagation of the error via
  // GRPC because GRPC instead gives an error about trailing metadata being too
  // large.
  absl::StatusOr<std::pair<std::string, std::string>> RunSubprocess(
      absl::Span<const std::string> args) {
    absl::StatusOr<std::pair<std::string, std::string>> stdout_stderr_status =
        SubprocessResultToStrings(
            SubprocessErrorAsStatus(InvokeSubprocess(args)));

    if (!stdout_stderr_status.ok()) {
      XLS_LOG(ERROR) << stdout_stderr_status.status();
      const int64_t kMaxMessageSize = 1024;
      auto prune_error_message = [](std::string_view message) -> std::string {
        if (message.size() >= kMaxMessageSize) {
          return absl::StrFormat(
              "%s\n...\n%s", message.substr(0, kMaxMessageSize),
              message.substr(message.size() - kMaxMessageSize));
        }
        return std::string(message);
      };
      return absl::InternalError(absl::StrFormat(
          "Failed to execute subprocess: %s. Error: %s",
          absl::StrJoin(args, " "),
          prune_error_message(stdout_stderr_status.status().message())));
    }
    return stdout_stderr_status;
  }

  // Build yosys synthesis the verilog given in the CompileRequest.
  std::string BuildYosysCmds(const CompileRequest* request,
                             const std::filesystem::path& verilog_path,
                             const std::filesystem::path& json_path,
                             const std::filesystem::path& netlist_path) {
    std::vector<std::string> yosys_cmd_vec;
    std::string yosys_cmd;

    // Input in hz, adjust for scale ps
    double clock_period_ps = 1e12 / request->target_frequency_hz();
    std::string delay_target = absl::StrCat(clock_period_ps);

    // Define yosys commands
    const std::string read_verilog_rtl =
        absl::StrFormat("read_verilog %s ;", verilog_path.string());
    const std::string read_synthesis_libraries = absl::StrFormat(
        "read_liberty -lib -ignore_miss_dir -setattr blackbox %s ;",
        synthesis_libraries_);

    const std::string perform_generic_synthesis =
        absl::StrFormat("synth -top %s ;", request->top_module_name());

    const std::string perform_ff_mapping =
        absl::StrFormat("dfflibmap -liberty %s; opt ;", synthesis_libraries_);
    const std::string perform_abc_mapping = absl::StrFormat(
        "abc -D %s -liberty %s -script "
        "+strash;fraig;scorr;retime,%s;strash;dch,-f;map,-M,1,%s -showtmp ;",
        delay_target, synthesis_libraries_, delay_target, delay_target);
    const std::string perform_cleanup =
        absl::StrFormat("setundef -zero ; splitnets ;");
    const std::string perform_optimizations =
        absl::StrFormat("opt ;clean ; rename -enumerate ;");
    const std::string write_json_netlist =
        absl::StrFormat("write_json %s ;", json_path.string());

    const std::string write_verilog_netlist =
        absl::StrFormat("write_verilog -noattr -noexpr -nohex -nodec %s ;",
                        netlist_path.string());

    // Build yosys commandfile
    yosys_cmd_vec.push_back(read_verilog_rtl);
    yosys_cmd_vec.push_back(read_synthesis_libraries);

    yosys_cmd_vec.push_back(perform_generic_synthesis);
    yosys_cmd_vec.push_back(perform_ff_mapping);
    yosys_cmd_vec.push_back(perform_abc_mapping);
    yosys_cmd_vec.push_back(perform_cleanup);
    yosys_cmd_vec.push_back(perform_optimizations);

    yosys_cmd_vec.push_back(write_json_netlist);
    yosys_cmd_vec.push_back(write_verilog_netlist);

    yosys_cmd = absl::StrJoin(yosys_cmd_vec, "\n");

    XLS_LOG(INFO) << "about to start, yosys cmd: " << yosys_cmd;
    return yosys_cmd;
  }

  // Build STA for the verilog netlist given in the CompileRequest.
  std::string BuildSTACmds(const CompileRequest* request,
                           std::filesystem::path netlist_path) {
    // Invoke STA for timing and max freq analysis.
    std::vector<std::string> sta_cmd_vec;
    std::string sta_cmd;

    // Input in hz, adjust for scale ps
    double clock_period_ps = 1e12 / request->target_frequency_hz();
    std::string delay_target = absl::StrCat(clock_period_ps);

    const std::string setup_libraries =
        absl::StrFormat("set LIB_FILES { %s }", sta_libraries_);
    const std::string read_libraries =
        absl::StrFormat("foreach libFile $LIB_FILES { read_liberty $libFile }");
    const std::string read_verilog_netlist =
        absl::StrFormat("read_verilog %s ", netlist_path.string());
    const std::string perform_elaboratation =
        absl::StrFormat("link_design %s  ", request->top_module_name());

    const std::string setup_units = absl::StrFormat("set_cmd_units -time ps");
    const std::string setup_clk_period =
        absl::StrFormat("set clk_period %s", delay_target);
    const std::string setup_clk_port =
        absl::StrFormat("set clk_port [get_ports -quiet clk]");
    const std::string setup_delay = absl::StrFormat("set clk_io_pct 0.001");

    const std::string setup_constraints = absl::StrFormat(
        R"(if { [string length [get_ports -quiet clk]] > 1 } {
  create_clock -name op_clk  -period $clk_period  $clk_port ;
  set non_clock_inputs [lsearch -inline -all -not -exact [all_inputs] $clk_port ] ;
  set_input_delay  [expr $clk_period * $clk_io_pct] -clock op_clk $non_clock_inputs ;
  set_output_delay [expr $clk_period * $clk_io_pct] -clock op_clk [all_outputs] ;
 })");

    const std::string perform_report_clk =
        absl::StrFormat("report_clock_min_period");
    const std::string perform_worst_slack =
        absl::StrFormat("report_worst_slack -max");
    const std::string perform_report_negative_slacks =
        absl::StrFormat("report_tns report_wns");

    const std::string perform_report_checks = absl::StrFormat(
        "report_checks -path_delay min_max -fields {slew cap input nets"
        "fanout} -format full_clock_expanded");

    const std::string perform_exit = absl::StrFormat("exit");

    sta_cmd_vec.push_back(setup_libraries);
    sta_cmd_vec.push_back(read_libraries);
    sta_cmd_vec.push_back(read_verilog_netlist);
    sta_cmd_vec.push_back(perform_elaboratation);

    sta_cmd_vec.push_back(setup_units);
    sta_cmd_vec.push_back(setup_clk_period);
    sta_cmd_vec.push_back(setup_clk_port);
    sta_cmd_vec.push_back(setup_delay);

    sta_cmd_vec.push_back(setup_constraints);

    sta_cmd_vec.push_back(perform_report_clk);
    sta_cmd_vec.push_back(perform_worst_slack);
    sta_cmd_vec.push_back(perform_report_negative_slacks);
    sta_cmd_vec.push_back(perform_report_checks);

    sta_cmd_vec.push_back(perform_exit);

    sta_cmd = absl::StrJoin(sta_cmd_vec, "\n");

    XLS_LOG(INFO) << "about to start, sta cmd: " << sta_cmd;
    return sta_cmd;
  }

  // Invokes yosys synthesis the verilog given in the CompileRequest.
  absl::Status RunSynthesisSTA(const CompileRequest* request,
                               CompileResponse* result) {
    if (request->top_module_name().empty()) {
      return absl::InvalidArgumentError("Must specify top module name.");
    }

    XLS_ASSIGN_OR_RETURN(TempDirectory temp_dir, TempDirectory::Create());
    std::filesystem::path temp_dir_path = temp_dir.path();
    if (absl::GetFlag(FLAGS_save_temps)) {
      std::move(temp_dir).Release();
    }

    std::filesystem::path verilog_path = temp_dir_path / "input.v";
    XLS_RETURN_IF_ERROR(SetFileContents(verilog_path, request->module_text()));

    // Invoke yosys to generate verilog and json output.
    std::filesystem::path json_path = temp_dir_path / "netlist.json";
    std::filesystem::path netlist_path = temp_dir_path / "output.v";
    std::filesystem::path yosys_cmd_path = temp_dir_path / "yosys.cmd";
    std::filesystem::path sta_cmd_path = temp_dir_path / "sta.tcl";

    std::string yosys_cmd;
    std::string sta_cmd;

    std::pair<std::string, std::string> string_pair;

    // YOSYS
    yosys_cmd = BuildYosysCmds(request, verilog_path, json_path, netlist_path);
    XLS_RETURN_IF_ERROR(SetFileContents(yosys_cmd_path, yosys_cmd));

    XLS_LOG(INFO) << "Yosys command file: " << yosys_cmd_path;

    XLS_ASSIGN_OR_RETURN(string_pair,
                         RunSubprocess({yosys_path_, "-s", yosys_cmd_path}));

    auto [yosys_stdout, yosys_stderr] = string_pair;
    if (absl::GetFlag(FLAGS_save_temps)) {
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "yosys.stdout", yosys_stdout));
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "yosys.stderr", yosys_stderr));
    }

    // return the JSON netlist result
    XLS_ASSIGN_OR_RETURN(std::string netlist, GetFileContents(json_path));
    if (absl::GetFlag(FLAGS_return_netlist)) {
      result->set_netlist(netlist);
    }

    // Add stats in response.
    XLS_ASSIGN_OR_RETURN(YosysSynthesisStatistics parse_stats,
                         ParseYosysOutput(yosys_stdout));
    XLS_RET_CHECK(!result->has_instance_count());

    for (const auto& name_count : parse_stats.cell_histogram) {
      (*result->mutable_instance_count()
            ->mutable_cell_histogram())[name_count.first] = name_count.second;
    }

    // If only synthesis requested, done.
    if (absl::GetFlag(FLAGS_synthesis_only)) {
      return absl::OkStatus();
    }

    // STA
    sta_cmd = BuildSTACmds(request, netlist_path);
    XLS_RETURN_IF_ERROR(SetFileContents(sta_cmd_path, sta_cmd));

    XLS_LOG(INFO) << "STA command file: " << sta_cmd_path;

    XLS_ASSIGN_OR_RETURN(
        string_pair,
        RunSubprocess({sta_path_, "-no_splash", "-exit", sta_cmd_path}));

    auto [sta_stdout, sta_stderr] = string_pair;
    if (absl::GetFlag(FLAGS_save_temps)) {
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "sta.stdout", sta_stdout));
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "sta.stderr", sta_stderr));
    }

    XLS_ASSIGN_OR_RETURN(STAStatistics sta_stats,
                         ParseOpenSTAOutput(sta_stdout));

    result->set_max_frequency_hz(sta_stats.max_frequency_hz);
    result->set_slack_ps(sta_stats.slack_ps);

    return absl::OkStatus();
  }

 private:
  std::string yosys_path_;
  std::string sta_path_;
  std::string synthesis_libraries_;
  std::string sta_libraries_;
};

void RealMain() {
  int port = absl::GetFlag(FLAGS_port);
  std::string server_address = absl::StrCat("0.0.0.0:", port);

  std::string yosys_path = absl::GetFlag(FLAGS_yosys_path);
  XLS_QCHECK_OK(FileExists(yosys_path));

  std::string sta_path = absl::GetFlag(FLAGS_sta_path);
  XLS_QCHECK_OK(FileExists(sta_path));

  std::string synthesis_libraries = absl::GetFlag(FLAGS_synthesis_libraries);
  XLS_QCHECK(!synthesis_libraries.empty())
      << "-synthesis_libraries must be provided";

  std::string sta_libraries = absl::GetFlag(FLAGS_sta_libraries);
  XLS_QCHECK(!sta_libraries.empty()) << "-sta_libraries must be provided";

  YosysStaServiceImpl service(yosys_path, sta_path, synthesis_libraries,
                              sta_libraries);

  ::grpc::ServerBuilder builder;
  std::shared_ptr<::grpc::ServerCredentials> creds = GetServerCredentials();
  builder.AddListeningPort(server_address, creds);
  builder.RegisterService(&service);
  std::unique_ptr<::grpc::Server> server(builder.BuildAndStart());

  XLS_LOG(INFO) << "Serving on port: " << port;
  XLS_LOG(INFO) << "synthesis_libraries: " << synthesis_libraries;
  XLS_LOG(INFO) << "sta_libraries: " << sta_libraries;

  server->Wait();
}

}  // namespace
}  // namespace synthesis
}  // namespace xls

int main(int argc, char** argv) {
  xls::InitXls(kUsage, argc, argv);

  xls::synthesis::RealMain();

  return EXIT_SUCCESS;
}
