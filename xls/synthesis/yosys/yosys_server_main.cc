// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/strings/str_join.h"
#include "absl/time/time.h"
#include "grpcpp/grpcpp.h"
#include "grpcpp/security/server_credentials.h"
#include "grpcpp/server.h"
#include "grpcpp/server_builder.h"
#include "grpcpp/server_context.h"
#include "xls/common/file/filesystem.h"
#include "xls/common/file/temp_directory.h"
#include "xls/common/file/temp_file.h"
#include "xls/common/init_xls.h"
#include "xls/common/logging/log_lines.h"
#include "xls/common/logging/logging.h"
#include "xls/common/status/ret_check.h"
#include "xls/common/status/status_macros.h"
#include "xls/common/subprocess.h"
#include "xls/synthesis/server_credentials.h"
#include "xls/synthesis/synthesis.pb.h"
#include "xls/synthesis/synthesis_service.grpc.pb.h"
#include "xls/synthesis/yosys/yosys_util.h"

const char kUsage[] =
    R"( Launches a XLS synthesis server which uses yosys and nextpnr for synthesis and
place-and-route.

Invocation:

  yosys_server --yosys_path=PATH --nextpnr_path=PATH
)";

ABSL_FLAG(int32_t, port, 10000, "Port to listen on.");
ABSL_FLAG(std::string, yosys_path, "", "The path to the yosys binary.");
ABSL_FLAG(std::string, nextpnr_path, "", "The path to the nextpnr binary.");
ABSL_FLAG(std::string, synthesis_target, "",
          "The backend to target for synthesis; e.g. ice40, ecp5.");
ABSL_FLAG(bool, save_temps, false, "Do not delete temporary files.");
ABSL_FLAG(bool, synthesis_only, false,
          "Perform synthesis but not place and route");
ABSL_FLAG(bool, return_netlist, true,
          "Return the netlist generated by synthesis");

namespace xls {
namespace synthesis {
namespace {

class YosysSynthesisServiceImpl : public SynthesisService::Service {
 public:
  explicit YosysSynthesisServiceImpl(std::string_view yosys_path,
                                     std::string_view nextpnr_path,
                                     std::string_view synthesis_target)
      : yosys_path_(yosys_path),
        nextpnr_path_(nextpnr_path),
        synthesis_target_(synthesis_target) {}

  ::grpc::Status Compile(::grpc::ServerContext* server_context,
                         const CompileRequest* request,
                         CompileResponse* result) override {
    auto start = absl::Now();

    absl::Status synthesis_status = RunSynthesis(request, result);
    if (!synthesis_status.ok()) {
      return ::grpc::Status(grpc::StatusCode::INTERNAL,
                            std::string(synthesis_status.message()));
    }

    result->set_elapsed_runtime_ms(
        absl::ToInt64Milliseconds(absl::Now() - start));

    return ::grpc::Status::OK;
  }

  // Run the given arguments as a subprocess with InvokeSubprocess.
  // InvokeSubprocess is wrapped because the error message can be very large (it
  // includes both stdout and stderr) which breaks propagation of the error via
  // GRPC because GRPC instead gives an error about trailing metadata being too
  // large.
  absl::StatusOr<std::pair<std::string, std::string>> RunSubprocess(
      absl::Span<const std::string> args) {
    absl::StatusOr<std::pair<std::string, std::string>> stdout_stderr_status =
        InvokeSubprocess(args);
    if (!stdout_stderr_status.ok()) {
      XLS_LOG(ERROR) << stdout_stderr_status.status();
      const int64_t kMaxMessageSize = 1024;
      auto prune_error_message = [](std::string_view message) -> std::string {
        if (message.size() >= kMaxMessageSize) {
          return absl::StrFormat(
              "%s\n...\n%s", message.substr(0, kMaxMessageSize),
              message.substr(message.size() - kMaxMessageSize));
        }
        return std::string(message);
      };
      return absl::InternalError(absl::StrFormat(
          "Failed to execute subprocess: %s. Error: %s",
          absl::StrJoin(args, " "),
          prune_error_message(stdout_stderr_status.status().message())));
    }
    return stdout_stderr_status;
  }

  // Invokes yosys and nextpnr to synthesis the verilog given in the
  // CompileRequest.
  absl::Status RunSynthesis(const CompileRequest* request,
                            CompileResponse* result) {
    if (request->top_module_name().empty()) {
      return absl::InvalidArgumentError("Must specify top module name.");
    }

    XLS_ASSIGN_OR_RETURN(TempDirectory temp_dir, TempDirectory::Create());
    std::filesystem::path temp_dir_path = temp_dir.path();
    if (absl::GetFlag(FLAGS_save_temps)) {
      std::move(temp_dir).Release();
    }
    std::filesystem::path verilog_path = temp_dir_path / "input.v";
    XLS_RETURN_IF_ERROR(SetFileContents(verilog_path, request->module_text()));

    // Invoke yosys to generate netlist.
    std::filesystem::path netlist_path = temp_dir_path / "netlist.json";
    std::pair<std::string, std::string> string_pair;
    std::string yosys_cmd =
        absl::StrFormat("synth_%s -top %s -json %s", synthesis_target_,
                        request->top_module_name(), netlist_path.string());
    XLS_LOG(INFO) << "yosys cmd: " << yosys_cmd;
    XLS_ASSIGN_OR_RETURN(
        string_pair,
        RunSubprocess({yosys_path_, "-p", yosys_cmd, verilog_path.string()}));
    auto [yosys_stdout, yosys_stderr] = string_pair;
    if (absl::GetFlag(FLAGS_save_temps)) {
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "yosys.stdout", yosys_stdout));
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "yosys.stderr", yosys_stderr));
    }
    XLS_ASSIGN_OR_RETURN(std::string netlist, GetFileContents(netlist_path));
    if (absl::GetFlag(FLAGS_return_netlist)) {
      result->set_netlist(netlist);
    }

    // Add stats in response.
    XLS_ASSIGN_OR_RETURN(YosysSynthesisStatistics parse_stats,
                         ParseYosysOutput(yosys_stdout));
    XLS_RET_CHECK(!result->has_instance_count());
    for (const auto& name_count : parse_stats.cell_histogram) {
      (*result->mutable_instance_count()
            ->mutable_cell_histogram())[name_count.first] = name_count.second;
    }

    // If only synthesis requested, done.
    if (absl::GetFlag(FLAGS_synthesis_only)) {
      return absl::OkStatus();
    }

    // Invoke nextpnr for place and route.
    std::optional<std::filesystem::path> pnr_path;
    std::vector<std::string> nextpnr_args = {nextpnr_path_, "--json",
                                             netlist_path.string()};

    if (synthesis_target_ == "ecp5") {
      nextpnr_args.push_back("--45k");
      nextpnr_args.push_back("--textcfg");
      pnr_path = temp_dir_path / "pnr.cfg";
      nextpnr_args.push_back(pnr_path->string());
    } else if (synthesis_target_ == "ice40") {
      nextpnr_args.push_back("--hx8k");
    }

    if (request->has_target_frequency_hz()) {
      nextpnr_args.push_back("--freq");
      nextpnr_args.push_back(
          absl::StrCat(request->has_target_frequency_hz() / 1000000));
    }
    XLS_ASSIGN_OR_RETURN(string_pair, RunSubprocess(nextpnr_args));
    auto [nextpnr_stdout, nextpnr_stderr] = string_pair;
    if (absl::GetFlag(FLAGS_save_temps)) {
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "nextpnr.stdout", nextpnr_stdout));
      XLS_RETURN_IF_ERROR(
          SetFileContents(temp_dir_path / "nextpnr.stderr", nextpnr_stderr));
    }

    if (pnr_path.has_value()) {
      XLS_ASSIGN_OR_RETURN(std::string pnr_result, GetFileContents(*pnr_path));
      result->set_place_and_route_result(pnr_result);
    }

    // Parse the stderr from nextpnr to get the maximum frequency.
    XLS_ASSIGN_OR_RETURN(int64_t max_frequency_hz,
                         ParseNextpnrOutput(nextpnr_stderr));
    result->set_max_frequency_hz(max_frequency_hz);
    XLS_LOG(INFO) << "max_frequency_mhz: " << (max_frequency_hz / 1e6);

    return absl::OkStatus();
  }

 private:
  std::string yosys_path_;
  std::string nextpnr_path_;
  std::string synthesis_target_;
};

void RealMain() {
  int port = absl::GetFlag(FLAGS_port);
  std::string server_address = absl::StrCat("0.0.0.0:", port);
  std::string yosys_path = absl::GetFlag(FLAGS_yosys_path);
  XLS_QCHECK_OK(FileExists(yosys_path));
  std::string nextpnr_path = absl::GetFlag(FLAGS_nextpnr_path);
  XLS_QCHECK_OK(FileExists(nextpnr_path));
  std::string synthesis_target = absl::GetFlag(FLAGS_synthesis_target);
  XLS_QCHECK(!synthesis_target.empty()) << "-synthesis_target must be provided";
  YosysSynthesisServiceImpl service(yosys_path, nextpnr_path, synthesis_target);

  ::grpc::ServerBuilder builder;
  std::shared_ptr<::grpc::ServerCredentials> creds = GetServerCredentials();
  builder.AddListeningPort(server_address, creds);
  builder.RegisterService(&service);
  std::unique_ptr<::grpc::Server> server(builder.BuildAndStart());
  XLS_LOG(INFO) << "Serving on port: " << port;
  XLS_LOG(INFO) << "synthesis_target: " << synthesis_target;
  server->Wait();
}

}  // namespace
}  // namespace synthesis
}  // namespace xls

int main(int argc, char** argv) {
  xls::InitXls(kUsage, argc, argv);

  xls::synthesis::RealMain();

  return EXIT_SUCCESS;
}
