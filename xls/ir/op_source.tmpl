#include "xls/ir/op.h"

#include "xls/common/logging/logging.h"
#include "xls/common/status/statusor.h"
#include "absl/container/flat_hash_map.h"

namespace xls {

std::string OpToString(Op op) {
  static const absl::flat_hash_map<Op, std::string>* op_map =
      new absl::flat_hash_map<Op, std::string>({
{% for op in spec.OPS -%}
{ OP_{{ op.name.upper() }}, "{{ op.name }}" },
{% endfor -%}
      });
  auto found = op_map->find(op);
  if (found == op_map->end()) {
    XLS_LOG(FATAL) << "OpToString(" << static_cast<uint64>(op)
               << ") failed, unknown op";
  }
  return found->second;
}

xabsl::StatusOr<Op> StringToOp(absl::string_view op_str) {
  static const absl::flat_hash_map<std::string, Op>* string_map =
      new absl::flat_hash_map<std::string, Op>({
{% for op in spec.OPS -%}
{"{{ op.name }}", OP_{{ op.name.upper() }}},
{% endfor -%}
      });
  auto found = string_map->find(op_str);
  if (found == string_map->end()) {
    return absl::InvalidArgumentError(
        absl::StrCat("Unknown operation for string-to-op conversion: ", op_str));
  }
  return found->second;
}

bool OpIsCompare(Op op) {
{% for op in spec.OPS -%}
{%- if spec.Property.COMPARISON in op.properties -%}
if (op == OP_{{ op.name.upper() }}) return true;
{% endif -%}
{% endfor -%}
  return false;
}

bool OpIsAssociative(Op op) {
{% for op in spec.OPS -%}
{%- if spec.Property.ASSOCIATIVE in op.properties -%}
if (op == OP_{{ op.name.upper() }}) return true;
{% endif -%}
{% endfor -%}
  return false;
}

bool OpIsCommutative(Op op) {
{% for op in spec.OPS -%}
{%- if spec.Property.COMMUTATIVE in op.properties -%}
if (op == OP_{{ op.name.upper() }}) return true;
{% endif -%}
{% endfor -%}
  return false;
}

bool OpIsBitWise(Op op) {
{% for op in spec.OPS -%}
{%- if spec.Property.BITWISE in op.properties -%}
if (op == OP_{{ op.name.upper() }}) return true;
{% endif -%}
{% endfor -%}
  return false;
}

{% for op_class in spec.OpClass.kinds.values() -%}
template<>
bool IsOpClass<{{op_class.name}}>(Op op) {
{% for op in spec.OPS -%}
{%- if op.op_class == op_class -%}
if (op == OP_{{ op.name.upper() }}) return true;
{% endif -%}
{% endfor -%}
  return false;
}

{% endfor %}

std::ostream& operator<<(std::ostream& os, Op op) {
  os << OpToString(op);
  return os;
}

}  // namespace xls
