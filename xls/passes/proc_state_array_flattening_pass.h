// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_PROC_STATE_ARRAY_FLATTENING_PASS_H_
#define XLS_PASSES_PROC_STATE_ARRAY_FLATTENING_PASS_H_

#include <cstdint>
#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/proc.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which flattens array elements of the proc state into their constituent
// elements. Tuples are flattened in a different pass. Flattening improves
// optimizability because each state element can be considered and transformed
// in isolation. Flattening also gives the scheduler more flexibility; without
// flattening, each element in the aggregate must have the same lifetime.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ProcStateArrayFlatteningPass` is an optimization pass designed to
// enhance the optimizability and scheduling flexibility of Procs in XLS. Its
// core function is to transform one-dimensional, array-typed state elements
// within the proc state into a tuple of their individual constituent elements.
// (Note: A distinct pass, `ProcStateTupleFlatteningPass`, is responsible for
// handling the flattening of tuple-typed state elements.)
//
// The rationale behind this flattening is multifaceted:
//
// 1.  **Improved Optimizability**: By breaking down arrays into their
//     individual elements, subsequent optimization passes (such as narrowing,
//     constant folding, or dead code elimination) can consider and transform
//     each element in isolation. This often enables more aggressive and
//     effective optimizations that might be inhibited when elements are tightly
//     coupled within an array structure.
//
// 2.  **Increased Scheduler Flexibility**: When a state element is represented
//     as an array, all elements within that array are typically treated as a
//     single, atomic unit by the scheduler. This implies that they must all
//     have the same lifetime and be updated or accessed simultaneously. By
//     flattening the array into a tuple of individual elements, the scheduler
//     gains greater flexibility. Each element can then potentially have an
//     independent lifetime, enabling more efficient scheduling and resource
//     allocation in the generated hardware.
//
// The pass identifies array-typed state elements that are suitable for
// flattening. Currently, the heuristic for flattening is to unconditionally
// flatten "small" arrays, specifically those with a size of 2 or less. While a
// `kMaxArrayFlattenSize` constant is defined, the current implementation
// applies a stricter size limit.
//
// The transformation process for an array-typed state element (e.g.,
// `state: bits[8][2]`) involves:
//
// 1.  **Determining Flattening**: The `ShouldFlattenStateElement` function
//     checks if a given state element is an array and meets the predefined size
//     heuristic for flattening.
//
// 2.  **Transforming `StateElement` Type**: The original array-typed
//     `StateElement` is replaced by a new `StateElement` of a tuple type, where
//     each element of the tuple corresponds to an element of the original
//     array. For example, an `ArrayType` of `bits[8][2]` becomes a `TupleType`
//     of `(bits[8], bits[8])`.
//
// 3.  **Transforming `initial_value`**: The initial value of the `StateElement`
//     is converted from an array literal to a tuple literal with the
//     corresponding element values.
//
// 4.  **Transforming `StateRead` Operations**: Any `StateRead` operation that
//     previously read the array-typed state element is modified. Instead of
//     directly reading the array, it now reads the new tuple-typed state
//     element. Its uses are then replaced by an `array` operation that
//     reconstructs the original array from `tuple_index` operations on the new
//     tuple-typed state read. This ensures that any downstream logic consuming
//     the original array continues to see the expected array structure.
//
// 5.  **Transforming `Next` Operations**: Any `next_value` operation that
//     computed the next state for the array-typed element is also modified. Its
//     `value` operand (which would have been an array) is transformed into a
//     tuple by creating `array_index` operations for each element of the
//     original array and then wrapping these in a `tuple` operation.
//
// Example:
// Consider a Proc with a state element `state` that is a 2-element array of
// `bits[8]`:
//
//
// ```
// // Original IR snippet
// package my_package
//
// proc my_proc(state: bits[8][2], init={0, 1}) {
//   // ...
//   state_read.0: bits[8][2] = state_read(state)
//   idx0: bits[32] = literal(0)
//   elem0: bits[8] = array_index(state_read.0, indices=[idx0])
//   // ... further usage of elem0
//   // computes next state as an array
//   next_val: bits[8][2] = array(literal(1), literal(2))
//   next (state, next_val)
// }
// ```
//
//
// After `ProcStateArrayFlatteningPass`, the `state` element would be flattened
// into a tuple `(bits[8], bits[8])`:
//
//
// ```
// // Optimized IR snippet (simplified)
// package my_package
//
// // state is now a tuple
// proc my_proc(state: (bits[8], bits[8]), init={(0, 1)}) {
//   // ...
//   state_read.0: (bits[8], bits[8]) = state_read(state) // Reads the tuple
//   elem0_from_tuple: bits[8] = tuple_index(state_read.0, index=0)
//   elem1_from_tuple: bits[8] = tuple_index(state_read.0, index=1)
//   // Any original uses of `state_read.0` would be replaced by an `array` of
//   // these tuple_indexed elements.
//   reconstructed_array: bits[8][2] = array(elem0_from_tuple, elem1_from_tuple)
//
//   // next_value now produces a tuple (assuming original `next_val` was an
//   // array of literals)
//   next_val_tuple: (bits[8], bits[8]) = tuple(literal(1), literal(2))
//   next (state, next_val_tuple)
// }
// ```
//
// This transformation facilitates creating more fine-grained control and
// optimization opportunities for individual elements of the original array,
// which is highly beneficial for hardware synthesis.
class ProcStateArrayFlatteningPass : public OptimizationProcPass {
 public:
  static constexpr std::string_view kName = "proc_state_array_flat";

  // Array simplification can flatten proc state arrays into elements. This is
  // the maximum length of an array it will flatten.
  static constexpr int64_t kMaxArrayFlattenSize = 4096;

  ProcStateArrayFlatteningPass()
      : OptimizationProcPass(kName, "Proc State Array Flattening") {}
  ~ProcStateArrayFlatteningPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnProcInternal(
      Proc* proc, const OptimizationPassOptions& options, PassResults* results,
      OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_PROC_STATE_ARRAY_FLATTENING_PASS_H_
