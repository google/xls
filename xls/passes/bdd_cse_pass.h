// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_BDD_CSE_PASS_H_
#define XLS_PASSES_BDD_CSE_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which commons equivalent expressions in the graph using binary decision
// diagrams.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `BddCsePass` (BDD-based Common Subexpression Elimination) is an
// optimization pass in XLS that identifies and merges logically equivalent
// expressions within a function or proc by leveraging Binary Decision Diagrams
// (BDDs). Unlike the purely syntactic `CsePass`, `BddCsePass` can detect
// equivalences even when the expressions have different syntactic forms, as it
// relies on the canonical representation of Boolean functions provided by BDDs.
// This capability leads to more aggressive common subexpression elimination and
// significantly reduces hardware redundancy.
//
// **How it Works**:
//
// 1.  **BDD Representation**: The core of this pass is the `BddQueryEngine`.
//     For each bit-typed node in the function, the `BddQueryEngine` constructs
//     a Binary Decision Diagram. A BDD is a directed acyclic graph that
//     represents a Boolean function. Crucially, for any given Boolean function,
//     its BDD is canonical (unique) if a fixed variable ordering is used. This
//     property allows the pass to determine if two different expressions
//     compute the same Boolean function simply by comparing their BDDs.
//
// 2.  **Node Ordering for Determinism and Performance**: The pass first
//     determines a specific order in which to process the nodes
//     (`GetNodeOrder`). This order is a topological sort (necessary to avoid
//     introducing cycles) and prioritizes nodes on less critical paths. This
//     prioritization helps ensure that CSE replacements do not inadvertently
//     increase the overall critical path delay of the design.
//
// 3.  **Equivalence Bucketing**: The pass iterates through the nodes in the
//     determined order. For each bit-typed node, it computes a hash value based
//     on the BDD node indices of all its constituent bits. Nodes with the same
//     hash are grouped together into "node buckets," as they are *potentially*
//     logically equivalent.
//
// 4.  **Logical Equivalence Check**: Within each bucket, the pass performs a
//     pairwise comparison of nodes using the `is_same_value` function. This
//     function directly compares the BDDs of the two nodes. If their BDDs are
//     identical, the nodes are confirmed to be logically equivalent.
//
// 5.  **Replacement**: When two or more logically equivalent nodes are found
//     (e.g., `node_A` and `node_B`, where `node_A` was encountered earlier in
//     the `node_order` and is chosen as the representative):
//
//     *   The later encountered node (`node_B`) is replaced by the earlier node
//         (`node_A`). This means all users of `node_B` are rewired to use
//         `node_A` instead.
//
//     *   The pass records that a change occurred.
//
// 6.  **Post-DCE**: After `BddCsePass` has completed its execution, a
//     `DeadCodeEliminationPass` is typically run. This is essential to remove
//     any nodes that became dead code as a result of being replaced by an
//     equivalent node, further cleaning up the IR.
//
// **Benefits**:
//
// *   **Semantic Equivalence**: `BddCsePass` excels at identifying and
//     commoning subexpressions that are semantically (logically) equivalent,
//     even if their textual representation in the IR is different. This is a
//     significant advantage over purely syntactic CSE approaches.
//
// *   **Hardware Reduction**: By eliminating redundant computations, the pass
//     directly reduces the amount of hardware required, leading to smaller
//     area, lower power consumption, and potentially faster circuits.
//
// *   **Improved IR Quality**: The resulting IR is more compact, canonical, and
//     easier for subsequent optimization and synthesis tools to process.
//
// Example:
// Consider two expressions that compute the same Boolean function but have
// different IR structures: `x_eq_42: bits[1] = eq(x, literal(42))` and
// `forty_two_not_ne_x: bits[1] = not(ne(literal(42), x))`.
// Syntactically, these expressions are different.
//
//
// ```
// // Original IR snippet
// fn FuzzTest(x: bits[16]) -> (bits[1], bits[1]) {
//   forty_two: bits[16] = literal(value=42)
//   x_eq_42: bits[1] = eq(x, forty_two)
//   forty_two_not_ne_x: bits[1] = not(ne(forty_two, x))
//   ret tuple.0: (bits[1], bits[1]) = tuple(x_eq_42, forty_two_not_ne_x)
// }
// ```
//
//
// `BddCsePass` would build BDDs for both `x_eq_42` and `forty_two_not_ne_x`.
// Since these two expressions are logically equivalent, their BDDs would be
// identical. The pass would then replace one with the other (e.g.,
// `forty_two_not_ne_x` would be replaced by `x_eq_42`), resulting in shared
// logic:
//
//
// ```
// // Optimized IR (after BddCsePass and a subsequent DCE pass)
// fn FuzzTest(x: bits[16]) -> (bits[1], bits[1]) {
//   forty_two: bits[16] = literal(value=42)
//   x_eq_42: bits[1] = eq(x, forty_two)
//   ret tuple.0: (bits[1], bits[1]) = tuple(x_eq_42, x_eq_42)
// }
// ```
//
// This effectively eliminates the redundant computation of the second
// comparison, leading to a more optimized design.
class BddCsePass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "bdd_cse";
  explicit BddCsePass()
      : OptimizationFunctionBasePass(
            kName, "BDD-based Common Subexpression Elimination") {}
  ~BddCsePass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_BDD_CSE_PASS_H_
