// Copyright 2025 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_RESOURCE_SHARING_PASS_H_
#define XLS_PASSES_RESOURCE_SHARING_PASS_H_

#include <algorithm>
#include <cstdint>
#include <memory>
#include <optional>
#include <string_view>
#include <utility>
#include <vector>

#include "absl/container/flat_hash_set.h"
#include "absl/status/statusor.h"
#include "absl/types/span.h"
#include "xls/estimators/area_model/area_estimator.h"
#include "xls/ir/function_base.h"
#include "xls/ir/node.h"
#include "xls/ir/node_util.h"
#include "xls/passes/folding_graph.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"
#include "xls/passes/visibility_analysis.h"
#include "xls/passes/visibility_expr_builder.h"

namespace xls {

// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ResourceSharingPass` is a critical optimization pass in XLS that aims to
// reduce hardware area by sharing common computational resources (e.g., adders,
// multipliers) among different parts of the design. This is achieved by
// identifying mutually exclusive operations—operations that are guaranteed not
// to execute at the same time—and then transforming the IR to allow them to
// share the same physical hardware resource through multiplexing.
//
// The pass is configured with a `ProfitabilityGuard` enum, which determines the
// heuristic used to select which sharing opportunities to exploit:
//
// *   **`kInDegree`**: Prioritizes sharing based on the in-degree of nodes in
//     a conceptual "folding graph." This heuristic favors nodes that are
//     potential "destinations" for folding, especially those with more distinct
//     "source" operations that can be multiplexed into them. This approach is
//     often effective for asymmetric folding scenarios where one complex
//     operation can subsume several simpler ones.
// *   **`kCliques`**: Selects sharing opportunities based on identifying
//     cliques (groups of mutually exclusive operations) in the folding graph.
//     This approach is particularly suitable for symmetric folding scenarios
//     where multiple operations of similar complexity can all share a single
//     resource.
// *   **`kRandom`**: Randomly selects a subset of potential folding actions.
//     This is typically used for testing, fuzzing, or exploration purposes
//     rather than for deterministic optimization.
// *   **`kAlways`**: Attempts to perform all possible resource sharing that is
//     identified as legal. This is generally used for aggressive optimization
//     benchmarking or during specific testing phases.
//
// The core mechanism of `ResourceSharingPass` involves several stages:
//
// 1.  **Mutual Exclusion Analysis**:
//     *   **`ComputeMutualExclusionAnalysis`**: This is a central function that
//         identifies pairs or groups of operations that are mutually exclusive.
//         It builds a "mutual exclusivity relation" between nodes, proving that
//         two operations are guaranteed not to be active simultaneously.
//     *   It leverages `NodeForwardDependencyAnalysis` to trace dataflow
//         dependencies and `BddQueryEngine` (Binary Decision Diagrams) for
//         precise logical analysis. The `BddQueryEngine` is critical for
//         proving that a particular operation's value does not influence
//         another under specific conditions (e.g., when a particular arm of a
//         `select` operation is chosen).
//     *   The analysis primarily focuses on `PrioritySelect` operations, as
//         these explicitly define conditional execution paths, which naturally
//         create clear mutual exclusivity between their cases. The analysis is
//         conservative and avoids making assumptions through `Invoke` nodes
//         before function inlining to ensure correctness.
//
// 2.  **Folding Graph Construction**: Based on the results of the mutual
//     exclusivity analysis, a `FoldingGraph` is constructed. This graph
//     represents potential "folding actions," where a "source" operation can be
//     "folded" into a "destination" operation, implying that they can share the
//     same underlying hardware resource. This sharing is controlled by a
//     `select` operation whose condition is derived from the mutual exclusivity
//     proof.
//
// 3.  **Profitability Estimation**:
//     *   The pass utilizes `AreaEstimator` and `DelayEstimator` tools to
//         assess the profitability of each potential folding action. This
//         involves a cost-benefit analysis.
//     *   `EstimateAreaForSelectingASingleInput`: Calculates the area overhead
//         associated with adding multiplexers (`select` logic) required to
//         steer the inputs to a shared resource.
//     *   `EstimateAreaForNegatingNode`: Estimates the area cost if an operand
//         needs to be negated (e.g., when folding a `sub` operation into an
//         `add` operation that operates on the negated operand).
//     *   The `area_saved` for a folding action is calculated as the estimated
//         area of the "from" node minus the area overhead of the multiplexers
//         and any additional required logic.
//     *   `DelayAnalysis` is used to consider the impact of sharing on the
//         critical path delay. The `kMaxDelaySpread` constant defines an
//         acceptable limit for the increase in delay due to multiplexing.
//
// 4.  **Selection of Folding Actions**:
//     *   `SelectFoldingActions`: This function, guided by the chosen
//         `ProfitabilityGuard` heuristic, selects a subset of the legal and
//         profitable folding actions to perform.
//     *   It prioritizes actions that offer significant area savings while
//         keeping delay impacts within acceptable bounds.
//     *   The selected actions are sorted (e.g., by descending area savings)
//         and then "legalized" (`LegalizeSequenceOfFolding`) to prevent
//         overlapping or conflicting transformations from being applied.
//
// 5.  **IR Transformation**: Once a final set of `NaryFoldingAction`s is
//     selected, the IR is transformed to implement the sharing. This involves:
//     *   Creating new `select` or `priority_select` operations (or chains of
//         them) to multiplex the inputs of the shared resource based on the
//         conditions derived from the original mutual exclusivity.
//     *   Replacing the original "from" operations with the output of the newly
//         created multiplexing structure, which then feeds into the "to"
//         (shared) operation.
//     *   Removing the now redundant "from" operations.
//
// Example:
// Consider two `umul` operations, `mul0(a, b)` and `mul1(c, d)`, which are
// mutually exclusive (e.g., they are in different arms of a `priority_select`).
// The `ResourceSharingPass` might identify this and transform the IR to use a
// single shared `umul` hardware resource:
//
//
// ```
// // Original IR snippet (simplified)
// selector: bits[1] = ...
// mul0: bits[32] = umul(a, b, width=32)
// mul1: bits[32] = umul(c, d, width=32)
// ret result: bits[32] = priority_sel(selector, cases=[mul0], default=mul1)
// ```
//
//
// After `ResourceSharingPass` (conceptual representation, as actual IR is more
// complex with explicit multiplexing):
//
//
// ```
// // Optimized IR snippet (simplified)
// selector: bits[1] = ...
//
// // Multiplexed inputs to the shared multiplier
// input_a_mux: bits[32] = priority_sel(selector, cases=[a], default=c)
// input_b_mux: bits[32] = priority_sel(selector, cases=[b], default=d)
//
// // Shared multiplier operation
// umul_shared: bits[32] = umul(input_a_mux, input_b_mux, width=32)
//
// ret result: bits[32] = umul_shared // The shared multiplier is now the result
// ```
//
// This pass is vital for achieving high-quality hardware designs by efficiently
// utilizing available hardware resources, particularly in designs with
// significant conditional logic.
class ResourceSharingPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "resource_sharing";

  struct Config {
    const double min_area_savings;
    const double max_delay_spread_squared;
    const uint64_t max_delay_increase;
    const uint64_t max_delay_increase_per_fold;
    const int64_t max_edges_to_handle;
    const int64_t max_path_count_for_edge_in_general_visibility_analysis;
    const int64_t max_path_count_for_bdd_engine;
  };

  // TODO: area vs. delay trade-off heuristics in resource sharing should be
  // queried from area/delay models instead of being hard-coded on this pass.
  // avoids folds with small area savings on certain ops
  static constexpr double kDefaultMinAreaSavings = 12.0;
  static constexpr double kDefaultMaxDelaySpread = 320.0;
  static constexpr double kDefaultMaxDelaySpreadSquared =
      kDefaultMaxDelaySpread * kDefaultMaxDelaySpread;
  // avoids folds with too large a delay increase or (delay spread)^2
  static constexpr uint64_t kDefaultMaxDelayIncrease = 2000;
  static constexpr uint64_t kDefaultMaxDelayIncreasePerFold = 200;

  // avoids large visibility expressions that will likely be disqualified later
  // also, pruning edges is O(edges^2), so this value should be relatively small
  static constexpr int64_t kDefaultMaxEdgesToHandle = 50;
  // the BDD expression path count for each edge is much more constrained than
  // the total path count to prevent a conservatively chosen visibility
  // expression being dominated by a single, complicated edge.
  static constexpr int64_t
      kDefaultMaxPathCountForEdgeInGeneralVisibilityAnalysis = 64;
  static constexpr int64_t kDefaultMaxPathCountForBddEngine = 4096;

  struct MutuallyExclPair {
    Node* one;
    Node* other;
    MutuallyExclPair(Node* a, Node* b)
        : one(std::min(a, b, NodeIdLessThan)),
          other(std::max(a, b, NodeIdLessThan)) {}
    bool operator==(const MutuallyExclPair& o) const {
      return one == o.one && other == o.other;
    }
    template <typename H>
    friend H AbslHashValue(H h, const MutuallyExclPair& d) {
      return H::combine(std::move(h), d.one, d.other);
    }
  };

  // TODO: replace with a single visibility analysis that computes a variety of
  // conservative visibility expressions with different trade-offs and that
  // can be queried to provide the simplest visibility expressions it knows
  // which prove the mutual exclusivity of a set of nodes.
  struct VisibilityAnalyses {
    const VisibilityAnalysis& general;
    const SingleSelectVisibilityAnalysis& single_select;
  };

  ~ResourceSharingPass() override = default;

  enum class ProfitabilityGuard {
    kInDegree,

    kCliques,

    kRandom,  // This heuristic makes this pass not deterministic when different
              // seeds of the PRVG are used.

    kAlways,  // This heuristic applies resource sharing whenever possible. This
              // is used for testing only.
  };

  // This function computes the set of mutual exclusive pairs of instructions.
  // Each pair of instruction is associated with the select (of any kind) that
  // made them mutually exclusive.
  // We later use this association to extract the conditions to decide which
  // inputs to use at the folded remaining node.
  //
  // This analysis is conservative and as such it might generate false
  // negatives. In other words, some mutually-exclusive pairs of instructions
  // might not be detected by this analysis. Hence, this analysis can be
  // improved in the future.
  static absl::StatusOr<absl::flat_hash_set<MutuallyExclPair>>
  ComputeMutualExclusionAnalysis(FunctionBase* f, OptimizationContext& context,
                                 const VisibilityAnalyses& visibility,
                                 const Config& config);

  // This function returns all possible folding actions that we can legally
  // perform.
  static absl::StatusOr<std::vector<std::unique_ptr<BinaryFoldingAction>>>
  ComputeFoldableActions(
      FunctionBase* f,
      absl::flat_hash_set<MutuallyExclPair>& mutual_exclusivity,
      const VisibilityAnalyses& visibility, const Config& config);

  // MakeNaryFoldingActions creates a single n-ary folding action from as many
  // of the provided binary foldings as possible, given our understanding of the
  // visibility of these nodes. It is possible that one of the binary foldings
  // is on a node whose conservative visibility expression is too complicated to
  // analyze efficiently, in which case we must drop that binary folding.
  static absl::StatusOr<std::unique_ptr<NaryFoldingAction>>
  MakeNaryFoldingAction(std::vector<BinaryFoldingAction*>& subset_of_edges_to_n,
                        double area_saved, const VisibilityAnalyses& visibility,
                        const Config& config);

  // Legalizes a sequence of folding actions by removing or modifying actions
  // that conflict.
  //
  // Returns a pair where the first element is the legalized sequence of
  // actions and the second element is a boolean that is true if the input
  // sequence was modified.
  static absl::StatusOr<
      std::pair<std::vector<std::unique_ptr<NaryFoldingAction>>, bool>>
  LegalizeSequenceOfFolding(
      absl::Span<const std::unique_ptr<NaryFoldingAction>>
          potential_folding_actions_to_perform,
      absl::flat_hash_set<ResourceSharingPass::MutuallyExclPair>&
          mutual_exclusivity,
      std::optional<const AreaEstimator*> area_estimator, const Config& config);

  // This function performs the folding actions specified in its input following
  // the order specified.
  // @next_node_id is used to determine what nodes were generated by this pass
  // and is only used for logging purposes; see ToMathNotation.
  static absl::StatusOr<bool> PerformFoldingActions(
      FunctionBase* f, int64_t next_node_id,
      VisibilityBuilder* visibility_builder,
      const std::vector<std::unique_ptr<NaryFoldingAction>>&
          folding_actions_to_perform);

  // WARNING: The constructor arguments here are available primarily for use by
  // automated tuning software such as vizier. Changing the parameter values can
  // have hard to predict effects on the quality of the resulting IR. The set of
  // options available now should not be considered stable and may be changed at
  // any time for any reason.
  explicit ResourceSharingPass(
      ProfitabilityGuard profitability_guard = ProfitabilityGuard::kInDegree,
      double min_area_savings = kDefaultMinAreaSavings,
      double max_delay_spread_squared = kDefaultMaxDelaySpreadSquared,
      uint64_t max_delay_increase = kDefaultMaxDelayIncrease,
      uint64_t max_delay_increase_per_fold = kDefaultMaxDelayIncreasePerFold,
      int64_t max_edges_to_handle = kDefaultMaxEdgesToHandle,
      int64_t max_path_count_for_edge_in_general_visibility_analysis =
          kDefaultMaxPathCountForEdgeInGeneralVisibilityAnalysis,
      int64_t max_path_count_for_bdd_engine = kDefaultMaxPathCountForBddEngine)
      : OptimizationFunctionBasePass(kName, "Resource Sharing"),
        profitability_guard_(profitability_guard),
        config_(min_area_savings, max_delay_spread_squared, max_delay_increase,
                max_delay_increase_per_fold, max_edges_to_handle,
                max_path_count_for_edge_in_general_visibility_analysis,
                max_path_count_for_bdd_engine) {}

  constexpr static Config kDefaultConfig = {
      .min_area_savings = ResourceSharingPass::kDefaultMinAreaSavings,
      .max_delay_spread_squared =
          ResourceSharingPass::kDefaultMaxDelaySpreadSquared,
      .max_delay_increase = ResourceSharingPass::kDefaultMaxDelayIncrease,
      .max_delay_increase_per_fold =
          ResourceSharingPass::kDefaultMaxDelayIncreasePerFold,
      .max_edges_to_handle = ResourceSharingPass::kDefaultMaxEdgesToHandle,
      .max_path_count_for_edge_in_general_visibility_analysis =
          ResourceSharingPass::
              kDefaultMaxPathCountForEdgeInGeneralVisibilityAnalysis,
      .max_path_count_for_bdd_engine =
          ResourceSharingPass::kDefaultMaxPathCountForBddEngine,
  };

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;

 private:
  ProfitabilityGuard profitability_guard_;
  Config config_;
};
}  // namespace xls

#endif  // XLS_PASSES_RESOURCE_SHARING_PASS_H_
