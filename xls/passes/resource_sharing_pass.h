// Copyright 2025 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_RESOURCE_SHARING_PASS_H_
#define XLS_PASSES_RESOURCE_SHARING_PASS_H_

#include <string_view>
#include <utility>
#include <vector>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/ir/node.h"
#include "xls/passes/bdd_query_engine.h"
#include "xls/passes/node_dependency_analysis.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"
#include "xls/passes/query_engine.h"

namespace xls {

// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ResourceSharingPass` is a critical optimization pass in XLS that aims to
// reduce hardware area by sharing common computational resources (e.g., adders,
// multipliers) among different parts of the design. This is achieved by
// identifying mutually exclusive operations—operations that are guaranteed not
// to execute at the same time—and then transforming the IR to allow them to
// share the same physical hardware resource through multiplexing.
//
// The pass is configured with a `ProfitabilityGuard` enum, which determines the
// heuristic used to select which sharing opportunities to exploit:
//
// *   **`kInDegree`**: Prioritizes sharing based on the in-degree of nodes in
//     a conceptual "folding graph." This heuristic favors nodes that are
//     potential "destinations" for folding, especially those with more distinct
//     "source" operations that can be multiplexed into them. This approach is
//     often effective for asymmetric folding scenarios where one complex
//     operation can subsume several simpler ones.
// *   **`kCliques`**: Selects sharing opportunities based on identifying
//     cliques (groups of mutually exclusive operations) in the folding graph.
//     This approach is particularly suitable for symmetric folding scenarios
//     where multiple operations of similar complexity can all share a single
//     resource.
// *   **`kRandom`**: Randomly selects a subset of potential folding actions.
//     This is typically used for testing, fuzzing, or exploration purposes
//     rather than for deterministic optimization.
// *   **`kAlways`**: Attempts to perform all possible resource sharing that is
//     identified as legal. This is generally used for aggressive optimization
//     benchmarking or during specific testing phases.
//
// The core mechanism of `ResourceSharingPass` involves several stages:
//
// 1.  **Mutual Exclusion Analysis**:
//     *   **`ComputeMutualExclusionAnalysis`**: This is a central function that
//         identifies pairs or groups of operations that are mutually exclusive.
//         It builds a "mutual exclusivity relation" between nodes, proving that
//         two operations are guaranteed not to be active simultaneously.
//     *   It leverages `NodeForwardDependencyAnalysis` to trace dataflow
//         dependencies and `BddQueryEngine` (Binary Decision Diagrams) for
//         precise logical analysis. The `BddQueryEngine` is critical for
//         proving that a particular operation's value does not influence
//         another under specific conditions (e.g., when a particular arm of a
//         `select` operation is chosen).
//     *   The analysis primarily focuses on `PrioritySelect` operations, as
//         these explicitly define conditional execution paths, which naturally
//         create clear mutual exclusivity between their cases. The analysis is
//         conservative and avoids making assumptions through `Invoke` nodes
//         before function inlining to ensure correctness.
//
// 2.  **Folding Graph Construction**: Based on the results of the mutual
//     exclusivity analysis, a `FoldingGraph` is constructed. This graph
//     represents potential "folding actions," where a "source" operation can be
//     "folded" into a "destination" operation, implying that they can share the
//     same underlying hardware resource. This sharing is controlled by a
//     `select` operation whose condition is derived from the mutual exclusivity
//     proof.
//
// 3.  **Profitability Estimation**:
//     *   The pass utilizes `AreaEstimator` and `DelayEstimator` tools to
//         assess the profitability of each potential folding action. This
//         involves a cost-benefit analysis.
//     *   `EstimateAreaForSelectingASingleInput`: Calculates the area overhead
//         associated with adding multiplexers (`select` logic) required to
//         steer the inputs to a shared resource.
//     *   `EstimateAreaForNegatingNode`: Estimates the area cost if an operand
//         needs to be negated (e.g., when folding a `sub` operation into an
//         `add` operation that operates on the negated operand).
//     *   The `area_saved` for a folding action is calculated as the estimated
//         area of the "from" node minus the area overhead of the multiplexers
//         and any additional required logic.
//     *   `DelayAnalysis` is used to consider the impact of sharing on the
//         critical path delay. The `kMaxDelaySpread` constant defines an
//         acceptable limit for the increase in delay due to multiplexing.
//
// 4.  **Selection of Folding Actions**:
//     *   `SelectFoldingActions`: This function, guided by the chosen
//         `ProfitabilityGuard` heuristic, selects a subset of the legal and
//         profitable folding actions to perform.
//     *   It prioritizes actions that offer significant area savings while
//         keeping delay impacts within acceptable bounds.
//     *   The selected actions are sorted (e.g., by descending area savings)
//         and then "legalized" (`LegalizeSequenceOfFolding`) to prevent
//         overlapping or conflicting transformations from being applied.
//
// 5.  **IR Transformation**: Once a final set of `NaryFoldingAction`s is
//     selected, the IR is transformed to implement the sharing. This involves:
//     *   Creating new `select` or `priority_select` operations (or chains of
//         them) to multiplex the inputs of the shared resource based on the
//         conditions derived from the original mutual exclusivity.
//     *   Replacing the original "from" operations with the output of the newly
//         created multiplexing structure, which then feeds into the "to"
//         (shared) operation.
//     *   Removing the now redundant "from" operations.
//
// Example:
// Consider two `umul` operations, `mul0(a, b)` and `mul1(c, d)`, which are
// mutually exclusive (e.g., they are in different arms of a `priority_select`).
// The `ResourceSharingPass` might identify this and transform the IR to use a
// single shared `umul` hardware resource:
//
//
// ```
// // Original IR snippet (simplified)
// selector: bits[1] = ...
// mul0: bits[32] = umul(a, b, width=32)
// mul1: bits[32] = umul(c, d, width=32)
// ret result: bits[32] = priority_sel(selector, cases=[mul0], default=mul1)
// ```
//
//
// After `ResourceSharingPass` (conceptual representation, as actual IR is more
// complex with explicit multiplexing):
//
//
// ```
// // Optimized IR snippet (simplified)
// selector: bits[1] = ...
//
// // Multiplexed inputs to the shared multiplier
// input_a_mux: bits[32] = priority_sel(selector, cases=[a], default=c)
// input_b_mux: bits[32] = priority_sel(selector, cases=[b], default=d)
//
// // Shared multiplier operation
// umul_shared: bits[32] = umul(input_a_mux, input_b_mux, width=32)
//
// ret result: bits[32] = umul_shared // The shared multiplier is now the result
// ```
//
// This pass is vital for achieving high-quality hardware designs by efficiently
// utilizing available hardware resources, particularly in designs with
// significant conditional logic.
class ResourceSharingPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "resource_sharing";

  // avoids folds with small area savings on certain ops
  static constexpr double kMinAreaSavings = 10.0;
  static constexpr double kMaxDelaySpread = 320.0 * 320.0;

  explicit ResourceSharingPass();

  ~ResourceSharingPass() override = default;

  enum class ProfitabilityGuard {
    kInDegree,

    kCliques,

    kRandom,  // This heuristic makes this pass not deterministic when different
              // seeds of the PRVG are used.

    kAlways,  // This heuristic applies resource sharing whenever possible. This
              // is used for testing only.
  };

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;

 private:
  ProfitabilityGuard profitability_guard_;
};

bool InfluencedBySource(
    Node* node, Node* source, const NodeForwardDependencyAnalysis& nda,
    const BddQueryEngine& bdd_engine,
    const std::vector<std::pair<TreeBitLocation, bool>>& assumptions);

}  // namespace xls

#endif  // XLS_PASSES_RESOURCE_SHARING_PASS_H_
