// Copyright 2023 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_BASIC_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_BASIC_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// This pass does simple pattern-matching optimizations which are ~always a good
// idea to do (replacing a node with a constant, removing operands of nodes,
// etc). They improve QoR, do not increase the number of nodes in the graph,
// preserve the same abstraction level, and do not impede later optimizations
// via obfuscation. These optimizations require no analyses beyond looking at
// the node and its operands. Examples include: not(not(x)) => x, x + 0 => x,
// etc.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `BasicSimplificationPass` applies a collection of straightforward,
// pattern-matching optimizations to the XLS IR. These optimizations are
// designed to improve the Quality of Results (QoR) without significantly
// increasing the number of nodes in the graph, preserving the current
// abstraction level, and avoiding obfuscation that might hinder subsequent
// optimization passes. The pass primarily relies on local analysis of a node
// and its immediate operands.
//
// The pass iteratively traverses the nodes in the function (or proc) and
// attempts to apply various simplification patterns until a fixed point is
// reached (no further changes can be made).
//
// Key simplifications performed by this pass include:
//
// 1.  **Identity Operations**:
//     *   `add(x, 0)` => `x` (and similar for `sub`, `shll`, `shrl`, `shra`
//         with 0)
//     *   `and(x, x)` => `x` (and `or(x, x)` => `x`)
//     *   `nand(x, x, x)` => `not(x)`
//     *   `xor(x, x)` => `0` (for an even number of identical `x` operands)
//     *   `xor(x, x, x)` => `x` (for an odd number of identical `x` operands)
//     *   `not(not(x))` => `x`
//     *   `neg(neg(x))` => `x`
//     *   `and_reduce(x)` => `x` (if `x` is 1-bit)
//     *   `or_reduce(x)` => `x` (if `x` is 1-bit)
//     *   `xor_reduce(x)` => `x` (if `x` is 1-bit)
//     *   `priority_sel(bits[0], cases=[], default=X)` => `X` (a priority
//         select with a zero-width selector always selects its default value).
//
// 2.  **Constant Propagation and Folding**:
//     *   `umul(x, 0)` or `smul(x, 0)` => `0`
//     *   `or(x, -1)` => `-1` (all ones literal)
//     *   `nor(x, -1)` => `0`
//     *   `and(x, 0)` => `0`
//     *   `nand(x, 0)` => `1`
//     *   `xor(x, -1)` => `not(x)`
//     *   `and_reduce([])` => `1` (identity for AND reduction on an empty set)
//     *   `or_reduce([])` => `0` (identity for OR reduction on an empty set)
//     *   `xor_reduce([])` => `0` (identity for XOR reduction on an empty set)
//     *   Consolidation of multiple literal operands in associative/commutative
//         N-ary operations (e.g., `and(x, literal_A, y, literal_B)` =>
//         `and(x, y, literal_A_and_B)`).
//
// 3.  **Boolean Algebra Simplifications**:
//     *   `and(x, not(x))` => `0`
//     *   `or(x, not(x))` => `1`
//     *   `add(x, not(x))` => `1` (for `bits` types, effectively `2^N - 1`)
//     *   `eq(x: bits[1], 1)` => `x`
//     *   `eq(x: bits[1], 0)` => `not(x)`
//
// 4.  **Redundant Operand Removal**:
//     *   `or(x, 0, y)` => `or(x, y)`
//     *   `and(x, -1, y)` => `and(x, y)`
//     *   Removal of duplicate operands in N-ary `and`, `or`, `nand`, `nor`,
//         and `xor` operations (e.g., `and(x, y, y, x)` => `and(x, y)`).
//
// 5.  **Flattening Nested Associative N-ary Operations**: If an outer N-ary
//     operation has an inner N-ary operation of the *same opcode* as one of its
//     operands, and the inner operation has only one user (the outer
//     operation), the inner operation's operands are flattened directly into
//     the outer
//     operation.
//
//     Example:
//
//     ```
//     or.5: bits[8] = or(w, x)
//     or.6: bits[8] = or(y, z)
//     ret result: bits[8] = or(or.5, or.6)
//     ```
//     becomes:
//
//     ```
//     ret result: bits[8] = or(w, x, y, z)
//     ```
//
//
// 6.  **Comparison Simplifications**:
//     *   `eq(x, x)` => `1`
//     *   `ne(x, x)` => `0`
//     *   `eq(x, y)` => `1` (if `x` and `y` are zero-width values)
//     *   `ne(x, y)` => `0` (if `x` and `y` are zero-width values)
//
// This pass is designed to be efficient and broadly applicable, serving as a
// foundational optimization before more complex analyses and transformations
// are applied.
class BasicSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "basic_simp";
  explicit BasicSimplificationPass()
      : OptimizationFunctionBasePass(kName, "Basic Simplifications") {}
  ~BasicSimplificationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_BASIC_SIMPLIFICATION_PASS_H_
