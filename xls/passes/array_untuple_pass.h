// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_ARRAY_UNTUPLE_PASS_H_
#define XLS_PASSES_ARRAY_UNTUPLE_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which changes any (non-external) array-of-tuple into a tuple-of-arrays.
// We can see through tuples quite well but can't see through arrays to anywhere
// near the same extent. Therefore the struct-of-array representation is
// always superior.
//
// Note that this pass makes no attempt to unpack or repack arrays which escape
// the function-base. This means that anything which comes in through a function
// param, or a procs recv or escapes through a function return or a proc send is
// not untuple'd.
//
// TODO(allight): We could do this at the cost of a significant number of ir
// nodes. We should experiment to see if this is worth doing.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ArrayUntuplePass` is an optimization pass in XLS that transforms arrays
// of tuples into tuples of arrays. This conversion, often referred to as the
// "struct-of-arrays" (SoA) transformation, is generally superior for hardware
// implementation. The XLS IR and its optimization passes can "see through"
// tuples much more effectively than through arrays. By converting an array of
// structs into a struct of arrays, this pass exposes significantly more
// opportunities for subsequent optimizations (such as bit-slicing, dead code
// elimination, and common subexpression elimination), ultimately leading to
// more efficient and compact hardware designs.
//
// **Core Principle**:
// The pass aims to convert a data structure of the form `Array<Tuple<A, B, C>>`
// into `Tuple<Array<A>, Array<B>, Array<C>>`.
//
// **How it Works**:
//
// 1.  **`FindUntupleGroups` (Union-Find for Related Nodes)**:
//     This function utilizes a `UnionFind` data structure to group nodes that
//     represent parts of the same array-of-tuples structure and should be
//     transformed together. It essentially identifies equivalence classes of
//     nodes that are interconnected within the array-of-tuples dataflow. For
//     instance, if an `array_update` modifies an array-of-tuples, both the
//     original array and the `array_update` result are considered part of the
//     same equivalence group. Operations considered for grouping include:
//     `ArrayUpdate`, `ArraySlice`, `ArrayConcat`, `Eq`, `Ne`, `Sel` (and its
//     variants `PrioritySel`, `OneHotSel`), `Gate`, and `Next`.
//
// 2.  **`FindExternalGroups` (Identifying External Visibility)**:
//     This is a crucial preliminary step that identifies "external" uses of
//     arrays-of-tuples. If an array-of-tuples either originates from outside
//     the current function/proc (e.g., as a function parameter or a proc's
//     `receive` operand) or escapes its boundary (e.g., as a function return
//     value or a proc's `send` operand), it cannot be untupled because doing
//     so would alter the external interface of the component. Such groups of
//     nodes are marked as "excluded" from transformation. Additional
//     exclusions include:
//     *   Arrays of empty tuples (to avoid potential infinite loops in fuzzer-
//         generated code).
//
//     *   Arrays of arrays (this pass currently does not recursively unwrap
//         them).
//
//     *   The `update_value` operand of an `array_update` (as it represents an
//         external input to the update operation).
//
//     *   Operands of unhandled operations that are arrays of tuples.
//
// 3.  **`UntupleVisitor` (Applying Transformations)**:
//     This `DfsVisitorWithDefault` traverses the function or proc nodes in
//     topological order and applies the necessary transformations if a node
//     represents an array-of-tuples and its equivalence group is not marked
//     as excluded. The visitor handles various IR operations:
//     *   **`Literal`**: Converts an array-of-tuples literal into a tuple of
//         array literals.
//
//     *   **`StateRead`**: For Procs, it untuples a `StateRead` operation by
//         creating new `StateElement`s for each tuple element, with each new
//         element holding an array corresponding to that specific tuple field.
//
//     *   **`Next`**: Transforms a `next` operation on an array-of-tuples
//         state element into a series of `next` operations, one for each
//         tuple-of-arrays state element.
//
//     *   **`ArrayIndex`**: Converts an `array_index` operation on an array-of-
//         tuples into a `tuple` of `array_index` operations, where each
//         accesses a corresponding element from the untupled array structure.
//
//     *   **`Array`**: Transforms an `array` construction that creates an
//         array-of-tuples into a `tuple` of `array` constructions, effectively
//         building the tuple-of-arrays representation.
//
//     *   **`ArrayUpdate`, `ArraySlice`, `ArrayConcat`**: Similar
//         transformations are applied to these operations, distributing them
//         across the individual tuple elements to operate on the corresponding
//         arrays.
//
//     *   **`Gate`, `Select` (and its variants `PrioritySel`, `OneHotSel`)**:
//         These operations are distributed across the elements of the tuple,
//         creating new operations for each element of the untupled structure.
//
//     *   **`Eq`, `Ne` (Comparisons)**: Comparisons on arrays of tuples are
//         distributed across the tuple elements. For `eq`, the individual
//         comparison results are `and`-reduced; for `ne`, they are
//         `or`-reduced.
//
// **Benefits**:
//
// *   **Improved Optimization Opportunities**: By converting arrays of tuples
//     to tuples of arrays, the pass exposes the individual array components.
//     This allows other subsequent passes (e.g., `BitSliceSimplificationPass`,
//     `DcePass`, `CsePass`) to operate more effectively, as they are generally
//     more adept at optimizing bit-level operations and tuple structures.
//
// *   **Reduced Hardware Complexity**: Can lead to a more modular and efficient
//     hardware implementation by breaking down complex array-of-tuple
//     structures into simpler, parallel arrays.
//
// *   **Enhanced IR Clarity**: The transformed IR can be easier to understand
//     and reason about, as logical components are grouped more coherently and
//     less opaque data structures are used.
//
// Example (`tuple_index(array_index(array_of_tuples, idx), element_idx)`):
// Consider an array of tuples where we first index into the array, and then
// extract an element from the resulting tuple:
//
//
// ```
// // Original IR snippet
// fn my_func(my_array: (bits[32], bits[16])[4], idx: bits[2]) -> bits[16] {
//   array_element: (bits[32], bits[16]) = array_index(my_array, indices=[idx])
//   ret tuple_element: bits[16] = tuple_index(array_element, index=1)
// }
// ```
//
//
// After `ArrayUntuplePass`, `my_array` would conceptually be transformed into
// separate arrays for each tuple element, e.g., `(my_array_elem0: bits[32][4],
// my_array_elem1: bits[16][4])`. The access pattern would then become
// simplified:
//
//
// ```
// // Optimized IR (conceptually, after ArrayUntuplePass and DCE)
// fn my_func(my_array_elem0: bits[32][4],
//            my_array_elem1: bits[16][4],
//            idx: bits[2]) -> bits[16] {
//   ret array_index_elem1: bits[16] = array_index(my_array_elem1,
//                                                 indices=[idx])
// }
// ```
//
// The pass effectively streamlines data access by creating direct arrays for
// each tuple element, allowing for more direct and optimized indexing into the
// relevant array, eliminating the intermediate tuple operations.
class ArrayUntuplePass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "array_untuple";
  explicit ArrayUntuplePass()
      : OptimizationFunctionBasePass(kName, "Array UnTuple") {}
  ~ArrayUntuplePass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};
}  // namespace xls

#endif  // XLS_PASSES_ARRAY_UNTUPLE_PASS_H_
