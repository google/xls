// Copyright 2022 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "xls/passes/proc_inlining_pass.h"

#include <random>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/status/statusor.h"
#include "xls/common/status/matchers.h"
#include "xls/common/status/status_macros.h"
#include "xls/interpreter/channel_queue.h"
#include "xls/interpreter/interpreter_proc_runtime.h"
#include "xls/interpreter/serial_proc_runtime.h"
#include "xls/ir/function.h"
#include "xls/ir/function_builder.h"
#include "xls/ir/ir_test_base.h"
#include "xls/ir/package.h"
#include "xls/ir/value_helpers.h"
#include "xls/passes/dce_pass.h"

namespace xls {
namespace {

using status_testing::IsOkAndHolds;
using status_testing::StatusIs;
using ::testing::ElementsAreArray;
using ::testing::HasSubstr;

class ProcInliningPassTest : public IrTestBase {
 protected:
  ProcInliningPassTest() = default;

  absl::StatusOr<bool> Run(Package* p,
                           std::optional<std::string> top = std::nullopt) {
    if (top.has_value()) {
      XLS_RETURN_IF_ERROR(p->SetTopByName(top.value()));
    }

    PassOptions options;
    options.inline_procs = true;
    PassResults results;
    XLS_ASSIGN_OR_RETURN(bool changed,
                         ProcInliningPass().Run(p, options, &results));
    // Run dce to clean things up.
    XLS_RETURN_IF_ERROR(
        DeadCodeEliminationPass().Run(p, PassOptions(), &results).status());
    XLS_VLOG(1) << "After DCE:\n" << p->DumpIr();
    return changed;
  }

  absl::StatusOr<std::unique_ptr<SerialProcRuntime>> CreateInterpreter(
      Package* p,
      const absl::flat_hash_map<std::string, std::vector<int64_t>>& inputs) {
    XLS_ASSIGN_OR_RETURN(std::unique_ptr<SerialProcRuntime> interpreter,
                         CreateInterpreterSerialProcRuntime(p));

    for (auto [ch_name, ch_inputs] : inputs) {
      XLS_ASSIGN_OR_RETURN(Channel * ch, p->GetChannel(ch_name));
      XLS_RET_CHECK(ch->type()->IsBits());

      std::vector<Value> input_values;
      for (int64_t in : ch_inputs) {
        input_values.push_back(Value(UBits(in, ch->type()->GetFlatBitCount())));
      }

      ChannelQueue& queue = interpreter->queue_manager().GetQueue(ch);
      if (ch->kind() == ChannelKind::kStreaming) {
        XLS_RETURN_IF_ERROR(
            queue.AttachGenerator(FixedValueGenerator(input_values)));
      } else {
        XLS_RET_CHECK(ch->kind() == ChannelKind::kSingleValue);
        XLS_RET_CHECK_EQ(input_values.size(), 1)
            << "Single value channels may only have a single input";
        XLS_RETURN_IF_ERROR(queue.Write(input_values.front()));
      }
    }
    return std::move(interpreter);
  }

  // Evaluate the proc with the given inputs and expect the given
  // outputs. Inputs and outputs are given as a map from channel name to
  // sequence of values. `expected_ticks` if given is the expected number of
  // ticks to run to generate the expected outputs. If the expected number of
  // outputs is not generated by this number of ticks an error is raised.
  void EvalAndExpect(
      Package* p,
      const absl::flat_hash_map<std::string, std::vector<int64_t>>& inputs,
      const absl::flat_hash_map<std::string, std::vector<int64_t>>&
          expected_outputs,
      std::optional<int64_t> expected_ticks = std::nullopt,
      xabsl::SourceLocation loc = xabsl::SourceLocation::current()) {
    testing::ScopedTrace trace(loc.file_name(), loc.line(),
                               "EvalAndExpect failed");

    XLS_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SerialProcRuntime> interpreter,
                             CreateInterpreter(p, inputs));

    std::vector<Channel*> output_channels;
    absl::flat_hash_map<Channel*, int64_t> expected_output_count;
    for (auto [ch_name, expected_values] : expected_outputs) {
      XLS_ASSERT_OK_AND_ASSIGN(Channel * ch, p->GetChannel(ch_name));
      ASSERT_TRUE(ch->type()->IsBits());
      output_channels.push_back(ch);
      expected_output_count[ch] = expected_values.size();
    }
    // Sort output channels the output expectations are done in a deterministic
    // order.
    std::sort(output_channels.begin(), output_channels.end(),
              [](Channel* a, Channel* b) { return a->name() < b->name(); });

    const int64_t kMaxTicks = 1000;
    XLS_ASSERT_OK_AND_ASSIGN(
        int64_t ticks,
        interpreter->TickUntilOutput(expected_output_count, kMaxTicks));
    if (expected_ticks.has_value()) {
      EXPECT_EQ(expected_ticks.value(), ticks);
    }

    for (Channel* ch : output_channels) {
      std::vector<int64_t> outputs;
      ChannelQueue& queue = interpreter->queue_manager().GetQueue(ch);
      while (outputs.size() < expected_outputs.at(ch->name()).size()) {
        Value output = queue.Read().value();
        outputs.push_back(output.bits().ToUint64().value());
      }
      EXPECT_THAT(outputs, ElementsAreArray(expected_outputs.at(ch->name())))
          << "Output of channel: " << ch->name();
    }
  }

  // Make a proc which receives data on channel `in` and immediate sends back
  // the data on channel `out`.
  absl::StatusOr<Proc*> MakeLoopbackProc(std::string_view name, Channel* in,
                                         Channel* out, Package* p) {
    XLS_RET_CHECK(in->type() == out->type());
    ProcBuilder b(name, "tkn", p);
    BValue rcv = b.Receive(in, b.GetTokenParam());
    BValue send = b.Send(out, b.TupleIndex(rcv, 0), b.TupleIndex(rcv, 1));
    return b.Build(send, {});
  }

  // Make a proc which receives data on channel `in` and sends back the data on
  // channel `out` after `delay` ticks.
  absl::StatusOr<Proc*> MakeDelayedLoopbackProc(std::string_view name,
                                                int64_t delay, Channel* in,
                                                Channel* out, Package* p) {
    XLS_RET_CHECK(in->type() == out->type());
    ProcBuilder b(name, "tkn", p);
    BValue cnt = b.StateElement("cnt", Value(UBits(0, 32)));
    BValue data = b.StateElement("cnt", Value(UBits(0, 32)));

    BValue cnt_eq_0 = b.Eq(cnt, b.Literal(UBits(0, 32)));
    BValue cnt_last = b.Eq(cnt, b.Literal(UBits(delay - 1, 32)));

    BValue rcv = b.ReceiveIf(in, b.GetTokenParam(), cnt_eq_0);

    BValue send = b.SendIf(out, b.TupleIndex(rcv, 0), cnt_last, data);

    BValue next_cnt = b.Select(cnt_last, b.Literal(UBits(0, 32)),
                               b.Add(cnt, b.Literal(UBits(1, 32))));
    BValue next_data = b.Select(cnt_eq_0, b.TupleIndex(rcv, 1), data);

    return b.Build(send, {next_cnt, next_data});
  }

  // Make a proc which receives data on channel `in` and sends back twice the
  // value of data on channel `out`.
  absl::StatusOr<Proc*> MakeDoublerProc(std::string_view name, Channel* in,
                                        Channel* out, Package* p) {
    XLS_RET_CHECK(in->type() == out->type());
    ProcBuilder b(name, "tkn", p);
    BValue rcv = b.Receive(in, b.GetTokenParam());
    BValue data = b.TupleIndex(rcv, 1);
    BValue send = b.Send(out, b.TupleIndex(rcv, 0), b.Add(data, data));
    return b.Build(send, {});
  }

  // Make a proc which receives data on channel `a_in` and sends the data on
  // `a_out`, then receives data on channel `b_in` and sends that data on
  // `b_out`.
  absl::StatusOr<Proc*> MakePassThroughProc(std::string_view name,
                                            Channel* a_in, Channel* a_out,
                                            Channel* b_in, Channel* b_out,
                                            Package* p) {
    XLS_RET_CHECK(a_in->type() == a_out->type());
    XLS_RET_CHECK(b_in->type() == b_out->type());

    ProcBuilder b(name, "tkn", p);
    BValue rcv_a = b.Receive(a_in, b.GetTokenParam());
    BValue send_a =
        b.Send(a_out, b.TupleIndex(rcv_a, 0), b.TupleIndex(rcv_a, 1));
    BValue rcv_b = b.Receive(b_in, send_a);
    BValue send_b =
        b.Send(b_out, b.TupleIndex(rcv_b, 0), b.TupleIndex(rcv_b, 1));
    return b.Build(send_b, {});
  }

  // Make a proc which loops `iteration` times. It receives on the first
  // iteration. The state accumulates the received data with the iteration
  // count. The accumulated value is sent on the last iteration.
  //
  //   i = 0
  //   accum = 0
  //   while(true):
  //    if i == 0:
  //      x = rcv(in)
  //    else:
  //      x = accum + i
  //    if i == ITERATIONS:
  //      i = 0
  //      accum = 0
  //      send(out, x)
  //    else:
  //      i = i + 1
  //      accum = x
  absl::StatusOr<Proc*> MakeLoopingAccumulatorProc(std::string_view name,
                                                   Channel* input_ch,
                                                   Channel* output_ch,
                                                   int64_t iterations,
                                                   Package* p) {
    XLS_RET_CHECK(input_ch->type() == output_ch->type());
    XLS_RET_CHECK(input_ch->type()->IsBits());
    int64_t bit_count = input_ch->type()->AsBitsOrDie()->bit_count();

    SourceInfo loc;

    ProcBuilder b(name, "tkn", p);
    BValue i = b.StateElement("i", ZeroOfType(input_ch->type()));
    BValue accum = b.StateElement("accum", ZeroOfType(input_ch->type()));

    BValue zero = b.Literal(UBits(0, bit_count), loc, "zero");
    BValue one = b.Literal(UBits(1, bit_count), loc, "one");

    BValue is_first_iteration = b.Eq(i, zero, loc, "is_first_iteration");
    BValue is_last_iteration =
        b.Eq(i, b.Literal(UBits(iterations - 1, bit_count)), loc,
             "is_last_iteration");

    BValue rcv = b.ReceiveIf(input_ch, b.GetTokenParam(), is_first_iteration);
    BValue rcv_token = b.TupleIndex(rcv, 0);
    BValue data = b.TupleIndex(rcv, 1, loc, "data");

    BValue next_i =
        b.Select(is_last_iteration, zero, b.Add(i, one), loc, "next_i");
    BValue updated_accum = b.Select(is_first_iteration, data, b.Add(accum, i),
                                    loc, "updated_accum");
    BValue next_accum =
        b.Select(is_last_iteration, zero, updated_accum, loc, "next_accum");

    BValue send =
        b.SendIf(output_ch, rcv_token, is_last_iteration, updated_accum);

    return b.Build(send, {next_i, next_accum});
  }

  // Make a proc which receives data values `x` and `y` and sends the sum and
  // difference.
  absl::StatusOr<Proc*> MakeSumAndDifferenceProc(std::string_view name,
                                                 Channel* x_in, Channel* y_in,
                                                 Channel* x_plus_y_out,
                                                 Channel* x_minus_y_out,
                                                 Package* p) {
    XLS_RET_CHECK(x_in->type() == y_in->type());
    XLS_RET_CHECK(x_plus_y_out->type() == x_minus_y_out->type());

    ProcBuilder b(name, "tkn", p);
    BValue x_rcv = b.Receive(x_in, b.GetTokenParam());
    BValue y_rcv = b.Receive(y_in, b.TupleIndex(x_rcv, 0));
    BValue x = b.TupleIndex(x_rcv, 1);
    BValue y = b.TupleIndex(y_rcv, 1);

    BValue send_x_plus_y =
        b.Send(x_plus_y_out, b.TupleIndex(y_rcv, 0), b.Add(x, y));
    BValue send_x_minus_y =
        b.Send(x_minus_y_out, send_x_plus_y, b.Subtract(x, y));

    return b.Build(send_x_minus_y, {});
  }

  // Make a proc which receives data values `x` and `y` and sends out the sum.
  absl::StatusOr<Proc*> MakeSumProc(std::string_view name, Channel* x_in,
                                    Channel* y_in, Channel* out, Package* p) {
    XLS_RET_CHECK(x_in->type() == y_in->type());
    XLS_RET_CHECK(x_in->type() == out->type());

    ProcBuilder b(name, "tkn", p);
    BValue x_rcv = b.Receive(x_in, b.GetTokenParam());
    BValue y_rcv = b.Receive(y_in, b.TupleIndex(x_rcv, 0));
    BValue x = b.TupleIndex(x_rcv, 1);
    BValue y = b.TupleIndex(y_rcv, 1);
    BValue send_out = b.Send(out, b.TupleIndex(y_rcv, 0), b.Add(x, y));

    return b.Build(send_out, {});
  }

  // Make a proc which receives a tuple of data and loops twice accumulating the
  // element values before sending out the accumulation:
  //
  // u1: cnt = 0
  // x_accum = 0
  // y_accum = 0
  // while (true):
  //   (x, y) = rcv(in)
  //   x_accum += x
  //   y_accum += y
  //   send_if(out, cnt, (x_accum, y_accum))
  //   cnt = !cnt
  absl::StatusOr<Proc*> MakeTupleAccumulator(std::string_view name,
                                             Channel* in, Channel* out,
                                             Package* p) {
    XLS_RET_CHECK(in->type()->IsTuple());
    int64_t x_bit_count =
        in->type()->AsTupleOrDie()->element_type(0)->AsBitsOrDie()->bit_count();
    int64_t y_bit_count =
        in->type()->AsTupleOrDie()->element_type(1)->AsBitsOrDie()->bit_count();
    ProcBuilder b(name, "tkn", p);

    BValue cnt = b.StateElement("cnt", Value(UBits(0, 1)));
    BValue x_accum = b.StateElement("x_accum", Value(UBits(0, x_bit_count)));
    BValue y_accum = b.StateElement("y_accum", Value(UBits(0, y_bit_count)));

    BValue rcv_x_y = b.Receive(in, b.GetTokenParam());
    BValue rcv_x_y_data = b.TupleIndex(rcv_x_y, 1);
    BValue x = b.TupleIndex(rcv_x_y_data, 0);
    BValue y = b.TupleIndex(rcv_x_y_data, 1);

    BValue x_plus_x_accum = b.Add(x, x_accum);
    BValue y_plus_y_accum = b.Add(y, y_accum);

    BValue send_x_y_result =
        b.SendIf(out, b.TupleIndex(rcv_x_y, 0), cnt,
                 b.Tuple({x_plus_x_accum, y_plus_y_accum}));

    return b.Build(send_x_y_result,
                   {b.Not(cnt), x_plus_x_accum, y_plus_y_accum});
  }

  int64_t TotalProcStateSize(Package* p) {
    int64_t bit_count = 0;
    XLS_VLOG(1) << absl::StreamFormat("Proc state of package %s:", p->name());
    for (const std::unique_ptr<Proc>& proc : p->procs()) {
      XLS_VLOG(1) << absl::StreamFormat("  State elements for proc %s:",
                                        proc->name());
      for (Param* param : proc->StateParams()) {
        XLS_VLOG(1) << absl::StreamFormat("    %s: %d bits", param->GetName(),
                                          param->GetType()->GetFlatBitCount());
        bit_count += param->GetType()->GetFlatBitCount();
      }
    }
    return bit_count;
  }
};

TEST_F(ProcInliningPassTest, NoProcs) {
  auto p = CreatePackage();
  FunctionBuilder fb(TestName(), p.get());
  fb.Param("x", p->GetBitsType(32));
  XLS_ASSERT_OK(fb.Build().status());
  ASSERT_THAT(Run(p.get()), IsOkAndHolds(false));
}

TEST_F(ProcInliningPassTest, SingleProc) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  ProcBuilder b(TestName(), "tkn", p.get());
  BValue rcv = b.Receive(ch_in, b.GetTokenParam());
  BValue send = b.Send(ch_out, b.TupleIndex(rcv, 0), b.TupleIndex(rcv, 1));
  XLS_ASSERT_OK_AND_ASSIGN(Proc * proc, b.Build(send, {}));

  ASSERT_THAT(Run(p.get(), proc->name()), IsOkAndHolds(false));
}

TEST_F(ProcInliningPassTest, NestedProcs) {
  // Nested procs where the inner proc does a trivial arithmetic operation.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(MakeDoublerProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {2, 4, 6}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {2, 4, 6}}},
                /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, NestedProcsFifoDepth1) {
  // Nested procs where the inner proc does a trivial arithmetic operation.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(MakeDoublerProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {2, 4, 6}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {2, 4, 6}}},
                /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, NestedProcsWithUnspecifiedFifoDepth) {
  // Nested procs where the inner proc does a trivial arithmetic operation.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(MakeDoublerProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {2, 4, 6}}});

  EXPECT_THAT(
      Run(p.get(), /*top=*/"A"),
      StatusIs(
          absl::StatusCode::kUnimplemented,
          HasSubstr(
              "Only streaming channels of FIFO depth one or less are supported "
              "in proc inlining. Channel `a_to_b` has depth: (none)")));
}

TEST_F(ProcInliningPassTest, NestedProcsWithNonzeroFifoDepth) {
  // Nested procs where the inner proc does a trivial arithmetic operation.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/42));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(MakeDoublerProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {2, 4, 6}}});

  EXPECT_THAT(
      Run(p.get(), /*top=*/"A"),
      StatusIs(
          absl::StatusCode::kUnimplemented,
          HasSubstr(
              "Only streaming channels of FIFO depth one or less are supported "
              "in proc inlining. Channel `b_to_a` has depth: 42")));
}

TEST_F(ProcInliningPassTest, NestedProcsWithSingleValue) {
  // Nested procs where the inner proc does a trivial arithmetic operation.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateSingleValueChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateSingleValueChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateSingleValueChannel("a_to_b", ChannelOps::kSendReceive, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateSingleValueChannel("b_to_a", ChannelOps::kSendReceive, u32));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(MakeDoublerProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1}}}, {{"out", {2}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1}}}, {{"out", {2}}},
                /*expected_ticks=*/1);
}

TEST_F(ProcInliningPassTest, NestedProcsWithConditionalSingleValueSend) {
  // Nested procs where the outer proc conditionally sends on a single value
  // channel to the inner proc.
  std::unique_ptr<Package> p = std::make_unique<Package>(TestName());
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateSingleValueChannel("a_to_b", ChannelOps::kSendReceive, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  ProcBuilder ab("A", "tkn", p.get());
  BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());
  BValue in_data = ab.TupleIndex(rcv_in, 1);
  BValue data_is_odd = ab.BitSlice(in_data, /*start=*/0, /*width=*/1);
  BValue send_to_b =
      ab.SendIf(a_to_b, ab.TupleIndex(rcv_in, 0), data_is_odd, in_data);
  BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);
  BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_b, 0),
                            ab.TupleIndex(rcv_from_b, 1));
  XLS_ASSERT_OK(ab.Build(send_out, {}));

  XLS_ASSERT_OK(MakeDoublerProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 4, 5}}},
                {{"out", {2, 2, 6, 6, 10}}});

  EXPECT_THAT(
      Run(p.get(), /*top=*/"A"),
      StatusIs(
          absl::StatusCode::kUnimplemented,
          HasSubstr(
              "Conditional send on single-value channels are not supported")));
}

TEST_F(ProcInliningPassTest, NestedProcPassThrough) {
  // Nested procs where the inner proc passes through the value.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(MakeLoopbackProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}},
                /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, NestedProcDelayedPassThrough) {
  // Nested procs where the inner proc passes through the value after a delay.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  ProcBuilder ab("A", "tkn", p.get());
  BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());
  BValue in_data = ab.TupleIndex(rcv_in, 1);
  BValue send_to_b = ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), in_data);
  BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);
  BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_b, 0),
                            ab.Add(in_data, ab.TupleIndex(rcv_from_b, 1)));
  XLS_ASSERT_OK(ab.Build(send_out, {}));

  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("B", /*delay=*/3, a_to_b, b_to_a, p.get())
          .status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {246, 44, 84}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {246, 44, 84}}});
}

TEST_F(ProcInliningPassTest, InputPlusDelayedInput) {
  // Proc where a value is added to a delayed version of itself. The value is
  // delayed by sending it through another proc. This tests the saving of inputs
  // from external channels.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("B", /*delay=*/42, a_to_b, b_to_a, p.get())
          .status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}},
                /*expected_ticks=*/126);
}

TEST_F(ProcInliningPassTest, NestedProcsTrivialInnerLoop) {
  // Nested procs where the inner proc loops more than once for each received
  // input.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());

  {
    // Inner proc performs the following:
    //
    //   st = 1
    //   while(true):
    //    if(st): rcv()
    //    if(!st): send(42)
    //    st = !st
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(1, 1)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), st);
    BValue send_to_a = bb.SendIf(b_to_a, bb.TupleIndex(rcv_from_a, 0),
                                 bb.Not(st), bb.Literal(UBits(42, 32)));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Not(st)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {42, 42, 42}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {42, 42, 42}}},
                /*expected_ticks=*/6);
}

TEST_F(ProcInliningPassTest, NestedProcsIota) {
  // Output only nested procs where the inner proc just implements iota
  // starting at 42.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_from_b = ab.Receive(b_to_a, ab.GetTokenParam());
    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_b, 0),
                              ab.TupleIndex(rcv_from_b, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  {
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(42, 32)));
    BValue send_to_a = bb.Send(b_to_a, bb.GetTokenParam(), bb.GetStateParam(0));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Add(st, bb.Literal(UBits(1, 32)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {}, {{"out", {42, 43, 44}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {}, {{"out", {42, 43, 44}}});
}

TEST_F(ProcInliningPassTest, NestedProcsOddIota) {
  // Output only nested procs where the inner proc just implements iota
  // starting at 42 but only sends the odd values.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_from_b = ab.Receive(b_to_a, ab.GetTokenParam());
    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_b, 0),
                              ab.TupleIndex(rcv_from_b, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  {
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(42, 32)));
    BValue send_to_a =
        bb.SendIf(b_to_a, bb.GetTokenParam(),
                  bb.BitSlice(bb.GetStateParam(0), /*start=*/0, /*width=*/1),
                  bb.GetStateParam(0));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Add(st, bb.Literal(UBits(1, 32)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {}, {{"out", {43, 45, 47, 49}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {}, {{"out", {43, 45, 47, 49}}}, /*expected_ticks=*/8);
}

TEST_F(ProcInliningPassTest, SynchronizedNestedProcs) {
  // Nested procs where every other iteration each proc does nothing (send and
  // receive predicates off). The procs are synchronized in that they are active
  // on the same ticks.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    // Outer proc performs the following:
    //
    //   st = 0
    //   while(true):
    //    if(st):
    //      x = rcv(in)
    //      send(a_to_b, x)
    //      y = rcv(b_t_a)
    //      send(out, y)
    //    st = !st
    ProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 1)));
    BValue rcv_in = ab.ReceiveIf(ch_in, ab.GetTokenParam(), st);
    BValue send_to_b = ab.SendIf(a_to_b, ab.TupleIndex(rcv_in, 0), st,
                                 ab.TupleIndex(rcv_in, 1));
    BValue rcv_from_b = ab.ReceiveIf(b_to_a, send_to_b, ab.GetStateParam(0));
    BValue send_out =
        ab.SendIf(ch_out, ab.TupleIndex(rcv_from_b, 0), ab.GetStateParam(0),
                  ab.TupleIndex(rcv_from_b, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {ab.Not(st)}));
  }

  {
    // Inner proc performs the following:
    //
    //   st = 0
    //   while(true):
    //    if(st):
    //       x = rcv(a_to_b)
    //       send(b_to_a, x + 42)
    //    st = !st
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), st);
    BValue send_to_a = bb.SendIf(
        b_to_a, bb.TupleIndex(rcv_from_a, 0), st,
        bb.Add(bb.TupleIndex(rcv_from_a, 1), bb.Literal(UBits(42, 32))));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Not(st)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {43, 44, 45}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {43, 44, 45}}},
                /*expected_ticks=*/6);
}

TEST_F(ProcInliningPassTest, NestedProcsNontrivialInnerLoop) {
  // Nested procs where the inner proc loops more than once for each received
  // input and does something interesting.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  {
    // Inner proc has a counter which loops from 0, 1, 2, 3. It essentially
    // performs the following:
    //
    //   x = rcv()
    //   for i in 0..3:
    //     x += i
    //   snd(x)
    ProcBuilder bb("B", "tkn", p.get());
    BValue cnt = bb.StateElement("cnt", Value(UBits(0, 2)));
    BValue accum = bb.StateElement("accum", Value(UBits(0, 32)));

    BValue cnt_eq_0 = bb.Eq(cnt, bb.Literal(UBits(0, 2)));
    BValue cnt_eq_3 = bb.Eq(cnt, bb.Literal(UBits(3, 2)));

    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), cnt_eq_0);

    BValue data = bb.Select(cnt_eq_0, bb.TupleIndex(rcv_from_a, 1), accum);
    BValue data_plus_cnt = bb.Add(data, bb.ZeroExtend(cnt, 32));

    BValue send_to_a = bb.SendIf(b_to_a, bb.TupleIndex(rcv_from_a, 0), cnt_eq_3,
                                 data_plus_cnt);

    XLS_ASSERT_OK(bb.Build(
        send_to_a,
        {bb.Add(cnt, bb.Literal(UBits(1, 2))),
         bb.Select(cnt_eq_3, bb.Literal(UBits(0, 32)), data_plus_cnt)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {7, 8, 9}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {7, 8, 9}}});
}

TEST_F(ProcInliningPassTest, DoubleNestedProcsPassThrough) {
  // Nested procs where the inner proc passes through the value.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_c,
      p->CreateStreamingChannel("b_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_b,
      p->CreateStreamingChannel("c_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  XLS_ASSERT_OK(
      MakePassThroughProc("B", a_to_b, b_to_c, c_to_b, b_to_a, p.get())
          .status());
  XLS_ASSERT_OK(MakeLoopbackProc("C", b_to_c, c_to_b, p.get()).status());

  EXPECT_EQ(p->procs().size(), 3);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}});
}

TEST_F(ProcInliningPassTest, SequentialNestedProcsPassThrough) {
  // Sequential procs where each inner proc passes through the value.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_c,
      p->CreateStreamingChannel("a_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_a,
      p->CreateStreamingChannel("c_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());

    BValue send_to_b =
        ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), ab.TupleIndex(rcv_in, 1));
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

    BValue send_to_c = ab.Send(a_to_c, ab.TupleIndex(rcv_from_b, 0),
                               ab.TupleIndex(rcv_from_b, 1));
    BValue rcv_from_c = ab.Receive(c_to_a, send_to_c);

    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_c, 0),
                              ab.TupleIndex(rcv_from_c, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("B", /*delay=*/3, a_to_b, b_to_a, p.get())
          .status());
  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("C", /*delay=*/2, a_to_c, c_to_a, p.get())
          .status());

  EXPECT_EQ(p->procs().size(), 3);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {123, 22, 42}}});
}

TEST_F(ProcInliningPassTest, SequentialNestedLoopingProcsWithState) {
  // Sequential procs where each inner proc loops several times.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_c,
      p->CreateStreamingChannel("a_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_a,
      p->CreateStreamingChannel("c_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_d,
      p->CreateStreamingChannel("a_to_d", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * d_to_a,
      p->CreateStreamingChannel("d_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());

    BValue send_to_b =
        ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), ab.TupleIndex(rcv_in, 1));
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

    BValue send_to_c = ab.Send(a_to_c, ab.TupleIndex(rcv_from_b, 0),
                               ab.TupleIndex(rcv_from_b, 1));
    BValue rcv_from_c = ab.Receive(c_to_a, send_to_c);

    BValue send_to_d = ab.Send(a_to_d, ab.TupleIndex(rcv_from_c, 0),
                               ab.TupleIndex(rcv_from_c, 1));
    BValue rcv_from_d = ab.Receive(d_to_a, send_to_d);

    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_d, 0),
                              ab.TupleIndex(rcv_from_d, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  XLS_ASSERT_OK(
      MakeLoopingAccumulatorProc("B", a_to_b, b_to_a, /*iterations=*/3, p.get())
          .status());
  XLS_ASSERT_OK(
      MakeLoopingAccumulatorProc("C", a_to_c, c_to_a, /*iterations=*/1, p.get())
          .status());
  XLS_ASSERT_OK(
      MakeLoopingAccumulatorProc("D", a_to_d, d_to_a, /*iterations=*/5, p.get())
          .status());

  EXPECT_EQ(p->procs().size(), 4);
  // Result should be:
  //   x + (0 + 1 + 2) + (0) + (0 + 1 + 2 + 3 + 4) = x + 13
  EvalAndExpect(p.get(), {{"in", {0, 1, 2}}}, {{"out", {13, 14, 15}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {0, 1, 2}}}, {{"out", {13, 14, 15}}});
}

TEST_F(ProcInliningPassTest, SequentialNestedProcsWithLoops) {
  // Sequential procs where the inner procs loop and do interesting things.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_c,
      p->CreateStreamingChannel("a_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_a,
      p->CreateStreamingChannel("c_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());

    BValue send_to_b =
        ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), ab.TupleIndex(rcv_in, 1));
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

    BValue send_to_c = ab.Send(a_to_c, ab.TupleIndex(rcv_from_b, 0),
                               ab.TupleIndex(rcv_from_b, 1));
    BValue rcv_from_c = ab.Receive(c_to_a, send_to_c);

    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_c, 0),
                              ab.TupleIndex(rcv_from_c, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("B", /*delay=*/4, a_to_b, b_to_a, p.get())
          .status());
  XLS_ASSERT_OK(MakeDoublerProc("C", a_to_c, c_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 3);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {246, 44, 84}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {246, 44, 84}}});
}

TEST_F(ProcInliningPassTest, DoubleNestedLoops) {
  // Nested procs where the nested procs loop. The innermost proc loops 4 times,
  // the middle proc loops 2 times.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_c,
      p->CreateStreamingChannel("b_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_b,
      p->CreateStreamingChannel("c_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  {
    // Middle proc "B" accumulates the input and passes on the accumulation
    // value:
    //
    //  cnt = 1
    //  accum = 0
    //  while true:
    //    if cnt == 1:
    //      x = rcv(a_to_b)
    //      accum += x
    //      send(b_to_c, accum)
    //    else:
    //      z = rcv(c_to_b)
    //      send(b_to_a, z)
    //    cnt = !cnt
    ProcBuilder bb("B", "tkn", p.get());
    BValue cnt = bb.StateElement("cnt", Value(UBits(1, 1)));
    BValue accum = bb.StateElement("accum", Value(UBits(0, 32)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), cnt);
    BValue next_accum = bb.Add(accum, bb.TupleIndex(rcv_from_a, 1),
                               SourceInfo(), "B_accum_next");
    BValue send_to_c =
        bb.SendIf(b_to_c, bb.TupleIndex(rcv_from_a, 0), cnt, next_accum);

    BValue rcv_from_c = bb.ReceiveIf(c_to_b, send_to_c, bb.Not(cnt));
    BValue send_to_a = bb.SendIf(b_to_a, bb.TupleIndex(rcv_from_c, 0),
                                 bb.Not(cnt), bb.TupleIndex(rcv_from_c, 1));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Not(cnt), next_accum}));
  }

  {
    // Innermost proc "C" adds 15 to the received value over four iterations and
    // sends back the result:
    //
    // u4 cnt = 0
    // u32 accum = 0
    // while true:
    //   if cnt == 0:
    //     accum = rcv(b_to_c)
    //   else:
    //     accum += 5
    //   if cnt == 3
    //     send(c_to_b, accum)
    //   cnt += 1
    ProcBuilder cb("C", "tkn", p.get());
    BValue cnt = cb.StateElement("cnt", Value(UBits(0, 2)));
    BValue accum = cb.StateElement("accum", Value(UBits(0, 32)));
    BValue cnt_eq_0 = cb.Eq(cnt, cb.Literal(UBits(0, 2)));
    BValue cnt_eq_3 = cb.Eq(cnt, cb.Literal(UBits(3, 2)));

    BValue rcv_from_b = cb.ReceiveIf(b_to_c, cb.GetTokenParam(), cnt_eq_0);

    BValue next_accum = cb.Select(
        cnt_eq_0, cb.TupleIndex(rcv_from_b, 1),
        cb.Add(accum, cb.Literal(UBits(5, 32)), SourceInfo(), "C_accum_next"));

    BValue send_to_b =
        cb.SendIf(c_to_b, cb.TupleIndex(rcv_from_b, 0), cnt_eq_3, next_accum);

    BValue next_cnt = cb.Add(cnt, cb.Literal(UBits(1, 2)));

    XLS_ASSERT_OK(cb.Build(send_to_b, {next_cnt, next_accum}));
  }

  // Output is sum of all inputs so far plus 15.
  EXPECT_EQ(p->procs().size(), 3);
  EvalAndExpect(p.get(), {{"in", {1, 100, 100000}}},
                {{"out", {16, 116, 100116}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 100, 100000}}},
                {{"out", {16, 116, 100116}}},
                /*expected_ticks=*/12);
}

TEST_F(ProcInliningPassTest, MultiIO) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateStreamingChannel("y", ChannelOps::kReceiveOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_plus_y_out,
      p->CreateStreamingChannel("x_plus_y_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_minus_y_out,
      p->CreateStreamingChannel("x_minus_y_out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_x,
      p->CreateStreamingChannel("pass_x", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_y,
      p->CreateStreamingChannel("pass_y", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_plus_y,
      p->CreateStreamingChannel("x_plus_y", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_minus_y,
      p->CreateStreamingChannel("x_minus_y", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue rcv_y = ab.Receive(y_in, ab.TupleIndex(rcv_x, 0));

    BValue send_x =
        ab.Send(pass_x, ab.TupleIndex(rcv_y, 0), ab.TupleIndex(rcv_x, 1));
    BValue send_y = ab.Send(pass_y, send_x, ab.TupleIndex(rcv_y, 1));

    BValue rcv_sum = ab.Receive(x_plus_y, send_y);
    BValue rcv_diff = ab.Receive(x_minus_y, ab.TupleIndex(rcv_sum, 0));

    BValue send_sum = ab.Send(x_plus_y_out, ab.TupleIndex(rcv_diff, 0),
                              ab.TupleIndex(rcv_sum, 1));
    BValue send_diff =
        ab.Send(x_minus_y_out, send_sum, ab.TupleIndex(rcv_diff, 1));
    XLS_ASSERT_OK(ab.Build(send_diff, {}));
  }

  XLS_ASSERT_OK(MakeSumAndDifferenceProc("B", pass_x, pass_y, x_plus_y,
                                         x_minus_y, p.get()));

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(
      p.get(), {{"x", {123, 22, 42}}, {"y", {10, 20, 30}}},
      {{"x_plus_y_out", {133, 42, 72}}, {"x_minus_y_out", {113, 2, 12}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(
      p.get(), {{"x", {123, 22, 42}}, {"y", {10, 20, 30}}},
      {{"x_plus_y_out", {133, 42, 72}}, {"x_minus_y_out", {113, 2, 12}}},
      /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, InlinedProcsWithExternalStreamingIO) {
  // The inlined proc has streaming IO (external channels).
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateStreamingChannel("y", ChannelOps::kReceiveOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_plus_y_out,
      p->CreateStreamingChannel("x_plus_y_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_minus_y_out,
      p->CreateStreamingChannel("x_minus_y_out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_x,
      p->CreateStreamingChannel("pass_x", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_plus_y,
      p->CreateStreamingChannel("pass_x_plus_y", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue send_x =
        ab.Send(pass_x, ab.TupleIndex(rcv_x, 0), ab.TupleIndex(rcv_x, 1));

    BValue rcv_sum = ab.Receive(x_plus_y, send_x);
    BValue send_sum = ab.Send(x_plus_y_out, ab.TupleIndex(rcv_sum, 0),
                              ab.TupleIndex(rcv_sum, 1));
    XLS_ASSERT_OK(ab.Build(send_sum, {}));
  }

  // Proc "B" will be inlined and has internal communication with "A" (pass_x
  // and pass_x_plus_y channels) as well as external IO (y and x_minus_y_out).
  XLS_ASSERT_OK(MakeSumAndDifferenceProc("B", pass_x, y_in, x_plus_y,
                                         x_minus_y_out, p.get()));

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(
      p.get(), {{"x", {123, 22, 42}}, {"y", {10, 20, 30}}},
      {{"x_plus_y_out", {133, 42, 72}}, {"x_minus_y_out", {113, 2, 12}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(
      p.get(), {{"x", {123, 22, 42}}, {"y", {10, 20, 30}}},
      {{"x_plus_y_out", {133, 42, 72}}, {"x_minus_y_out", {113, 2, 12}}},
      /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, InlinedProcsWithExternalSingleValueIO) {
  // The inlined proc has single-value input on an external channel.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateSingleValueChannel("y_sv", ChannelOps::kReceiveOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_plus_y_out,
      p->CreateStreamingChannel("x_plus_y_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_minus_y_out,
      p->CreateStreamingChannel("x_minus_y_out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_x,
      p->CreateStreamingChannel("pass_x", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_plus_y,
      p->CreateStreamingChannel("pass_x_plus_y", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue send_x =
        ab.Send(pass_x, ab.TupleIndex(rcv_x, 0), ab.TupleIndex(rcv_x, 1));

    BValue rcv_sum = ab.Receive(x_plus_y, send_x);
    BValue send_sum = ab.Send(x_plus_y_out, ab.TupleIndex(rcv_sum, 0),
                              ab.TupleIndex(rcv_sum, 1));
    XLS_ASSERT_OK(ab.Build(send_sum, {}));
  }

  // Proc "B" will be inlined and has internal communication with "A" (pass_x
  // and pass_x_plus_y channels) as well as external IO (y and x_minus_y_out).
  XLS_ASSERT_OK(MakeSumAndDifferenceProc("B", pass_x, y_in, x_plus_y,
                                         x_minus_y_out, p.get()));

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(
      p.get(), {{"x", {123, 22, 42}}, {"y_sv", {10}}},
      {{"x_plus_y_out", {133, 32, 52}}, {"x_minus_y_out", {113, 12, 32}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(
      p.get(), {{"x", {123, 22, 42}}, {"y_sv", {10}}},
      {{"x_plus_y_out", {133, 32, 52}}, {"x_minus_y_out", {113, 12, 32}}},
      /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, SingleValueAndStreamingChannels) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * sv_in,
      p->CreateSingleValueChannel("sv", ChannelOps::kReceiveOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_x,
      p->CreateStreamingChannel("pass_x", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_sv,
      p->CreateSingleValueChannel("pass_sv", ChannelOps::kSendReceive, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_sum,
      p->CreateStreamingChannel("pass_sum", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * sum_out,
      p->CreateStreamingChannel("sum", ChannelOps::kSendOnly, u32));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue rcv_sv = ab.Receive(sv_in, ab.TupleIndex(rcv_x, 0));

    BValue send_x =
        ab.Send(pass_x, ab.TupleIndex(rcv_sv, 0), ab.TupleIndex(rcv_x, 1));
    BValue send_sv = ab.Send(pass_sv, send_x, ab.TupleIndex(rcv_sv, 1));

    BValue rcv_sum = ab.Receive(pass_sum, send_sv);
    BValue send_sum =
        ab.Send(sum_out, ab.TupleIndex(rcv_sum, 0), ab.TupleIndex(rcv_sum, 1));
    XLS_ASSERT_OK(ab.Build(send_sum, {}));
  }

  XLS_ASSERT_OK(MakeSumProc("B", pass_x, pass_sv, pass_sum, p.get()));

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"x", {123, 22, 42}}, {"sv", {10}}},
                {{"sum", {133, 32, 52}}});
  EvalAndExpect(p.get(), {{"x", {123, 22, 42}}, {"sv", {25}}},
                {{"sum", {148, 47, 67}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"x", {123, 22, 42}}, {"sv", {10}}},
                {{"sum", {133, 32, 52}}},
                /*expected_ticks=*/3);
  EvalAndExpect(p.get(), {{"x", {123, 22, 42}}, {"sv", {25}}},
                {{"sum", {148, 47, 67}}},
                /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, TriangleProcNetwork) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_c,
      p->CreateStreamingChannel("a_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_a,
      p->CreateStreamingChannel("c_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_c,
      p->CreateStreamingChannel("b_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());

    BValue send_to_b =
        ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), ab.TupleIndex(rcv_in, 1));
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

    BValue send_to_c = ab.Send(a_to_c, ab.TupleIndex(rcv_from_b, 0),
                               ab.TupleIndex(rcv_from_b, 1));
    BValue rcv_from_c = ab.Receive(c_to_a, send_to_c);

    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_c, 0),
                              ab.TupleIndex(rcv_from_c, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  {
    ProcBuilder bb("B", "tkn", p.get());
    BValue rcv_a = bb.Receive(a_to_b, bb.GetTokenParam());
    BValue rcv_data = bb.TupleIndex(rcv_a, 1);

    BValue send_to_b = bb.Send(b_to_a, bb.TupleIndex(rcv_a, 0), rcv_data);
    BValue send_to_c =
        bb.Send(b_to_c, send_to_b, bb.Shll(rcv_data, bb.Literal(UBits(1, 32))));
    XLS_ASSERT_OK(bb.Build(send_to_c, {}));
  }

  {
    ProcBuilder cb("C", "tkn", p.get());
    BValue rcv_a = cb.Receive(a_to_c, cb.GetTokenParam());
    BValue rcv_a_data = cb.TupleIndex(rcv_a, 1);

    BValue rcv_b = cb.Receive(b_to_c, cb.TupleIndex(rcv_a, 0));
    BValue rcv_b_data = cb.TupleIndex(rcv_b, 1);

    BValue send = cb.Send(c_to_a, cb.TupleIndex(rcv_b, 0),
                          cb.Add(rcv_a_data, rcv_b_data));
    XLS_ASSERT_OK(cb.Build(send, {}));
  }

  EXPECT_EQ(p->procs().size(), 3);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {369, 66, 126}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {369, 66, 126}}},
                /*expected_ticks=*/3);
}

TEST_F(ProcInliningPassTest, DelayedReceiveWithDataLossFifoDepth0) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  {
    // Inner proc does nothing on the first tick (i.e., doesn't receive
    // data). This causes data loss because the channel is FIFO depth 0.
    //
    //   st = 0
    //   while(true):
    //    if(st):
    //       x = rcv(a_to_b)
    //       send(b_to_a, x + 42)
    //    st = 1
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), st);
    BValue send_to_a = bb.SendIf(
        b_to_a, bb.TupleIndex(rcv_from_a, 0), st,
        bb.Add(bb.TupleIndex(rcv_from_a, 1), bb.Literal(UBits(42, 32))));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Literal(UBits(1, 1))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {43, 44, 45}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  XLS_ASSERT_OK_AND_ASSIGN(
      std::unique_ptr<SerialProcRuntime> interpreter,
      CreateInterpreter(p.get(), {{"in", {1, 2, 3, 4, 5}}}));
  EXPECT_THAT(
      interpreter->Tick(),
      StatusIs(
          absl::StatusCode::kAborted,
          HasSubstr(
              "Channel a_to_b lost data, send fired but receive did not")));
}

TEST_F(ProcInliningPassTest, DelayedReceiveWithNoDataLossFifoDepth1Variant0) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  {
    // Inner proc does nothing on the first tick (i.e., doesn't receive
    // data). Because the FIFO depth is 1, data is stored for a cycle which
    // avoids data loss.
    //
    //   st = 0
    //   while(true):
    //    if(st):
    //       x = rcv(a_to_b)
    //       send(b_to_a, x + 42)
    //    st = 1
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), st);
    BValue send_to_a = bb.SendIf(
        b_to_a, bb.TupleIndex(rcv_from_a, 0), st,
        bb.Add(bb.TupleIndex(rcv_from_a, 1), bb.Literal(UBits(42, 32))));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Literal(UBits(1, 1))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {43, 44, 45}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));
  EXPECT_EQ(p->procs().size(), 1);

  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {43, 44, 45}}});
}

TEST_F(ProcInliningPassTest, DelayedReceiveWithNoDataLossFifoDepth1Variant1) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  {
    // Inner proc does not receive on the first tick, but does send. Because the
    // FIFO depth is 1 no data should be lost. On the second tick of the inner
    // proc, the existing channel state should be received and updated in the
    // same tick.
    //
    //   u32: st = 0
    //   while(true):
    //    if st >= 1:
    //       x = rcv(a_to_b)
    //    else:
    //       x = 0
    //    send(b_to_a, x + 42)
    //    st = st + 1
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 32)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(),
                                     bb.UGe(st, bb.Literal(UBits(1, 32))));
    BValue send_to_a = bb.Send(
        b_to_a, bb.TupleIndex(rcv_from_a, 0),
        bb.Add(bb.TupleIndex(rcv_from_a, 1), bb.Literal(UBits(42, 32))));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Add(st, bb.Literal(UBits(1, 32)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {42, 43, 44}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {42, 43, 44}}});
}

TEST_F(ProcInliningPassTest, DelayedReceiveWithDataLossFifoDepth1) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK(MakePassThroughProc("A", ch_in, a_to_b, b_to_a, ch_out, p.get())
                    .status());
  {
    // Inner proc does not receive on the first *two* ticks (i.e., doesn't
    // receive data). The FIFO depth is 1 but that is insufficent to prevent
    // data loss.
    //
    //   u32: st = 0
    //   while(true):
    //    if st >= 2:
    //       x = rcv(a_to_b)
    //    else:
    //       x = 0
    //    send(b_to_a, x + 42)
    //    st = st + 1
    ProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 32)));
    BValue rcv_from_a = bb.ReceiveIf(a_to_b, bb.GetTokenParam(),
                                     bb.UGe(st, bb.Literal(UBits(2, 32))));
    BValue send_to_a = bb.Send(
        b_to_a, bb.TupleIndex(rcv_from_a, 0),
        bb.Add(bb.TupleIndex(rcv_from_a, 1), bb.Literal(UBits(42, 32))));
    XLS_ASSERT_OK(bb.Build(send_to_a, {bb.Add(st, bb.Literal(UBits(1, 32)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3}}}, {{"out", {42, 42, 43}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  XLS_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SerialProcRuntime> interpreter,
                           CreateInterpreter(p.get(), {{"in", {1, 2, 3}}}));
  XLS_EXPECT_OK(interpreter->Tick());
  EXPECT_THAT(interpreter->Tick(),
              StatusIs(absl::StatusCode::kAborted,
                       HasSubstr("Channel a_to_b lost data")));
}

TEST_F(ProcInliningPassTest, DataLoss) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  // Outer proc "A" sends every tick to inner proc "B", but only receives from
  // "B" every other tick. This results in a overflow in one of the A<->B
  // channels.
  //
  //   st = 1
  //   while(true):
  //    x = rcv(in)
  //    send(a_to_b, x)
  //    if st:
  //      y = rcv(a_to_b)
  //      send(out, y)
  //    st = !st
  ProcBuilder ab("A", "tkn", p.get());
  BValue st = ab.StateElement("st", Value(UBits(1, 1)));
  BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());
  BValue in_data = ab.TupleIndex(rcv_in, 1);
  BValue send_to_b = ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), in_data);

  BValue rcv_from_b = ab.ReceiveIf(b_to_a, send_to_b, st);
  BValue send_out = ab.SendIf(ch_out, ab.TupleIndex(rcv_from_b, 0), st,
                              ab.TupleIndex(rcv_from_b, 1));
  XLS_ASSERT_OK(ab.Build(send_out, {ab.Not(st)}));

  XLS_ASSERT_OK(MakeLoopbackProc("B", a_to_b, b_to_a, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 4, 5}}}, {{"out", {1, 2, 3}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  XLS_ASSERT_OK_AND_ASSIGN(
      std::unique_ptr<SerialProcRuntime> interpreter,
      CreateInterpreter(p.get(), {{"in", {1, 2, 3, 4, 5}}}));

  XLS_EXPECT_OK(interpreter->Tick());
  EXPECT_THAT(interpreter->Tick(),
              StatusIs(absl::StatusCode::kAborted,
                       HasSubstr("Channel b_to_a lost data")));
}

TEST_F(ProcInliningPassTest, DataLossDueToReceiveNotActivated) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b0,
      p->CreateStreamingChannel("a_to_b0", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b1,
      p->CreateStreamingChannel("a_to_b1", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    // Top proc doesn't send on a_to_b0 on the first cycle which stalls the
    // inner proc.
    //
    //   st = 0
    //   while(true):
    //    if(st):
    //       snd(a_to_b0)
    //    snd(a_to_b1)
    //    st = 1
    ProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 1)));
    BValue rcv = ab.Receive(ch_in, ab.GetTokenParam());
    BValue send0 =
        ab.SendIf(a_to_b0, ab.TupleIndex(rcv, 0), st, ab.Literal(UBits(0, 32)));
    BValue send1 = ab.Send(a_to_b1, send0, ab.Literal(UBits(0, 32)));
    XLS_ASSERT_OK(ab.Build(send1, {ab.Literal(UBits(1, 1))}).status());
  }

  {
    // Inner proc is stalled on the first receive which results in the second
    // receive dropping data.
    //
    //   while(true):
    //    rcv(a_to_b0)
    //    rcv(a_to_b1)
    ProcBuilder bb("B", "tkn", p.get());
    BValue rcv0 = bb.Receive(a_to_b0, bb.GetTokenParam());
    BValue rcv1 = bb.Receive(a_to_b1, bb.TupleIndex(rcv0, 0));
    XLS_ASSERT_OK(bb.Build(bb.TupleIndex(rcv1, 0), {}));
  }

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  XLS_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SerialProcRuntime> interpreter,
                           CreateInterpreter(p.get(), {{"in", {1, 2, 3}}}));
  EXPECT_THAT(interpreter->Tick(),
              StatusIs(absl::StatusCode::kAborted,
                       HasSubstr("Channel a_to_b1 lost data")));
}

TEST_F(ProcInliningPassTest, SingleValueChannelWithVariantElements1) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  Type* u64 = p->GetBitsType(64);
  Type* u32_u64 = p->GetTupleType({u32, u64});
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateSingleValueChannel("y", ChannelOps::kReceiveOnly, u64));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_inputs,
      p->CreateSingleValueChannel("pass_inputs", ChannelOps::kSendReceive,
                                  u32_u64));
  XLS_ASSERT_OK_AND_ASSIGN(Channel * pass_result,
                           p->CreateStreamingChannel(
                               "pass_result", ChannelOps::kSendReceive, u32_u64,
                               /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result0_out,
      p->CreateStreamingChannel("result0_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result1_out,
      p->CreateStreamingChannel("result1_out", ChannelOps::kSendOnly, u64));

  {
    // Proc "A". Element 1 sent on pass_inputs is variant:
    //
    // while true:
    //   x = rcv(x_in)  // streaming
    //   y = rcv(y_in)  // single-value
    //   send(pass_inputs, (x, y))
    //   (result0, result1) = rcv(pass_result)
    //   send(result0_out, result0)
    //   send(result1_out, result1)
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue rcv_y = ab.Receive(y_in, ab.TupleIndex(rcv_x, 0));
    BValue send_inputs =
        ab.Send(pass_inputs, ab.TupleIndex(rcv_y, 0),
                ab.Tuple({ab.TupleIndex(rcv_x, 1), ab.TupleIndex(rcv_y, 1)}));

    BValue rcv_result = ab.Receive(pass_result, send_inputs);
    BValue rcv_result_data = ab.TupleIndex(rcv_result, 1);
    BValue send_result0 = ab.Send(result0_out, ab.TupleIndex(rcv_result, 0),
                                  ab.TupleIndex(rcv_result_data, 0));
    BValue send_result1 =
        ab.Send(result1_out, send_result0, ab.TupleIndex(rcv_result_data, 1));

    XLS_ASSERT_OK(ab.Build(send_result1, {}));
  }

  XLS_ASSERT_OK(
      MakeTupleAccumulator("B", pass_inputs, pass_result, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  int64_t original_proc_state_size = TotalProcStateSize(p.get());
  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {4, 14, 28}}, {"result1_out", {20, 40, 60}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  // The new proc state includes 35 additional bits::
  //   A activation bit (1)
  //   B activation bit (1)
  //   pass_result channel receive activation bit (1)
  //   pass_inputs channel receive activation bit (1)
  //   one variant element (32)
  EXPECT_EQ(TotalProcStateSize(p.get()), original_proc_state_size + 36);

  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {4, 14, 28}}, {"result1_out", {20, 40, 60}}});
}

TEST_F(ProcInliningPassTest, SingleValueChannelWithVariantElements2) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  Type* u64 = p->GetBitsType(64);
  Type* u32_u64 = p->GetTupleType({u32, u64});
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateSingleValueChannel("y", ChannelOps::kReceiveOnly, u64));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_inputs,
      p->CreateSingleValueChannel("pass_inputs", ChannelOps::kSendReceive,
                                  u32_u64));
  XLS_ASSERT_OK_AND_ASSIGN(Channel * pass_result,
                           p->CreateStreamingChannel(
                               "pass_result", ChannelOps::kSendReceive, u32_u64,
                               /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result0_out,
      p->CreateStreamingChannel("result0_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result1_out,
      p->CreateStreamingChannel("result1_out", ChannelOps::kSendOnly, u64));

  {
    // Proc "A". Element 1 sent on pass_inputs is variant:
    //
    // while true:
    //   x = rcv(x_in)  // streaming
    //   y = rcv(y_in)  // single-value
    //   send(pass_inputs, (x+1, y+1))
    //   (result0, result1) = rcv(pass_result)
    //   send(result0_out, result0)
    //   send(result1_out, result1)
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue rcv_y = ab.Receive(y_in, ab.TupleIndex(rcv_x, 0));
    BValue x_plus_1 = ab.Add(ab.TupleIndex(rcv_x, 1), ab.Literal(UBits(1, 32)));
    BValue y_plus_1 = ab.Add(ab.TupleIndex(rcv_y, 1), ab.Literal(UBits(1, 64)));
    BValue send_inputs = ab.Send(pass_inputs, ab.TupleIndex(rcv_y, 0),
                                 ab.Tuple({x_plus_1, y_plus_1}));

    BValue rcv_result = ab.Receive(pass_result, send_inputs);
    BValue rcv_result_data = ab.TupleIndex(rcv_result, 1);
    BValue send_result0 = ab.Send(result0_out, ab.TupleIndex(rcv_result, 0),
                                  ab.TupleIndex(rcv_result_data, 0));
    BValue send_result1 =
        ab.Send(result1_out, send_result0, ab.TupleIndex(rcv_result_data, 1));

    XLS_ASSERT_OK(ab.Build(send_result1, {}));
  }

  XLS_ASSERT_OK(
      MakeTupleAccumulator("B", pass_inputs, pass_result, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  int64_t original_proc_state_size = TotalProcStateSize(p.get());
  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {6, 18, 34}}, {"result1_out", {22, 44, 66}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EXPECT_EQ(TotalProcStateSize(p.get()), original_proc_state_size + 36);

  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {6, 18, 34}}, {"result1_out", {22, 44, 66}}});
}

TEST_F(ProcInliningPassTest, SingleValueChannelWithVariantElements3) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  Type* u32_u32 = p->GetTupleType({u32, u32});
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateSingleValueChannel("y", ChannelOps::kReceiveOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_inputs,
      p->CreateSingleValueChannel("pass_inputs", ChannelOps::kSendReceive,
                                  u32_u32));
  XLS_ASSERT_OK_AND_ASSIGN(Channel * pass_result,
                           p->CreateStreamingChannel(
                               "pass_result", ChannelOps::kSendReceive, u32_u32,
                               /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result0_out,
      p->CreateStreamingChannel("result0_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result1_out,
      p->CreateStreamingChannel("result1_out", ChannelOps::kSendOnly, u32));

  {
    // Proc "A". Element 1 sent on pass_inputs is variant:
    //
    // while true:
    //   x = rcv(x_in)  // streaming
    //   y = rcv(y_in)  // single-value
    //   send(pass_inputs, (y, x+y))
    //   (result0, result1) = rcv(pass_result)
    //   send(result0_out, result0)
    //   send(result1_out, result1)
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue rcv_y = ab.Receive(y_in, ab.TupleIndex(rcv_x, 0));
    BValue x = ab.TupleIndex(rcv_x, 1);
    BValue y = ab.TupleIndex(rcv_y, 1);
    BValue send_inputs = ab.Send(pass_inputs, ab.TupleIndex(rcv_y, 0),
                                 ab.Tuple({y, ab.Add(x, y)}));

    BValue rcv_result = ab.Receive(pass_result, send_inputs);
    BValue rcv_result_data = ab.TupleIndex(rcv_result, 1);
    BValue send_result0 = ab.Send(result0_out, ab.TupleIndex(rcv_result, 0),
                                  ab.TupleIndex(rcv_result_data, 0));
    BValue send_result1 =
        ab.Send(result1_out, send_result0, ab.TupleIndex(rcv_result_data, 1));

    XLS_ASSERT_OK(ab.Build(send_result1, {}));
  }

  XLS_ASSERT_OK(
      MakeTupleAccumulator("B", pass_inputs, pass_result, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  int64_t original_proc_state_size = TotalProcStateSize(p.get());
  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {20, 40, 60}}, {"result1_out", {24, 54, 88}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EXPECT_EQ(TotalProcStateSize(p.get()), original_proc_state_size + 36);

  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {20, 40, 60}}, {"result1_out", {24, 54, 88}}});
}

TEST_F(ProcInliningPassTest, SingleValueChannelWithVariantElements4) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  Type* u32_u32 = p->GetTupleType({u32, u32});
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * x_in,
      p->CreateStreamingChannel("x", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * y_in,
      p->CreateSingleValueChannel("y", ChannelOps::kReceiveOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * pass_inputs,
      p->CreateSingleValueChannel("pass_inputs", ChannelOps::kSendReceive,
                                  u32_u32));
  XLS_ASSERT_OK_AND_ASSIGN(Channel * pass_result,
                           p->CreateStreamingChannel(
                               "pass_result", ChannelOps::kSendReceive, u32_u32,
                               /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result0_out,
      p->CreateStreamingChannel("result0_out", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * result1_out,
      p->CreateStreamingChannel("result1_out", ChannelOps::kSendOnly, u32));

  {
    // Proc "A". Both elements sent on pass_inputs are variant:
    //
    // while true:
    //   x = rcv(x_in)  // streaming
    //   y = rcv(y_in)  // single-value
    //   send(pass_inputs, (x, x+y))  // single-value
    //   (result0, result1) = rcv(pass_result)
    //   send(result0_out, result0)
    //   send(result1_out, result1)
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_x = ab.Receive(x_in, ab.GetTokenParam());
    BValue rcv_y = ab.Receive(y_in, ab.TupleIndex(rcv_x, 0));
    BValue x = ab.TupleIndex(rcv_x, 1);
    BValue y = ab.TupleIndex(rcv_y, 1);
    BValue send_inputs = ab.Send(pass_inputs, ab.TupleIndex(rcv_y, 0),
                                 ab.Tuple({x, ab.Add(x, y)}));

    BValue rcv_result = ab.Receive(pass_result, send_inputs);
    BValue rcv_result_data = ab.TupleIndex(rcv_result, 1);
    BValue send_result0 = ab.Send(result0_out, ab.TupleIndex(rcv_result, 0),
                                  ab.TupleIndex(rcv_result_data, 0));
    BValue send_result1 =
        ab.Send(result1_out, send_result0, ab.TupleIndex(rcv_result_data, 1));

    XLS_ASSERT_OK(ab.Build(send_result1, {}));
  }

  XLS_ASSERT_OK(
      MakeTupleAccumulator("B", pass_inputs, pass_result, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  int64_t original_proc_state_size = TotalProcStateSize(p.get());
  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {4, 14, 28}}, {"result1_out", {24, 54, 88}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EXPECT_EQ(TotalProcStateSize(p.get()), original_proc_state_size + 36);

  EvalAndExpect(p.get(), {{"x", {2, 5, 7}}, {"y", {10}}},
                {{"result0_out", {4, 14, 28}}, {"result1_out", {24, 54, 88}}});
}

TEST_F(ProcInliningPassTest, TokenFanIn) {
  // Receive from two inputs, join the tokens then send the sum through another
  // proc.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in0,
      p->CreateStreamingChannel("in0", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in1,
      p->CreateStreamingChannel("in1", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_in0 = ab.Receive(ch_in0, ab.GetTokenParam());
    BValue rcv_in1 = ab.Receive(ch_in1, ab.GetTokenParam());
    BValue tkn_join =
        ab.AfterAll({ab.TupleIndex(rcv_in0, 0), ab.TupleIndex(rcv_in1, 0)});
    BValue send_to_b =
        ab.Send(a_to_b, tkn_join,
                ab.Add(ab.TupleIndex(rcv_in0, 1), ab.TupleIndex(rcv_in1, 1)));
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);
    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_b, 0),
                              ab.TupleIndex(rcv_from_b, 1));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  XLS_ASSERT_OK(MakeLoopbackProc("B", a_to_b, b_to_a, p.get()).status());

  EvalAndExpect(p.get(), {{"in0", {2, 5, 7}}, {"in1", {10, 20, 30}}},
                {{"out", {12, 25, 37}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));
  EXPECT_EQ(p->procs().size(), 1);

  EvalAndExpect(p.get(), {{"in0", {2, 5, 7}}, {"in1", {10, 20, 30}}},
                {{"out", {12, 25, 37}}});
}

TEST_F(ProcInliningPassTest, TokenFanOut) {
  // Send an input to two different procs, receive from them, join the tokens
  // and send the sum of the results.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_c,
      p->CreateStreamingChannel("a_to_c", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * c_to_a,
      p->CreateStreamingChannel("c_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    // Proc "A":
    //
    // while true:
    //   x = rcv(in)
    //   y = send(a_to_b, x)
    //   z = send(a_to_c, 2*x)
    //   send(out, x + y)
    ProcBuilder ab("A", "tkn", p.get());
    BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());
    BValue rcv_tkn = ab.TupleIndex(rcv_in, 0);
    BValue rcv_data = ab.TupleIndex(rcv_in, 1);

    BValue send_to_b = ab.Send(a_to_b, rcv_tkn, rcv_data);
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

    BValue send_to_c =
        ab.Send(a_to_c, rcv_tkn, ab.UMul(rcv_data, ab.Literal(UBits(2, 32))));
    BValue rcv_from_c = ab.Receive(c_to_a, send_to_c);

    BValue tkn_join = ab.AfterAll(
        {ab.TupleIndex(rcv_from_b, 0), ab.TupleIndex(rcv_from_c, 0)});
    BValue send_out = ab.Send(
        ch_out, tkn_join,
        ab.Add(ab.TupleIndex(rcv_from_b, 1), ab.TupleIndex(rcv_from_c, 1)));
    XLS_ASSERT_OK(ab.Build(send_out, {}));
  }

  XLS_ASSERT_OK(
      MakeLoopingAccumulatorProc("B", a_to_b, b_to_a, /*iterations=*/2, p.get())
          .status());
  XLS_ASSERT_OK(
      MakeLoopingAccumulatorProc("C", a_to_c, c_to_a, /*iterations=*/3, p.get())
          .status());

  EvalAndExpect(p.get(), {{"in", {2, 5, 7}}}, {{"out", {10, 19, 25}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));
  EXPECT_EQ(p->procs().size(), 1);

  EvalAndExpect(p.get(), {{"in", {2, 5, 7}}}, {{"out", {10, 19, 25}}});
}

TEST_F(ProcInliningPassTest, RandomProcNetworks) {
  // Create random proc networks and verify the results are the same before and
  // after proc inlining.

  // Number of proc networks to generate.
  const int kNumberSamples = 100;

  // Maximum number of iterations of any proc after receiveing but before
  // sending data.
  const int kMaxIterationCount = 10;

  // Maximum number of procs in the network.
  const int kMaxProcCount = 10;

  std::minstd_rand engine;
  std::uniform_int_distribution<int> proc_count_generator(1, kMaxProcCount);
  std::uniform_int_distribution<int> iteration_count_generator(
      1, kMaxIterationCount);
  std::bernoulli_distribution coin_flip(0.5);

  for (int sample = 0; sample < kNumberSamples; ++sample) {
    auto p = CreatePackage();
    Type* u32 = p->GetBitsType(32);

    XLS_ASSERT_OK_AND_ASSIGN(
        Channel * ch_in,
        p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
    XLS_ASSERT_OK_AND_ASSIGN(
        Channel * ch_out,
        p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

    // Top level builder.
    ProcBuilder b("top", "tkn", p.get());
    BValue receive_in = b.Receive(ch_in, b.GetTokenParam());

    // Vector of all the receives in the top level proc. When data is needed to
    // send to another proc, one of these values is randomly chosen.
    std::vector<BValue> receives = {receive_in};

    // Vector of all the tokens coming form send/receive nodes. When a
    // send/receive is generated a random subset of these is chosen as
    // predecessors in the token network.
    std::vector<BValue> tokens = {b.TupleIndex(receive_in, 0)};

    // Pair of channels for communicated with each nested proc and whether or
    // not data has been sent/received to/from the proc.
    struct ChannelPair {
      Channel* send_channel;
      bool sent;
      BValue send;
      Channel* receive_channel;
      bool received;
    };
    std::vector<ChannelPair> channel_pairs;

    // Construct set of non-top-level procs
    int proc_count = proc_count_generator(engine);
    std::vector<Proc*> procs;
    for (int proc_number = 0; proc_number < proc_count; ++proc_number) {
      // Generate channels to talk with proc.
      XLS_ASSERT_OK_AND_ASSIGN(
          Channel * from_top, p->CreateStreamingChannel(
                                  absl::StrFormat("top_to_proc%d", proc_number),
                                  ChannelOps::kSendReceive, u32,
                                  /*initial_values=*/{},
                                  /*fifo_depth=*/int64_t{coin_flip(engine)}));
      XLS_ASSERT_OK_AND_ASSIGN(
          Channel * to_top, p->CreateStreamingChannel(
                                absl::StrFormat("proc%d_to_top", proc_number),
                                ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{},
                                /*fifo_depth=*/int64_t{coin_flip(engine)}));

      channel_pairs.push_back(ChannelPair{.send_channel = from_top,
                                          .sent = false,
                                          .send = BValue(),
                                          .receive_channel = to_top,
                                          .received = false});

      // Generate proc with random loop iteration count.
      int64_t iteration_count = iteration_count_generator(engine);
      XLS_ASSERT_OK(
          MakeLoopingAccumulatorProc(absl::StrFormat("proc%d", proc_number),
                                     from_top, to_top,
                                     /*iterations=*/iteration_count, p.get())
              .status());
    }

    auto join_tokens = [&](absl::Span<const BValue> tkns) {
      if (tkns.size() == 1) {
        XLS_CHECK(tkns.front().node()->GetType()->IsToken())
            << tkns.front().node()->GetName();
        return tkns.front();
      }
      return b.AfterAll(tkns);
    };

    // While there still exists channels which haven't yet been send/received
    // on, pick a random channel and add a corresponging send/receive node.
    while (!channel_pairs.empty()) {
      // Choose a random channel to send/receive on.
      std::shuffle(channel_pairs.begin(), channel_pairs.end(), engine);
      ChannelPair& pair = channel_pairs.back();

      bool send_on_channel;
      Channel* channel;
      if (!pair.sent) {
        pair.sent = true;
        send_on_channel = true;
        channel = pair.send_channel;
      } else {
        XLS_CHECK(!pair.received);
        pair.received = true;
        send_on_channel = false;
        channel = pair.receive_channel;
      }

      if (send_on_channel) {
        // Choose random token predecessors.
        std::shuffle(tokens.begin(), tokens.end(), engine);
        int64_t token_count =
            std::uniform_int_distribution<int>(1, tokens.size())(engine);
        std::vector<BValue> token_predecessors;
        token_predecessors.reserve(token_count);
        for (int i = 0; i < token_count; i++) {
          token_predecessors.push_back(tokens[i]);
        }

        // Pick a random receive to get data from.
        std::shuffle(receives.begin(), receives.end(), engine);
        BValue receive = receives.front();
        BValue data = b.TupleIndex(receive, 1);

        // The send must be a token successor of the data source (receive).
        token_predecessors.push_back(b.TupleIndex(receive, 0));

        BValue send = b.Send(channel, join_tokens(token_predecessors), data);
        pair.send = send;
        tokens.push_back(send);
      } else {
        // The receive must be a token successor of the corresponding send.
        BValue receive = b.Receive(channel, pair.send);
        receives.push_back(receive);
        tokens.push_back(b.TupleIndex(receive, 0));

        // Done with this channel pair.
        channel_pairs.pop_back();
      }
    }

    // Sum all data from all receives together.
    BValue sum = b.TupleIndex(receives[0], 1);
    for (int64_t i = 1; i < receives.size(); ++i) {
      sum = b.Add(sum, b.TupleIndex(receives[i], 1));
    }

    BValue send_out = b.Send(ch_out, join_tokens(tokens), sum);
    XLS_ASSERT_OK_AND_ASSIGN(Proc * top, b.Build(send_out, {}));
    XLS_ASSERT_OK(p->SetTop(top));

    XLS_VLOG(1) << "Sample " << sample << " (before inlining):\n"
                << p->DumpIr();

    // Run the proc network interpreter on the proc network before inlining
    // using a few prechosen inputs. After inlining, the generated results
    // should be the same.
    absl::flat_hash_map<std::string, std::vector<int64_t>> inputs = {
        {"in", {2, 5, 7}}};
    XLS_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SerialProcRuntime> interpreter,
                             CreateInterpreter(p.get(), inputs));
    ChannelQueue& output_queue = interpreter->queue_manager().GetQueue(ch_out);
    while (output_queue.GetSize() < inputs.at("in").size()) {
      XLS_ASSERT_OK(interpreter->Tick());
    }
    absl::flat_hash_map<std::string, std::vector<int64_t>> expected_outputs;
    while (!output_queue.IsEmpty()) {
      Value output = output_queue.Read().value();
      expected_outputs[ch_out->name()].push_back(
          output.bits().ToUint64().value());
    }

    ASSERT_THAT(Run(p.get()), IsOkAndHolds(true));

    EXPECT_EQ(p->procs().size(), 1);

    XLS_VLOG(1) << "Sample " << sample << " (after inlining):\n" << p->DumpIr();
    EvalAndExpect(p.get(), inputs, expected_outputs);
  }
}

TEST_F(ProcInliningPassTest, DataDependencyWithoutTokenDependency) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  ProcBuilder ab("A", "tkn", p.get());
  BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());
  BValue in_data = ab.TupleIndex(rcv_in, 1);
  BValue send_to_b = ab.Send(a_to_b, ab.TupleIndex(rcv_in, 0), in_data);
  BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

  // Send gets its token from the token param, so no token dependency from the
  // (data-dependent) receive from b.
  BValue send_out = ab.Send(ch_out, ab.GetTokenParam(),
                            ab.Add(in_data, ab.TupleIndex(rcv_from_b, 1)));

  XLS_ASSERT_OK(
      ab.Build(ab.AfterAll({send_out, ab.TupleIndex(rcv_from_b, 0)}), {}));

  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("B", /*delay=*/3, a_to_b, b_to_a, p.get())
          .status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {123, 22, 42}}}, {{"out", {246, 44, 84}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"),
              StatusIs(absl::StatusCode::kUnimplemented,
                       HasSubstr("no token path exists")));
}

TEST_F(ProcInliningPassTest, ReceivedValueSentAndNext) {
  // Receive a value and pass to a send and a next-state value. This tests
  // whether the received value is properly saved due to being passed to the
  // next-state value.
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  {
    // Proc "A":
    //
    // st = 0
    // while true:
    //   in = rcv(in)
    //   send(a_to_b, in)
    //   x = rcv(b_to_a)
    //   send(out, st + x)
    //   st = in
    ProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 32)));
    BValue rcv_in = ab.Receive(ch_in, ab.GetTokenParam());
    BValue rcv_tkn = ab.TupleIndex(rcv_in, 0);
    BValue rcv_data = ab.TupleIndex(rcv_in, 1);

    BValue send_to_b = ab.Send(a_to_b, rcv_tkn, rcv_data);
    BValue rcv_from_b = ab.Receive(b_to_a, send_to_b);

    BValue send_out = ab.Send(ch_out, ab.TupleIndex(rcv_from_b, 0),
                              ab.Add(ab.TupleIndex(rcv_from_b, 1), st));
    XLS_ASSERT_OK(ab.Build(send_out, {ab.Identity(rcv_data)}).status());
  }

  XLS_ASSERT_OK(
      MakeDelayedLoopbackProc("B", /*delay=*/2, a_to_b, b_to_a, p.get())
          .status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {5, 7, 13}}}, {{"out", {5, 12, 20}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {5, 7, 13}}}, {{"out", {5, 12, 20}}});
}

TEST_F(ProcInliningPassTest, OffsetSendAndReceive) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  {
    // Proc A sends every 16 ticks starting at tick 0:
    //
    // u32 st = 0
    // while true:
    //   if st & 0xf == 0:
    //     send(a_to_b, st)
    //   st = st + 1
    ProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 32)));
    BValue send_cond =
        ab.Eq(ab.And(st, ab.Literal(UBits(0xf, 32))), ab.Literal(UBits(0, 32)));
    BValue send = ab.SendIf(a_to_b, ab.GetTokenParam(), send_cond, st);
    XLS_ASSERT_OK(ab.Build(send, {ab.Add(st, ab.Literal(UBits(1, 32)))}));
  }

  {
    // Proc B receives every 8 ticks starting at tick 7.
    //
    // u32 st = 0:
    // while true:
    //   if st & 0b111 == 0b111:
    //     data = rcv(a_to_b)
    //     send(out, data)
    //   st = st + 1
    ProcBuilder bb("1", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 32)));
    BValue cond =
        bb.Eq(bb.And(st, bb.Literal(UBits(7, 32))), bb.Literal(UBits(7, 32)));
    BValue rcv = bb.ReceiveIf(a_to_b, bb.GetTokenParam(), cond);
    BValue rcv_token = bb.TupleIndex(rcv, 0);
    BValue rcv_data = bb.TupleIndex(rcv, 1);
    BValue send = bb.SendIf(ch_out, rcv_token, cond, rcv_data);
    XLS_ASSERT_OK(bb.Build(send, {bb.Add(st, bb.Literal(UBits(1, 32)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {}, {{"out", {0, 16, 32, 48, 64}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {}, {{"out", {0, 16, 32, 48, 64}}});
}

// TODO(meheff): 2022/06/23 Handle case where inlining can produce cycles.
TEST_F(ProcInliningPassTest, DISABLED_InliningProducesCycle) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * b_to_a,
      p->CreateStreamingChannel("b_to_a", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  {
    // On tick 0, outer proc only sends to inner proc (and out). Subsequent
    // ticks receive from inner proc and then send the value back to inner proc
    // and to out channel.
    //
    // u1 st = 0
    // while true:
    //   if st:
    //     data = rcv(b_to_a)
    //   else:
    //     data = 0
    //   send(a_to_b, data)
    //   send(out, data)
    //   st = 1
    //
    ProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 1)));
    BValue rcv = ab.ReceiveIf(b_to_a, ab.GetTokenParam(), st);
    BValue rcv_token = ab.TupleIndex(rcv, 0);
    BValue rcv_data = ab.TupleIndex(rcv, 1);
    BValue send_to_b = ab.Send(a_to_b, rcv_token, rcv_data);
    BValue send_out = ab.Send(ch_out, send_to_b, rcv_data);
    XLS_ASSERT_OK(ab.Build(send_out, {ab.Literal(UBits(1, 1))}));
  }

  {
    // Inner proc receives every 8 ticks starting at tick 7:
    //
    // while true:
    //   data = rcv(a_to_b)
    //   data = data + 1
    //   send(b_to_a, data)
    ProcBuilder bb("B", "tkn", p.get());
    BValue rcv = bb.Receive(a_to_b, bb.GetTokenParam());
    BValue rcv_token = bb.TupleIndex(rcv, 0);
    BValue rcv_data = bb.TupleIndex(rcv, 1);
    BValue send =
        bb.Send(b_to_a, rcv_token, bb.Add(rcv_data, bb.Literal(UBits(1, 32))));
    XLS_ASSERT_OK(bb.Build(send, {}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {}, {{"out", {0, 1, 2, 3}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {}, {{"out", {0, 1, 2, 3}}});
}

TEST_F(ProcInliningPassTest, MultipleSends) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  {
    // u1 st = 0
    // while true:
    //   input = rcv(in)
    //   if st
    //     send(a_to_b, input + 10)
    //   else:
    //     send(a_to_b, input)
    //   st = !st
    TokenlessProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 1)));
    BValue input = ab.Receive(ch_in);
    ab.SendIf(a_to_b, st, ab.Add(input, ab.Literal(UBits(10, 32))));
    ab.SendIf(a_to_b, ab.Not(st), input);
    XLS_ASSERT_OK(ab.Build({ab.Not(st)}));
  }

  XLS_ASSERT_OK(MakeLoopbackProc("B", a_to_b, ch_out, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});
}

TEST_F(ProcInliningPassTest, MultipleSendsInDifferentOrder) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  {
    // u1 st = 0
    // while true:
    //   input = rcv(in)
    //   if !st
    //     send(a_to_b, input)
    //   else:
    //     send(a_to_b, input + 10)
    //   st = !st
    TokenlessProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(0, 1)));
    BValue input = ab.Receive(ch_in);
    ab.SendIf(a_to_b, ab.Not(st), input);
    ab.SendIf(a_to_b, st, ab.Add(input, ab.Literal(UBits(10, 32))));
    XLS_ASSERT_OK(ab.Build({ab.Not(st)}));
  }

  XLS_ASSERT_OK(MakeLoopbackProc("B", a_to_b, ch_out, p.get()).status());

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});
}

TEST_F(ProcInliningPassTest, MultipleReceivesFifoDepth0) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK(MakeLoopbackProc("A", ch_in, a_to_b, p.get()).status());

  {
    // u1 st = 0
    // while true:
    //   if st
    //     x = rcv(a_to_b) + 10
    //   else:
    //     x = rcv(a_to_b)
    //   send(out, x)
    //   st = !st
    TokenlessProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue tmp0 = bb.Add(bb.ReceiveIf(a_to_b, st), bb.Literal(UBits(10, 32)));
    BValue tmp1 = bb.ReceiveIf(a_to_b, bb.Not(st));
    BValue x = bb.Select(st, tmp0, tmp1);
    bb.Send(ch_out, x);
    XLS_ASSERT_OK(bb.Build({bb.Not(st)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});
}

TEST_F(ProcInliningPassTest, MultipleReceivesFifoDepth1) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK(MakeLoopbackProc("A", ch_in, a_to_b, p.get()).status());

  {
    // u1 st = 0
    // while true:
    //   if st
    //     x = rcv(a_to_b) + 10
    //   else:
    //     x = rcv(a_to_b)
    //   send(out, x)
    //   st = !st
    TokenlessProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue tmp0 = bb.Add(bb.ReceiveIf(a_to_b, st), bb.Literal(UBits(10, 32)));
    BValue tmp1 = bb.ReceiveIf(a_to_b, bb.Not(st));
    BValue x = bb.Select(st, tmp0, tmp1);
    bb.Send(ch_out, x);
    XLS_ASSERT_OK(bb.Build({bb.Not(st)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {1, 12, 3, 52, 123}}});
}

TEST_F(ProcInliningPassTest, MultipleReceivesDoesNotFireEveryTick) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK(MakeLoopbackProc("A", ch_in, a_to_b, p.get()).status());

  {
    // u2 st = 0
    // while true:
    //   if st == 0:
    //     x = rcv(a_to_b)
    //   else if st == 1:
    //     x = rcv(a_to_b) + 1
    //   else if st == 2:
    //     x = rcv(a_to_b) + 2
    //   send(out, x)
    //   st = st + 1
    TokenlessProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 2)));
    BValue st_eq_0 = bb.Eq(st, bb.Literal(UBits(0, 2)));
    BValue st_eq_1 = bb.Eq(st, bb.Literal(UBits(1, 2)));
    BValue st_eq_2 = bb.Eq(st, bb.Literal(UBits(2, 2)));
    BValue tmp0 = bb.ReceiveIf(a_to_b, st_eq_0);
    BValue tmp1 =
        bb.Add(bb.ReceiveIf(a_to_b, st_eq_1), bb.Literal(UBits(1, 32)));
    BValue tmp2 =
        bb.Add(bb.ReceiveIf(a_to_b, st_eq_2), bb.Literal(UBits(2, 32)));
    BValue x = bb.Select(st, {tmp0, tmp1, tmp2, bb.Literal(UBits(0, 32))});
    bb.Send(ch_out, x);
    XLS_ASSERT_OK(bb.Build({bb.Add(st, bb.Literal(UBits(1, 2)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123, 333}}},
                {{"out", {1, 3, 5, 0, 42, 124}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123, 333}}},
                {{"out", {1, 3, 5, 0, 42, 124}}});
}

TEST_F(ProcInliningPassTest, MultipleReceivesDoesNotFireEveryTickFifoDepth0) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/0));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK(MakeLoopbackProc("A", ch_in, a_to_b, p.get()).status());

  {
    // u2 st = 0
    // while true:
    //   if st == 0:
    //     x = rcv(a_to_b)
    //   else if st == 1:
    //     x = rcv(a_to_b) + 1
    //   else if st == 2:
    //     x = rcv(a_to_b) + 2
    //   send(out, x)
    //   st = st + 1
    TokenlessProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 2)));
    BValue st_eq_0 = bb.Eq(st, bb.Literal(UBits(0, 2)));
    BValue st_eq_1 = bb.Eq(st, bb.Literal(UBits(1, 2)));
    BValue st_eq_2 = bb.Eq(st, bb.Literal(UBits(2, 2)));
    BValue tmp0 = bb.ReceiveIf(a_to_b, st_eq_0);
    BValue tmp1 =
        bb.Add(bb.ReceiveIf(a_to_b, st_eq_1), bb.Literal(UBits(1, 32)));
    BValue tmp2 =
        bb.Add(bb.ReceiveIf(a_to_b, st_eq_2), bb.Literal(UBits(2, 32)));
    BValue x = bb.Select(st, {tmp0, tmp1, tmp2, bb.Literal(UBits(0, 32))});
    bb.Send(ch_out, x);
    XLS_ASSERT_OK(bb.Build({bb.Add(st, bb.Literal(UBits(1, 2)))}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123, 333}}},
                {{"out", {1, 3, 5, 0, 42, 124}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  XLS_ASSERT_OK_AND_ASSIGN(
      std::unique_ptr<SerialProcRuntime> interpreter,
      CreateInterpreter(p.get(), {{"in", {1, 2, 3, 42, 123, 333}}}));

  // Data is lost on tick 3 because a receive does not fire and the fifo
  // depth is zero.
  XLS_EXPECT_OK(interpreter->Tick());
  XLS_EXPECT_OK(interpreter->Tick());
  XLS_EXPECT_OK(interpreter->Tick());
  EXPECT_THAT(interpreter->Tick(),
              StatusIs(absl::StatusCode::kAborted,
                       HasSubstr("Channel a_to_b lost data")));
}

TEST_F(ProcInliningPassTest, MultipleSendsAndReceives) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out,
      p->CreateStreamingChannel("out", ChannelOps::kSendOnly, u32));

  {
    // u1 st = 1
    // while true:
    //   input = rcv(in)
    //   if st
    //     send(a_to_b, input + 10)
    //   else:
    //     send(a_to_b, input)
    //   st = !st
    TokenlessProcBuilder ab("A", "tkn", p.get());
    BValue st = ab.StateElement("st", Value(UBits(1, 1)));
    BValue input = ab.Receive(ch_in);
    ab.SendIf(a_to_b, st, ab.Add(input, ab.Literal(UBits(10, 32))));
    ab.SendIf(a_to_b, ab.Not(st), input);
    XLS_ASSERT_OK(ab.Build({ab.Not(st)}));
  }

  {
    // u1 st = 0
    // while true:
    //   if st
    //     x = rcv(a_to_b) + 100
    //   else:
    //     x = rcv(a_to_b)
    //   send(out, x)
    //   st = !st
    TokenlessProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue tmp0 = bb.Add(bb.ReceiveIf(a_to_b, st), bb.Literal(UBits(100, 32)));
    BValue tmp1 = bb.ReceiveIf(a_to_b, bb.Not(st));
    BValue x = bb.Select(st, tmp0, tmp1);
    bb.Send(ch_out, x);
    XLS_ASSERT_OK(bb.Build({bb.Not(st)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {11, 102, 13, 142, 133}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(p.get(), {{"in", {1, 2, 3, 42, 123}}},
                {{"out", {11, 102, 13, 142, 133}}});
}

TEST_F(ProcInliningPassTest, ReceiveIfsWithFalseCondition) {
  auto p = CreatePackage();
  Type* u32 = p->GetBitsType(32);

  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_in,
      p->CreateStreamingChannel("in", ChannelOps::kReceiveOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * a_to_b,
      p->CreateStreamingChannel("a_to_b", ChannelOps::kSendReceive, u32,
                                /*initial_values=*/{}, /*fifo_depth=*/1));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out0,
      p->CreateStreamingChannel("out0", ChannelOps::kSendOnly, u32));
  XLS_ASSERT_OK_AND_ASSIGN(
      Channel * ch_out1,
      p->CreateStreamingChannel("out1", ChannelOps::kSendOnly, u32));

  XLS_ASSERT_OK(MakeLoopbackProc("A", ch_in, a_to_b, p.get()).status());

  {
    // u1 st = 0
    // while true:
    //   x = 0
    //   y = 0
    //   if st
    //     x = rcv(a_to_b) + 100
    //   else:
    //     y = rcv(a_to_b)
    //   send(out0, x)
    //   send(out1, y)
    //   st = !st
    TokenlessProcBuilder bb("B", "tkn", p.get());
    BValue st = bb.StateElement("st", Value(UBits(0, 1)));
    BValue x = bb.Add(bb.ReceiveIf(a_to_b, st), bb.Literal(UBits(100, 32)));
    BValue y = bb.ReceiveIf(a_to_b, bb.Not(st));
    bb.Send(ch_out0, x);
    bb.Send(ch_out1, y);
    XLS_ASSERT_OK(bb.Build({bb.Not(st)}));
  }

  EXPECT_EQ(p->procs().size(), 2);
  EvalAndExpect(
      p.get(), {{"in", {1, 2, 3, 42, 123}}},
      {{"out0", {100, 102, 100, 142, 100}}, {"out1", {1, 0, 3, 0, 123}}});

  ASSERT_THAT(Run(p.get(), /*top=*/"A"), IsOkAndHolds(true));

  EXPECT_EQ(p->procs().size(), 1);
  EvalAndExpect(
      p.get(), {{"in", {1, 2, 3, 42, 123}}},
      {{"out0", {100, 102, 100, 142, 100}}, {"out1", {1, 0, 3, 0, 123}}});
}

}  // namespace
}  // namespace xls
