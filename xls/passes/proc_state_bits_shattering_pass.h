// Copyright 2025 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_PROC_STATE_BITS_SHATTERING_PASS_H_
#define XLS_PASSES_PROC_STATE_BITS_SHATTERING_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/proc.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which transforms Bits-type elements of the proc state into tuples of
// components. Only flattens where it can show that doing so will enable
// dynamic state feedback opportunities later (assuming it's followed by a
// ProcStateTupleFlatteningPass).
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ProcStateBitsShatteringPass` is an optimization pass that refactors
// `bits`-typed elements within a Proc's state. It breaks down (or "shatters")
// these wide bit vectors into a tuple of smaller `bits` components.
//
// The primary motivation for this transformation is to expose opportunities for
// subsequent passes (such as `ProcStateTupleFlatteningPass`) to enable more
// granular and dynamic control over individual state bits, which can lead to
// more efficient hardware implementations.
//
// The pass intelligently identifies `bits`-typed state elements where splitting
// would be beneficial. It only performs the transformation if it can
// demonstrate that doing so will likely enable dynamic state feedback. This
// often involves detecting specific patterns within the `next_value`
// expressions that define the next state, particularly when those `next_value`
// expressions involve `concat` operations whose operands are `select` or
// `priority_select` operations.
//
// Here's a breakdown of its operation:
//
// 1.  **Identification of Splitting Candidates**: The pass iterates through all
//     `bits`-typed state elements within a Proc.
//
// 2.  **Analysis of `next_value` Expressions**: For each state element, it
//     examines its associated `next_value` operations:
//     *   Simple pass-through `next_value`s (where the next value is just the
//         current state read) do not offer new splitting opportunities.
//
//     *   If a `next_value` is defined by a `concat` operation, the pass
//         analyzes the bit widths of the `concat`'s operands to identify
//         potential "split points" within the overall bit vector. For example,
//         for `concat(hi, mid, lo)`, split points would be after `lo` and after
//         `mid`.
//
//     *   A key heuristic for determining if splitting is beneficial is when
//         one or more of these `concat` operands are themselves `select` or
//         `priority_select` operations (or small `select` operations, if
//         enabled by `options.split_next_value_selects`). This pattern
//         suggests that different parts of the state element are updated based
//         on different conditions, and splitting them allows for more
//         fine-grained conditional updates to individual components.
//
// 3.  **Intersection of Split Points**: If multiple `next_value` operations
//     update the same state element, the pass calculates the intersection of
//     their suggested split points. This ensures that any performed splitting
//     is mutually beneficial for all updates to that state element.
//
// 4.  **Transformation**: If a beneficial set of split points (resulting in
//     more than one component) is identified, the `bits`-typed state element is
//     transformed into a `tuple` of smaller `bits` types.
//     *   The `StateRead` operation for the original state element is replaced
//         with a `concat` of `tuple_index` operations, effectively
//         reconstructing the original bit vector from the new tuple components
//         when the full value is needed.
//
//     *   Each `next_value` operation for the original state element is
//         replaced with a `tuple` of `bit_slice` operations, extracting the
//         appropriate bit ranges for each component of the new tuple state.
//
//     *   The `initial_value` of the state element is also converted into a
//         tuple literal matching the new structure.
//
// Example:
// Consider a 16-bit state element `x` where its `next_value` is a `concat` of
// three smaller bit groups (`x_hi`, `new_x_mid`, `x_lo`), and `new_x_mid` is
// derived from a `select` operation.
//
//
// ```
// // Original state and next value
// x: bits[16] = state_element(init=0)
// // ...
// x_lo: bits[6] = bit_slice(x, start=0, width=6)
// x_mid: bits[1] = bit_slice(x, start=6, width=1)
// x_hi: bits[9] = bit_slice(x, start=7, width=9)
// // Conditional update
// new_x_mid: bits[1] = select(or_reduce(x_lo), cases={x_mid, not(x_mid)})
// next_value(x, value=concat(x_hi, new_x_mid, x_lo))
// ```
//
//
// The `ProcStateBitsShatteringPass` would identify that `x` can be beneficially
// split into three components (e.g., 6 bits, 1 bit, 9 bits) because
// `new_x_mid` is a `select` operation, indicating a conditional update to a
// sub-part of `x`. It would transform `x` into a tuple state element:
//
//
// ```
// // Transformed state element and its updates (simplified)
// x: (bits[6], bits[1], bits[9]) = state_element(init=(0,0,0))
// // ...
// x_read_tuple: (bits[6], bits[1], bits[9]) = state_read(x)
// x_new_lo: bits[6] = tuple_index(x_read_tuple, 0)
// x_new_mid: bits[1] = tuple_index(x_read_tuple, 1)
// x_new_hi: bits[9] = tuple_index(x_read_tuple, 2)
//
// // Original `StateRead` users now reconstruct the full bit vector
// original_x_usage: bits[16] = concat(x_new_hi, x_new_mid, x_new_lo)
//
// // `next_value` now operates on the tuple components
// next_value(x, value=tuple(bit_slice(concat_value, 0, 6),
//                           bit_slice(concat_value, 6, 1),
//                           bit_slice(concat_value, 7, 9)))
// ```
//
//
// This transformation enables subsequent passes to optimize the updates to
// `x_lo`, `x_mid`, and `x_hi` independently, particularly when conditional
// logic can be localized to specific components, ultimately leading to more
// efficient hardware.
class ProcStateBitsShatteringPass : public OptimizationProcPass {
 public:
  static constexpr std::string_view kName = "proc_state_bits_shatter";

  ProcStateBitsShatteringPass()
      : OptimizationProcPass(kName, "Proc State Bits Shattering") {}
  ~ProcStateBitsShatteringPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnProcInternal(
      Proc* proc, const OptimizationPassOptions& options, PassResults* results,
      OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_PROC_STATE_BITS_SHATTERING_PASS_H_
