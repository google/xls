// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_BIT_SLICE_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_BIT_SLICE_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which simplifies bit-slices. This includes collapsing sequential
// bit-slices, eliminating degenerate full-width slices, and others.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `BitSliceSimplificationPass` is a crucial optimization pass that targets
// and simplifies operations related to bit manipulation: `bit_slice`,
// `dynamic_bit_slice`, and `bit_slice_update`. The overarching goal is to
// reduce logical complexity, enhance hardware efficiency, and generate cleaner
// IR by eliminating redundancies and transforming patterns into more canonical
// forms that are easier for hardware synthesis tools to process.
//
// The pass employs a combination of local pattern matching and advanced query
// engine analysis (utilizing `LazyTernaryQueryEngine` or
// `PartialInfoQueryEngine` for higher optimization levels) to identify and
// capitalize on simplification opportunities.
//
// Key simplifications performed by this pass include:
//
// 1.  **Simplifying `BitSlice` Operations**:
//     *   **Full-Width Slices**: A `bit_slice` that extracts the entire bit
//         width of its operand (e.g., `bit_slice(x, start=0, width=N)`) is a
//         no-operation and is directly replaced by its operand `x`.
//
//     *   **Consecutive `BitSlice` Operations**: Nested `bit_slice` operations
//         (e.g., `bit_slice(bit_slice(x, s0, w0), s1, w1)`) are collapsed into
//         a single `bit_slice(x, s0 + s1, w1)`, effectively combining the
//         slicing operations.
//
//     *   **Hoisting `BitSlice` above `Concat`**: A `bit_slice` of a `concat`
//         operation can often be rewritten as a `concat` of smaller
//         `bit_slice`s of the original `concat` operands. This allows for more
//         precise extraction of relevant bits and can eliminate unnecessary
//         concatenations.
//
//     *   **Hoisting `BitSlice` above Bitwise/Arithmetic Operations**: If a
//         `bit_slice` is the *sole consumer* of a bitwise operation (e.g.,
//         `and`, `or`, `xor`) or targets the low bits of an arithmetic
//         operation (e.g., `add`, `sub`, `neg`), the `bit_slice` can be pushed
//         down into the operands. This transforms `bit_slice(op(A, B), ...)`
//         into `op(bit_slice(A, ...), bit_slice(B, ...))`, reducing the width
//         of the intermediate `op` result.
//
//     *   **Hoisting `BitSlice` above `SignExt`**: Handles various cases where
//         a `bit_slice` operates on a `sign_ext` operation. It simplifies this
//         by transforming it into a direct slice of the original value or a
//         `sign_ext` of a smaller slice, depending on where the slice falls
//         relative to the sign bit of the extended value.
//
//     *   **Hoisting `BitSlice` above Shifts and Decodes**: If all users of a
//         shift or decode operation are bit-slices entirely contained within a
//         larger slice, the `bit_slice` can be hoisted above the shift/decode.
//         This effectively performs the shift/decode on a smaller bit-width
//         operand, reducing computation.
//
//     *   **Hoisting `BitSlice` above Selects**: If all users of a `select` (or
//         `one_hot_select`/`priority_select`) are bit-slices entirely contained
//         within a larger slice, the `bit_slice` can be hoisted above the
//         `select`. This results in the `select` operating on smaller, sliced
//         operands, which can reduce the multiplexer complexity.
//
// 2.  **Simplifying `DynamicBitSlice` Operations**:
//     *   **Out-of-Bounds Slices**: A `dynamic_bit_slice` whose start index is
//         provably out of bounds (meaning it attempts to slice entirely beyond
//         the operand's bit width) is replaced with a literal zero, as no data
//         can be extracted.
//
//     *   **Literal Start Index**: A `dynamic_bit_slice` with a known constant
//         start index is converted into a static `bit_slice` operation. This
//         eliminates dynamic addressing logic in the hardware.
//
//     *   **Hoisting `DynamicBitSlice` above `Select` of Literals**: If the
//         start index of a `dynamic_bit_slice` is the result of a `select`
//         operation where all the cases are literal constant values, the
//         `dynamic_bit_slice` can be hoisted. This replaces the original
//         `select` with a new `select` whose cases are static `bit_slice`
//         operations, each corresponding to one of the literal start indices.
//
//         ```
//         // Original IR
//         start1: bits[32] = literal(value=5)
//         start2: bits[32] = literal(value=25)
//         p: bits[32] = select(x, cases=[start1, start2])
//         q: bits[45] = dynamic_bit_slice(to_slice, p, width=45)
//
//         // Optimized IR (conceptually)
//         slice1: bits[45] = bit_slice(to_slice, start=5, width=45)
//         slice2: bits[45] = bit_slice(to_slice, start=25, width=45)
//         q: bits[45] = select(x, cases=[slice1, slice2])
//         ```
//
//     *   **Scaled Dynamic Bit Slices**: Optimizes `dynamic_bit_slice`
//         operations where the start index is a known multiple of the slice
//         width. This involves conceptually treating the `to_slice` operand as
//         an array of smaller bit elements and then using a `select` operation
//         to choose the correct element from this conceptual array.
//
// 3.  **Simplifying `BitSliceUpdate` Operations**:
//     *   **Out-of-Bounds Updates**: A `bit_slice_update` whose start index is
//         provably out of bounds is replaced by its `to_update` operand, as it
//         would have no effect on the target bit vector.
//
//     *   **Literal Start Index**: A `bit_slice_update` with a known constant
//         start index is replaced by an equivalent `concat` and `bit_slice`
//         structure. This eliminates the need for dynamic update logic in the
//         hardware.
//
//     *   **Hoisting `BitSliceUpdate` above `Select` of Literals**: Similar to
//         `DynamicBitSlice` with `select` of literals, if the start index of a
//         `bit_slice_update` is derived from a `select` of literals, the
//         `bit_slice_update` can be hoisted, resulting in static
//         `bit_slice_update` operations for each case of the original `select`.
//
//     *   **Scaled Bit Slice Updates**: Optimizes `bit_slice_update` operations
//         where the start index is a known multiple of the update value's
//         width.  This involves converting the `to_update` operand into an
//         array of smaller bit elements, performing an `array_update` on this
//         conceptual array, and then flattening the result back into a bit
//         vector using `concat`.
//
// The pass operates in a worklist-driven fashion, particularly for `bit_slice`
// nodes, ensuring that simplifications are iteratively applied until a fixed
// point is reached. This comprehensive approach guarantees a thorough
// optimization of bit manipulation logic, crucial for high-quality hardware
// generation.
class BitSliceSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "bitslice_simp";
  explicit BitSliceSimplificationPass()
      : OptimizationFunctionBasePass(kName, "Bit-slice simplification") {}
  ~BitSliceSimplificationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_BIT_SLICE_SIMPLIFICATION_PASS_H_
