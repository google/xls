// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_ARITH_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_ARITH_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// This pass performs various arithmetic optimizations such as replacement of
// divide by a constant with non-divide operations.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ArithSimplificationPass` is an optimization pass in XLS that applies a
// wide range of arithmetic transformations to simplify expressions, reduce
// hardware complexity, and improve overall efficiency. It utilizes a
// `StatelessQueryEngine` to identify constant values and bit patterns, which
// enables many of its powerful transformations. This pass operates in an
// iterative fixed-point manner, meaning it repeatedly applies simplifications
// until no further changes can be made, ensuring a thorough optimization.
//
// Key optimizations performed by this pass include:
//
// 1.  **Division and Modulo by Constants**:
//
//     *   **Division by Power of Two**: `udiv(x, 2^K)` or `sdiv(x, 2^K)` is
//         replaced with a right or left shift by `K` bits, respectively. This
//         is a fundamental hardware optimization.
//
//     *   **Modulo by Power of Two**: `umod(x, 2^K)` is replaced with a bit
//         slice to extract the `K` least significant bits. For `smod(x, 2^K)`,
//         it's handled by a `select` operation based on the sign of `x` to
//         ensure correct signed modulo semantics.
//
//     *   **Division/Modulo by Other Constants (Unsigned)**: `udiv(x, K)` where
//         `K` is a constant (not a power of two) is transformed using "magic
//         multiplication" algorithms, which replace division with a combination
//         of shifts and multiplies. This is often significantly more efficient
//         in hardware than a dedicated division unit.
//
//     *   **Division/Modulo by Other Constants (Signed)**: `sdiv(x, K)` where
//         `K` is a constant, also employs magic multiplication, with additional
//         logic to correctly handle signed semantics and rounding towards zero.
//
//     *   **Constant Dividend Optimization**: If the *dividend* is a small
//         constant (e.g., `udiv(13, x)` or `sdiv(13, x)`), the operation is
//         replaced by a lookup table (`PrioritySelect` over a `Literal` array).
//         This is particularly effective for small constant dividends where a
//         full division circuit is overkill.
//
// 2.  **Shift Operations**:
//
//     *   **Logical Shift by Constant**: `shll(x, K)` or `shrl(x, K)` where `K`
//         is a constant, is replaced by a combination of `bit_slice` and
//         `concat` operations. This avoids generating a potentially larger
//         barrel shifter for fixed-amount shifts.
//
//         ```
//         // Original: shrl(x, literal(2, bits=N_shift_amount_width))
//         // Example for shift by 2
//         // Optimized: concat(literal(0, bits=2),
//                              bit_slice(x, start=2, width=N-2))
//         ```
//
//
//     *   **Arithmetic Shift Right by Constant**: `shra(x, K)` is replaced by a
//         `sign_extend` of a `bit_slice` of `x`, effectively performing an
//         arithmetic right shift without a barrel shifter.
//
//     *   **Removal of Zero-Extended Shift Amounts**: If a shift amount is the
//         result of a `concat` with leading zeros (a common pattern for
//         zero-extension), the leading zeros are removed from the shift amount,
//         simplifying the shift input.
//
//     *   **Removal of Shift Guards**: If a shift amount is clamped by a
//         `select` operation (e.g., `select(UGt(amt, LIMIT), {LIMIT, amt})`)
//         where `LIMIT` is greater than or equal to the bit width of the value
//         being shifted, the clamping logic is removed as it is redundant (any
//         shift amount beyond the bit width produces the same result).
//
// 3.  **Comparisons with Negated Operands**:
//
//     *   **`eq(-lhs, -rhs)` => `eq(lhs, rhs)`** (and similar for `ne`).
//
//     *   **Signed comparisons like `slt(-lhs, -rhs)`**: These are transformed
//         into an `xor` of the reversed comparison (`sgt(lhs, rhs)`) and
//         additional terms to correctly handle `MIN_VALUE` edge cases (where
//         `neg(MIN_VALUE) == MIN_VALUE`).
//
//     *   **Signed comparison of negation to literal `eq(-expr, K)`**: These
//         are transformed into `eq(expr, -K)`, with similar `xor` logic for
//         inequalities to correctly handle `MIN_VALUE`. These transformations
//         are only applied if the `negate` operation has no other users to
//         avoid introducing logic replication.
//
// 4.  **Multiply Operations**:
//
//     *   **Multiply by Power of Two**: `umul(x, 2^K)` or `smul(x, 2^K)` are
//         replaced with a left shift by `K` bits.
//
//     *   **Multiply by Small Constant (Sum-of-Shifts)**: `mul(x, K)` where
//         `K` is a small constant with a few set bits can be replaced by a sum
//         of shifted `x` values (e.g., `x * 5` => `x + (x << 2)`). This is
//         applied if the number of adders required is below a `kAdderLimit`. A
//         complementary optimization uses subtraction from a power-of-two shift
//         for constants like 7 (e.g., `x * 7` => `(x << 3) - x`).
//
//     *   **Zero-Width Multiply Operands**: Multiplies where one or both
//         operands have a zero bit width are replaced by a literal zero, as the
//         result will always be zero.
//
//     *   **Multiply used by Narrowing Slice**: If a multiply operation's
//         result is only used by `bit_slice` operations that extract a narrower
//         result, the multiply itself can be performed at the required output
//         width, reducing the size of the multiplier hardware.
//
// 5.  **Decode Operations**:
//
//     *   **1-bit Wide Decode**: A `decode` operation with a 1-bit output is
//         simplified to an `eq(index, 0)` comparison, as only the index 0 will
//         produce a true output.
//
//     *   **1-bit Operand Decode**: A `decode` operation with a 1-bit input and
//         a 2-bit output is simplified to `concat(operand, not(operand))`,
//         which is its direct one-hot representation.
//
//     *   **Removal of Zero-Extended Index**: Similar to shifts, if a decode
//         index is formed by a `concat` with leading zeros (zero-extension),
//         the leading zeros are removed from the index.
//
// 6.  **`decode(N) - 1` Pattern**: The common pattern for creating a mask with
//     the `N` least-significant bits set (e.g., `sub(decode(N), 1)`) is
//     rewritten to `not(shll(all_ones, N))`, eliminating an adder and often
//     resulting in more efficient hardware.
//
// 7.  **Comparison of Injective Operations**: The pass identifies patterns
//     where the result of an injective arithmetic operation (like `add` or
//     `sub`) is compared against a constant (e.g., `(X + C0) == C1`). These are
//     simplified by performing the inverse arithmetic operation on the
//     constants to isolate `X` (e.g., `X == C1 - C0`).
//
// The `ArithSimplificationPass` operates to a fixed point, meaning it
// repeatedly applies these simplifications until no further changes are
// possible. This iterative approach ensures that all possible arithmetic
// optimizations are applied, resulting in a more efficient and optimized IR for
// hardware synthesis.
class ArithSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "arith_simp";
  explicit ArithSimplificationPass()
      : OptimizationFunctionBasePass(kName, "Arithmetic Simplifications") {}
  ~ArithSimplificationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_ARITH_SIMPLIFICATION_PASS_H_
