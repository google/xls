// Copyright 2023 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_LABEL_RECOVERY_PASS_H_
#define XLS_PASSES_LABEL_RECOVERY_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// At the end of the pass pipeline (when inlining and optimizations have been
// performed) attempts to recover original names for coverpoints and assertions
// to whatever degree possible so they're more human-readable -- we mangle them
// for inlining to ensure they're unique, but often those names are way
// overqualified.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `LabelRecoveryPass` is an optimization pass in XLS designed to enhance
// the human-readability of labels associated with `cover` points and `assert`
// statements. These labels are crucial for debugging and formal verification.
// During earlier optimization stages, particularly `InliningPass`, these labels
// are deliberately mangled (e.g., by prepending caller function names and
// invocation IDs). This mangling ensures their uniqueness in the flattened IR,
// which is critical for generating correct Verilog. However, these mangled
// names can become excessively long and difficult for users to interpret.
//
// The primary purpose of `LabelRecoveryPass` is to revert these mangled labels
// back to their original, more concise, user-defined forms wherever possible,
// without reintroducing naming collisions that would break downstream tools.
//
// **How it Works**:
//
// 1.  **Collecting Original Labels**: The pass iterates through all nodes in
//     the function or proc. For each `cover` and `assert` node, it checks for
//     the presence of an `original_label` attribute. This attribute stores the
//     name that the user originally provided before any mangling occurred
//     during inlining.
//
// 2.  **Grouping by Original Label**: It constructs a map where the keys are
//     the `original_label` strings, and the values are lists of all `cover` or
//     `assert` nodes that share that specific `original_label`. This grouping
//     is essential for identifying potential naming collisions.
//
// 3.  **Collision Check and Recovery**: For each unique `original_label` found
//     in the map:
//     *   **No Collision**: If a particular `original_label` is associated with
//         only *one* `cover` or `assert` node in the entire function, it means
//         that no naming collision occurred (e.g., the original statement was
//         inlined only once, or it was already unique). In this safe scenario,
//         the pass restores the node's `label` attribute to its
//         `original_label`.
//
//     *   **Collision Present**: If an `original_label` is associated with
//         *multiple* `cover` or `assert` nodes, it signifies that inlining has
//         created multiple instances of what was originally a single, uniquely
//         named statement. In this case, the pass *does not* attempt to recover
//         the original label for these collided nodes. Their mangled names are
//         retained to ensure uniqueness and prevent errors in downstream tools
//         like Verilog generation.
//
// **Benefits**:
//
// *   **Improved Debuggability**: By restoring original labels, the generated
//     Verilog becomes significantly more understandable for hardware designers,
//     making it easier to pinpoint issues related to `cover` points and
//     `assert` statements during simulation and debugging.
//
// *   **Enhanced Readability**: Reduces the verbosity of the generated IR and
//     Verilog code, contributing to overall better readability.
//
// *   **Preserves Intent**: Ensures that the designer's original intent and
//     chosen naming convention for `cover` and `assert` labels are reflected in
//     the final output wherever possible.
//
// **Limitations (as noted in the code)**:
//
// *   The current implementation only recovers labels if there are no
//     collisions for a given original label. It does not attempt to find
//     minimal distinguishing prefixes or other sophisticated renaming schemes
//     for collided labels, although this is noted as a potential future
//     improvement.
//
// Example:
// Consider a `callee` function with a `cover` point that is invoked only once
// by a `caller` function:
//
//
// ```
// // Original IR
// package p
//
// fn callee(p: bits[1]) -> () {
//   ret cover.10: () = cover(p, label="my_cover_label")
// }
//
// top fn caller(p: bits[1]) -> () {
//   ret invoke.20: () = invoke(p, to_apply=callee)
// }
// ```
//
//
// After `InliningPass`, the `cover.10` in `callee` might be inlined into
// `caller` and its label mangled (e.g., to
// `"caller_0_callee_my_cover_label"`).
//
// The `LabelRecoveryPass` would then perform the following steps:
// 1.  It would locate the inlined `cover` node within the `caller` function.
//
// 2.  It would retrieve its `original_label`, which is `"my_cover_label"`.
//
// 3.  It would determine that no other `cover` or `assert` node in `caller`
//     shares the `original_label` `"my_cover_label"`.
//
// 4.  Consequently, it would restore the label of the inlined `cover` node to
//     `"my_cover_label"`.
//
//
// ```
// // Optimized IR (after InliningPass, DCEPass, and LabelRecoveryPass)
// package p
//
// top fn caller(p: bits[1]) -> () {
//   // Label recovered to original
//   ret cover.new: () = cover(p, label="my_cover_label")
// }
// ```
//
// If `callee` were invoked multiple times, leading to multiple `cover` nodes
// with the same `original_label` (e.g., in a loop), their labels would remain
// mangled to ensure uniqueness, as per the pass's collision avoidance strategy.
class LabelRecoveryPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "label-recovery";
  LabelRecoveryPass() : OptimizationFunctionBasePass(kName, "LabelRecovery") {}
  ~LabelRecoveryPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_LABEL_RECOVERY_PASS_H_
