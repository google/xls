// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Dead Code Elimination.
//
#ifndef XLS_PASSES_DCE_PASS_H_
#define XLS_PASSES_DCE_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// class DeadCodeEliminationPass iterates up from a functions result
// nodes and marks all visited node. After that, all unvisited nodes
// are considered dead.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `DeadCodeEliminationPass` (DCE) is a fundamental optimization pass in XLS
// that removes "dead" or "unreachable" code from the Intermediate
// Representation (IR). Dead code refers to any operation whose result is not
// used, either directly or indirectly, to produce the final output of a
// function or any side-effecting operation. By removing such code, DCE
// simplifies the IR graph, reduces the size of the generated hardware, and can
// improve the performance of subsequent optimization passes by reducing the
// amount of code they need to analyze.
//
// **How it Works**:
//
// The pass operates by identifying "live" code—operations that are essential
// for the computation—and then removing everything else. This is achieved
// through a simple and efficient graph traversal algorithm:
//
// 1.  **Identifying Live Roots**: The pass starts by identifying the initial
//     set of "live" nodes. These are nodes that are inherently live because
//     they represent the essential outputs or side effects of the function or
//     proc. This set includes:
//     *   The function's return value.
//
//     *   Any side-effecting operations (e.g., `assert`, `cover`, `trace`,
//         `send`).
//
//     *   Proc `next` state update nodes.
//
//     *   Nodes with implicit uses (e.g., output ports in a block).
//
// 2.  **Worklist-based Traversal**: A worklist is initialized with all nodes
//     that are initially considered dead (i.e., those with no users and which
//     are deletable). The pass then iteratively removes a node from the
//     worklist and, for each of its operands, checks if that operand has become
//     dead as a result. If so, the operand is added to the worklist.
//
// 3.  **Determining Deletability**: A node is considered "deletable" if it is
//     not a root and does not have any side effects. The pass includes a
//     specific `is_deletable` check which ensures that:
//     *   Nodes with implicit uses (like block ports) are not removed.
//
//     *   Most side-effecting operations (`assert`, `cover`, `trace`, `send`,
//         etc.) are not removed, as they are considered observable effects.
//         `gate` is a special-case that is considered removable.
//
//     *   `invoke` nodes are generally not removed by DCE. This is a
//         conservative approach, as the invoked function might have side
//         effects that are not immediately apparent. `InliningPass` is
//         responsible for handling the removal of `invoke` nodes.
//
// 4.  **Node Removal**: As the pass identifies dead nodes, it removes them from
//     the function's IR graph. This process continues until the worklist is
//     empty, at which point only live code remains.
//
// **Benefits**:
//
// *   **Reduced Hardware Size**: The most direct benefit is a reduction in the
//     amount of logic that needs to be synthesized, leading to smaller and more
//     area-efficient hardware.
//
// *   **Improved Performance**: By removing unnecessary computations, the pass
//     can sometimes shorten critical paths, leading to improved timing
//     performance.
//
// *   **Enhanced IR Quality**: A cleaner, more compact IR is easier for both
//     humans and subsequent optimization passes to analyze and transform, which
//     can lead to better overall optimization results.
//
// Example:
// Consider a function with several operations, some of which do not contribute
// to the final result:
//
//
// ```
// // Original IR snippet
// fn some_dead_code(x: bits[42], y: bits[42]) -> bits[42] {
//   neg.1: bits[42] = neg(x)
//   add.2: bits[42] = add(x, y)      // Dead: not used by any live node
//   neg.3: bits[42] = neg(add.2)     // Dead: only user is also dead
//   ret sub.4: bits[42] = sub(neg.1, y)
// }
// ```
//
//
// The `DeadCodeEliminationPass` would perform the following steps:
// 1.  Start with the live root, `sub.4` (the function's return value).
//
// 2.  The live set becomes `{sub.4, neg.1, y}`. `x` is also live since its
//     used by `neg.1`.
//
// 3.  Nodes `add.2` and `neg.3` are identified as having no users that are in
//     the live set. Since they have no other users and are not side-effecting,
//     they are considered dead.
//
// 4.  The pass removes `add.2` and `neg.3` from the graph.
//
// The final, optimized IR would be:
//
//
// ```
// // Optimized IR (after DCE)
// fn some_dead_code(x: bits[42], y: bits[42]) -> bits[42] {
//   neg.1: bits[42] = neg(x)
//   ret sub.4: bits[42] = sub(neg.1, y)
// }
// ```
//
// The pass has successfully eliminated the unused `add` and `neg` operations,
// resulting in a more efficient implementation.
class DeadCodeEliminationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "dce";
  DeadCodeEliminationPass()
      : OptimizationFunctionBasePass(kName, "Dead Code Elimination") {}
  ~DeadCodeEliminationPass() override = default;

 protected:
  // Iterate all nodes, mark and eliminate the unvisited nodes.
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_DCE_PASS_H_
