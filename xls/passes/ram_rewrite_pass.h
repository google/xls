// Copyright 2023 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_RAM_REWRITE_PASS_H_
#define XLS_PASSES_RAM_REWRITE_PASS_H_

#include <cstdint>
#include <optional>
#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/channel.h"
#include "xls/ir/package.h"
#include "xls/ir/type.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Each kind of ram has logical names for each port. Internally, these are
// represented as these enums.
enum class RamLogicalChannel {
  // Abstract RAM
  kAbstractReadReq,
  kAbstractReadResp,
  kAbstractWriteReq,
  // 1RW RAM
  k1RWReq,
  k1RWResp,
  // 1R1W RAM
  k1R1WReadReq,
  k1R1WReadResp,
  k1R1WWriteReq,

  // Special: used to signal write completion, is empty and should not be
  // codegen'd as a real channel.
  kWriteCompletion,
};

absl::StatusOr<RamLogicalChannel> RamLogicalChannelFromName(
    std::string_view name);
std::string_view RamLogicalChannelName(RamLogicalChannel logical_channel);

ChannelDirection GetRamLogicalChannelDirection(
    RamLogicalChannel logical_channel);

// If mask_width is defined, return bits[mask_width]. Otherwise, there are no
// masks, which we represent with an empty tuple. The empty tuple will be
// removed in codegen.
Type* GetMaskType(Package* package, std::optional<int64_t> mask_width);

// Pass that rewrites RAMs of one type to a new type. Generally this will be
// some kind of lowering from more abstract to concrete RAMs.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `RamRewritePass` facilitates the transformation of RAM (Random Access
// Memory) interfaces within an XLS package. Its primary role is to lower more
// abstract RAM models to concrete RAM types that are directly implementable by
// target hardware. This is a crucial step in the hardware generation flow.
//
// The pass is driven by `RamRewrite` configurations, which specify the original
// RAM type (`from_config`), the target RAM type (`to_config`), and the mapping
// between logical channel names (e.g., `read_req`) and their corresponding
// physical channel names in the IR.
//
// Key aspects of the `RamRewritePass` include:
//
// 1.  **RAM Abstraction Levels**:
//     *   **`kAbstract`**: A high-level, generic RAM model that provides a
//         simplified interface.
//     *   **`k1RW` (One Read/Write Port)**: A concrete RAM with a single port
//         that can perform either a read or a write operation per cycle. Its
//         request channel typically includes address, data, write enable, and
//         read enable signals bundled together.
//     *   **`k1R1W` (One Read, One Write Port)**: A concrete RAM with separate,
//         independent read and write ports, enabling simultaneous read and
//         write operations.
//
// 2.  **Channel Rewiring and Repacking**:
//     The core function of the pass is to replace existing `send` and `receive`
//     operations associated with the `from_config` RAM channels with new `send`
//     and `receive` operations connected to the `to_config` RAM channels. This
//     often necessitates "repacking" the data payloads to match the new channel
//     types.
//
//     *   **Repacking for `send` operations**: The `RepackPayload` function
//         transforms the structure of an old `send` operation's operand to
//         match the expected input format of the new RAM channel. This can
//         involve adding literal values (e.g., `write_enable` or `read_enable`
//         bits for `k1RW` RAMs), dropping unused fields, or simply passing
//         through data if the formats are compatible.
//
//         Example (Abstract Read Request to 1RW Request):
//         An abstract read request might be a tuple `(address, mask)`. When
//         rewritten to a `k1RW` RAM, its request channel expects `(address,
//         data, write_mask, read_mask, write_enable, read_enable)`. The pass
//         will construct a new tuple, filling `data`, `write_mask` with zero
//         literals, setting `write_enable` to `0b0` and `read_enable` to `0b1`.
//
//         ```
//         // Original abstract read request send
//         send_abstract_read_req: token = send(tok,
//                                              (addr, mask),
//                                              channel=abstract_read_req)
//
//         // Transformed 1RW request send (simplified)
//         send_1rw_req: token =
//                       send(tok,
//                            (addr, data, wmask, mask, we, re),
//                            channel=1rw_req)
//         ```
//
//
//     *   **Repacking for `receive` operations**: Similarly, the output of the
//         new `receive` operation (which adheres to the `to_config` channel
//         type) is repacked to conform to the expected output format of the
//         original `from_config` channel. This ensures that downstream logic
//         that consumes the received data continues to function correctly.
//
// 3.  **Channel Creation and Removal**: The pass dynamically creates new
//     channels that correspond to the `to_config` RAM type and subsequently
//     removes the original channels associated with the `from_config` RAM type.
//     This ensures a clean transition to the new RAM interface.
//
// 4.  **Proc-Scoped Channels**: The pass properly handles both global and
//     proc-scoped channels. If a `proc_name` is specified in the `RamRewrite`
//     configuration, the channels are treated as local to that particular proc.
//
// 5.  **Error Handling**: The pass includes robust checks for potential issues
//     such as type mismatches (e.g., inconsistencies in address width between
//     `from_config` and `to_config`) and unsupported transformation scenarios,
//     returning informative errors where applicable.
//
// This pass is a critical element in the XLS compilation flow, enabling the
// compiler to generate optimized hardware for diverse RAM architectures while
// preserving the functional correctness of the original design.
class RamRewritePass : public OptimizationPass {
 public:
  static constexpr std::string_view kName = "ram_rewrite";
  explicit RamRewritePass() : OptimizationPass(kName, "RAM Rewrite") {}

  ~RamRewritePass() override = default;

 protected:
  absl::StatusOr<bool> RunInternal(Package* p,
                                   const OptimizationPassOptions& options,
                                   PassResults* results,
                                   OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_RAM_REWRITE_PASS_H_
