// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_SELECT_LIFTING_PASS_H_
#define XLS_PASSES_SELECT_LIFTING_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which replace the pattern
//   v = sel (c, array[i], array[j], ...)
// where all cases of the select reference the same array, to the code
//   z = sel (c, i, j, ...)
//   v = array[z]
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `SelectLiftingPass` is an optimization pass in XLS that restructures
// `select` and `priority_select` operations to improve hardware efficiency.
// It identifies scenarios where a `select`'s cases are all derived from a
// common "shared" operation (such as an `array_index` or a binary arithmetic
// operation) and "lifts" that shared operation out of the `select`. This
// transformation effectively moves the multiplexing (the `select`) from the
// *output* of the shared operation to its *input*, which often leads to
// significant hardware savings and can sometimes improve performance.
//
// This pass is particularly effective in two main scenarios:
//
// 1.  **Lifting `ArrayIndex` Operations**:
//     When all cases of a `select` are `array_index` operations on the *same
//     array*, the pass can lift the `array_index` out of the `select`. It
//     creates a new `select` that chooses between the *indices* of the original
//     `array_index` operations. The result of this new `select` (the chosen
//     index) is then used in a single, shared `array_index` operation. This
//     replaces multiple array reads followed by a wide data multiplexer with a
//     smaller index multiplexer followed by a single array read, which is
//     generally much more area-efficient.
//
//
//     ```
//     // Original IR snippet
//     v = sel(c, array[i], array[j])
//
//     // Optimized IR (after lifting)
//     z = sel(c, i, j)
//     v = array[z]
//     ```
//
//
// 2.  **Lifting Binary Operations**:
//     When all cases of a `select` are binary operations of the same kind
//     (e.g., all `add`s, `sub`s, or `mul`s) and share one common operand, the
//     binary operation can be lifted out of the `select`. A new `select` is
//     created to choose between the "other" (non-shared) operands. The result
//     of this new `select` is then used in a single, shared binary operation
//     with the common operand.
//
//
//     ```
//     // Original IR snippet
//     v = sel(c, x + a, x + b)
//
//     // Optimized IR (after lifting)
//     z = sel(c, a, b)
//     v = x + z
//     ```
//
//
// **Profitability and Applicability Guards**:
//
// The pass includes several "guards" to ensure that the transformation is both
// applicable and profitable:
//
// *   **`CanLiftSelect`**: This function checks if a `select` is a candidate
//     for lifting. For `ArrayIndex` lifting, it verifies that all cases are
//     indeed `array_index` operations on the same array and that their index
//     types are compatible. For binary operation lifting, it identifies a
//     common `shared_node` across all cases and ensures the operation type is
//     consistent and supported (e.g., `add`, `sub`, `and`, `or`, `mul`,
//     shifts). It also handles "identity" cases, where one of the `select`'s
//     cases is the shared operand itself.
//
// *   **`ShouldLiftSelect`**: This function determines if a liftable `select`
//     should actually be transformed, based on profitability heuristics:
//     *   **Area Estimation**: For binary operations, it performs a simple
//         cost-benefit analysis based on the bit-widths of the original and
//         transformed operations. The transformation is generally considered
//         profitable if the total bit-width of the new, narrower `select` and
//         the shared operation is less than or equal to the total bit-width of
//         the original `select` and all the individual binary operations (if
//         they were single-use).
//     *   **Delay Estimation**: If a `delay_model` is provided, the pass uses
//         `CriticalPathDelayAnalysis` to estimate the impact of the
//         transformation on the critical path. Lifting is avoided if it is
//         predicted to increase the latency. This is particularly important for
//         scenarios like converting multiple constant-shifts into a single
//         variable-shift, which is often more expensive in hardware.
//     *   **Heuristics for High-Latency Operations**: For high-latency
//         operations like multiplication, lifting is more cautiously applied,
//         especially if it involves identity cases, to avoid potentially
//         degrading performance.
//
// **How it Works**:
//
// 1.  **Worklist-based Iteration**: The pass maintains a worklist of `select`
//     and `priority_select` nodes that are candidates for optimization. It
//     iterates through this worklist, applying transformations until no more
//     profitable lifting opportunities can be found.
//
// 2.  **Applicability and Profitability Checks**: For each `select` in the
//     worklist, it calls `CanLiftSelect` and then `ShouldLiftSelect` to
//     determine if a valid and beneficial transformation exists.
//
// 3.  **IR Transformation**: If a transformation is approved:
//     *   **`LiftSelectForArrayIndex`**: Rewires the IR for `array_index`
//         lifting by creating a new `select` for the indices and a new shared
//         `array_index`.
//     *   **`LiftSelectForBinaryOperation`**: Rewires the IR for binary
//         operation lifting by creating a new `select` for the non-shared
//         operands and a new shared binary operation. It correctly handles
//         identity cases by inserting the appropriate identity literal (e.g.,
//         `0` for `add`, `-1` for `and`) into the new `select`.
//
// 4.  **Cleanup**: The original `select` node, now redundant, is marked for
//     deletion, which is typically handled by a subsequent
//     `DeadCodeEliminationPass`. Any new `select` nodes created during the
//     transformation are added to the worklist, allowing for potential further
//     optimizations.
//
// By systematically applying these transformations, `SelectLiftingPass` plays a
// crucial role in optimizing multiplexer-heavy designs, leading to more
// efficient use of hardware resources and improved overall performance.
class SelectLiftingPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "select_lifting";

  explicit SelectLiftingPass()
      : OptimizationFunctionBasePass(kName, "Select Lifting") {}

  ~SelectLiftingPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_SELECT_LIFTING_PASS_H_
