// Copyright 2022 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_SPARSIFY_SELECT_PASS_H_
#define XLS_PASSES_SPARSIFY_SELECT_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// The SparsifySelectPass is a type of range analysis-informed dead code
// elimination that removes cases from selects when range analysis proves that
// they can never occur. It does this by splitting a select into many selects,
// each of which covers a single interval from the selector interval set.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `SparsifySelectPass` is an optimization pass that utilizes range analysis
// to perform a specialized form of dead code elimination on `select`
// operations. Its core function is to identify and remove or simplify cases
// within a `select` instruction that are provably unreachable based on the
// possible range of values its selector can take. This leads to reduced
// hardware complexity and improved efficiency.
//
// Here's a detailed breakdown of its operation:
//
// 1.  **Range Analysis**: The pass begins by employing a
//     `PartialInfoQueryEngine` to perform a precise range analysis on the
//     `selector` operand of each `select` operation. This analysis determines
//     the `IntervalSet` – the complete set of possible values – that the
//     `selector` can attain during execution.
//
// 2.  **Identification of Dead Cases**: If the `IntervalSet` of the `selector`
//     reveals that it can only take on a subset of all possible values (i.e.,
//     the size of the `IntervalSet` is less than the total number of cases in
//     the `select`), then certain cases of the `select` are deemed unreachable
//     or "dead code."
//
// 3.  **Transformation into a Chain of Selects**: The primary transformation
//     involves replacing the original `select` operation with a new,
//     potentially nested, structure composed of multiple `select` operations.
//     Each new `select` in this chain is meticulously designed to cover a
//     specific `Interval` from the `selector_intervals`.
//
//     *   The helper function `IntervalsSortedBySize` sorts the reachable
//         intervals by their size (number of points covered), typically
//         processing smaller intervals first. This heuristic aims to produce a
//         more compact or efficient `select` decision tree.
//     *   For each `Interval`, a new `select` is constructed. This `select`
//         first determines if the value of the original `selector` falls
//         within the bounds of the current `Interval` using comparison
//         operations.
//     *   If the `selector` is found to be within the `Interval`, a nested
//         `select` (or a direct reference to the corresponding case value if
//         the interval is a single precise value) is used to choose among the
//         relevant cases of the original `select` that correspond to values
//         within this `Interval`.
//     *   If the `selector` is *not* within the current `Interval`, control
//         flows to the "next" `select` in the chain. If it's the last interval
//         being considered, it defaults to a zero value (or the original
//         default value of the select, if one exists).
//
//     The net result is a decision tree that efficiently evaluates only the
//     cases that are genuinely reachable given the `selector`'s known range.
//
// Example:
// Consider a `select` operation where the selector `add.3` is a `bits[4]`
// type. Although `bits[4]` can represent 16 values (0-15), range analysis
// might prove
// that `add.3` can only ever take on values within the interval `[8, 11]`.
// The original `select` has 16 cases, one for each possible value from 0 to 15.
//
//
// ```
// // Original IR snippet
// fn func(x: bits[2]) -> bits[4] {
//   zero_ext.1: bits[4] = zero_ext(x, new_bit_count=4)
//   literal.2: bits[4] = literal(value=8)
//   // This is the selector for sel.20
//   add.3: bits[4] = add(zero_ext.1, literal.2)
//   // ... many literals for the 16 cases (literal.4 through literal.19)
//   ret sel.20: bits[4] = sel(add.3, cases=[
//     literal.4, literal.5, literal.6, literal.7, literal.8, literal.9,
//     literal.10, literal.11, literal.12, literal.13, literal.14,
//     literal.15, literal.16, literal.17, literal.18, literal.19
//   ])
// }
// ```
//
//
// The `SparsifySelectPass` will recognize that only selector values 8, 9, 10,
// and 11 are possible. It will then rewrite `sel.20` into a nested structure
// that effectively covers only these reachable cases:
//
//
// ```
// // Optimized IR snippet (simplified conceptual representation)
// fn func(x: bits[2]) -> bits[4] {
//   // ... zero_ext.1, literal.2, add.3 remain as before
//   selector_val: bits[4] = add.3 // The original selector value
//
//   ret main_select: bits[4] = sel(
//       // Check if selector_val is in [8, 11]
//       and(uge(selector_val, literal(8)), ule(selector_val, literal(11))),
//       cases=[
//           // If in range [8, 11], dispatch to a select that handles these
//           // specific values
//           sel(sub(selector_val, literal(8)), cases=[
//               literal(8),  // for selector_val == 8
//               literal(9),  // for selector_val == 9
//               literal(10), // for selector_val == 10
//               literal(11)  // for selector_val == 11
//           ]),
//           // If not in range, default to 0 (or the original select's default
//           // if it had one)
//           literal(0)
//       ]
//   )
// }
// ```
//
// This transformation significantly reduces the logic required in the hardware
// for the `select` operation by eliminating the evaluation of impossible
// conditions, thereby contributing to smaller and faster hardware designs.
class SparsifySelectPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "sparsify_select";
  SparsifySelectPass()
      : OptimizationFunctionBasePass(kName, "Sparsify Select") {}
  ~SparsifySelectPass() override = default;

 protected:
  // Sparsify selects using range analysis.
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_SPARSIFY_SELECT_PASS_H_
