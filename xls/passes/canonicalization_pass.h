// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// IR Canonicalization.

#ifndef XLS_PASSES_CANONICALIZATION_PASS_H_
#define XLS_PASSES_CANONICALIZATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// IR Canonicalization.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `CanonicalizationPass` performs various transformations to bring the IR
// into a standardized, canonical form. This simplifies subsequent optimization
// passes by ensuring consistent patterns for common operations. By having a
// predictable structure, other passes can focus on more complex logical
// transformations without needing to handle numerous syntactic variations of
// the same underlying operation.
//
// Key canonicalizations include:
//
// 1.  **Ordering of Literals in Commutative/Comparison Operations**: For
//     commutative operations (like `add`, `mul`, `and`, `or`, `xor`) and
//     comparison operations, literals are consistently moved to the right-hand
//     side. This means an expression like `add(constant, x)` becomes
//     `add(x, constant)`. For comparisons, `ult(constant, x)` becomes
//     `ugt(x, constant)`.
//
//     Example:
//
//     ```
//     one:bits[2] = literal(value=1)
//     ret addval: bits[2] = add(one, x)
//     ```
//
//     becomes:
//
//     ```
//     ret addval: bits[2] = add(x, one)
//     ```
//
//
// 2.  **Conversion of Subtraction to Addition with Negation**:
//     `sub(x, literal)` is transformed into `add(x, negate(literal))`.
//
//     Example:
//
//     ```
//     one:bits[2] = literal(value=1)
//     ret subval: bits[2] = sub(x, one)
//     ```
//
//     becomes (assuming a 2-bit unsigned system where -1 is 3):
//
//     ```
//     ret addval: bits[2] = add(x, literal(value=3))
//     ```
//
//
// 3.  **Removal of No-op Zero-extends**: If a `zero_ext` operation extends to
//     the same bit width as its operand, it's a no-op and is removed.
//
//     Example:
//
//     ```
//     zero_ext: bits[16] = zero_ext(x, new_bit_count=16)
//     ```
//
//     becomes:
//
//     ```
//     x
//     ```
//
//
// 4.  **Replacement of Zero-extend with Concat**: A `zero_ext` operation is
//     replaced by a `concat` operation with a zero literal to explicitly show
//     the bit extension.
//
//     Example:
//
//     ```
//     zero_ext: bits[42] = zero_ext(x: bits[33], new_bit_count=42)
//     ```
//
//     becomes:
//
//     ```
//     concat: bits[42] = concat(literal(0, bits=9), x)
//     ```
//
//
// 5.  **Removal of Useless Bitwise Reductions**: Bitwise reductions
//     (`and_reduce`, `or_reduce`, `xor_reduce`) on single-bit operands are
//     replaced by the operand itself.
//
//     Example:
//
//     ```
//     and_reduce.1: bits[1] = and_reduce(x: bits[1])
//     ```
//
//     becomes:
//
//     ```
//     x
//     ```
//
//
// 6.  **Canonicalization of Clamp Operations**: Various forms of clamping
//     operations (min/max) implemented with `select` and comparison operations
//     are canonicalized to a consistent `select` form.
//
// 7.  **Inversion of Selector for Select Operations**: If a 2-way `select` has
//     a `not` operation as its selector, the `not` is removed and the cases are
//     swapped.
//
//     Example:
//
//     ```
//     not.1: bits[1] = not(p)
//     ret sel.2: bits[8] = sel(not.1, cases=[x, y])
//     ```
//
//     becomes:
//
//     ```
//     ret sel.2: bits[8] = sel(p, cases=[y, x])
//     ```
//
//
// 8.  **Simplification of Select with Full Case Coverage**: A `select`
//     operation with a `default` value is transformed into a `select` without a
//     `default` if the number of `cases` plus the `default` covers all possible
//     selector values.
//
// 9.  **Simplification of Next/StateRead Predicates**: For `next_value` and
//     `state_read` operations, predicates that are always `true` are removed,
//     making the operation unconditional. If a `next_value` predicate is
//     always `false`, the `next_value` is removed.
//
// These canonicalizations aim to simplify the graph, make patterns more
// recognizable for other passes, and improve the overall efficiency of
// downstream optimizations.
class CanonicalizationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "canon";
  explicit CanonicalizationPass()
      : OptimizationFunctionBasePass(kName, "Canonicalization") {}
  ~CanonicalizationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_CANONICALIZATION_PASS_H_
