// Copyright 2022 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_PROC_STATE_OPTIMIZATION_PASS_H_
#define XLS_PASSES_PROC_STATE_OPTIMIZATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/proc.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which tries to minimize the size and total number of elements of the
// proc state. The optimizations include removal of dead state elements and
// zero-width elements.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ProcStateOptimizationPass` is an optimization pass in XLS that focuses
// on minimizing the size and total number of state elements within a Proc.
// This is a critical optimization for hardware generation, as fewer and smaller
// state elements directly translate to reduced register count and memory usage,
// leading to more compact, faster, and more efficient hardware designs.
//
// The pass achieves its goals through several key transformations, often
// operating in an iterative fashion until no further improvements are possible:
//
// 1.  **Removal of Zero-Width State Elements**:
//     State elements that have a bit width of zero (and are not token-typed)
//     are inherently useless as they cannot store any information. This pass
//     identifies and removes such elements. Their corresponding `StateRead`
//     operations are replaced with their `initial_value` (which will be a
//     zero-width literal tuple), and `Next` operations are replaced with empty
//     tuples.
//
// 2.  **Removal of Constant State Elements**:
//     If a state element's value is provably constant throughout the entire
//     execution of the Proc (i.e., its `initial_value` is a constant, and all
//     its `next_value` operations consistently assign that same constant value
//     or are no-ops), then the state element is redundant. The pass replaces
//     all reads of such a state element with its constant value and removes the
//     element and its associated `Next` operations. This process is run to a
//     fixed point, meaning it will iterate until no more constant state
//     elements can be found.
//
// 3.  **Removal of Unobservable State Elements**:
//     This is a more advanced optimization that identifies state elements whose
//     values do not affect any observable output of the Proc (e.g., outputs to
//     channels, assertions, traces). A state element `X` is considered
//     observable if:
//     *   A side-effecting operation (e.g., `send`, `assert`, `cover`) directly
//         or indirectly depends on `X`.
//     *   The next-state value of another *observable* state element depends on
//         `X`.
//
//     To achieve this, the pass performs:
//     *   **State Dependency Analysis**: It computes a dependency map showing
//         which state elements each node in the Proc depends upon. This is a
//         forward dataflow analysis.
//     *   **Transitive Closure**: It constructs an adjacency matrix for state
//         element dependencies and then computes its transitive closure. This
//         determines which state elements ultimately influence which others,
//         and importantly, which ones influence observable outputs.
//     *   **Removal**: Any state element that does not transitively affect an
//         observable output is deemed unobservable and removed. Reads of such
//         elements are replaced with a zero-valued literal, and their `Next`
//         operations are removed.
//
// 4.  **Conversion of Constant Chains to State Machines**:
//     This optimization identifies sequences of state elements that effectively
//     form a counter or a simple state machine driven by a constant input. For
//     example, if `next[C[i+1]]` is semantically equivalent to
//     `state_read[C[i]]` and `next[C[0]]` is a constant, this sequence can be
//     converted into a single, compact state machine. Instead of using a
//     one-hot encoding (which `ProcStateArrayFlatteningPass` might produce),
//     this pass converts it into a binary-encoded state machine using
//     `log2(chain_length)` bits, which is more area-efficient. The reads of
//     the original state elements are then replaced by a `select` operation
//     that decodes the state machine's value to produce the corresponding
//     original state element value.
//
// **Benefits**:
//
// *   **Area Reduction**: Directly reduces the number of registers and memory
//     required for state, leading to smaller hardware footprints.
// *   **Power Reduction**: Fewer registers and less active logic contribute to
//     lower power consumption in the synthesized design.
// *   **IR Simplification**: Removes redundant state and associated logic,
//     making the IR cleaner and easier for subsequent compilation stages to
//     process.
//
// Example (Removing a constant state element):
//
//
// ```
// // Original IR snippet
// package my_package
//
// chan out(bits[32], kind=streaming, ops=send_only, flow_control=ready_valid)
//
// top proc my_proc() {
//   tkn: token = literal(value=token)
//   zero_val: bits[32] = literal(value=0)
//   one_val: bits[32] = literal(value=1)
//
//   // This state element `constant_state` is always `1`
//   constant_state: bits[32] = state_element(init=1)
//   next (constant_state, one_val) // Always updates to 1
//
//   // `not_constant_state` changes based on its LSB
//   not_constant_state: bits[32] = state_element(init=0)
//   not_constant_state_read: bits[32] = state_read(not_constant_state)
//   not_constant_lsb: bits[1] =
//       bit_slice(not_constant_state_read, start=0, width=1)
//   not_constant_next_lsb: bits[1] = not(not_constant_lsb)
//   next_not_constant_state: bits[32] =
//       concat(bit_slice(not_constant_state_read, start=1, width=31),
//              not_constant_next_lsb)
//   next (not_constant_state, next_not_constant_state)
//
//   // Usage: sum of constant_state and the LSB of not_constant_state
//   state_usage: bits[32] = add(state_read(constant_state),
//                               bit_slice(state_read(not_constant_state),
//                                         start=0, width=1))
//   send_tok: token = send(tkn, state_usage, channel=out)
//   next (send_tok)
// }
// ```
//
//
// The `ProcStateOptimizationPass` would identify `constant_state` as provably
// constant (always `1`). It would then replace all uses of
// `state_read(constant_state)` with `literal(1)` and remove the
// `constant_state` element and its `next_value`:
//
//
// ```
// // Optimized IR (simplified after ProcStateOptimizationPass and a subsequent
// // DCE pass)
// package my_package
//
// chan out(bits[32], id=0, kind=streaming, ops=send_only,
//          flow_control=ready_valid)
//
// top proc my_proc() {
//   tkn: token = literal(value=token)
//   zero_val: bits[32] = literal(value=0)
//   one_val: bits[32] = literal(value=1)
//
//   // `constant_state` has been removed by the pass
//
//   not_constant_state: bits[32] = state_element(init=0)
//   not_constant_state_read: bits[32] = state_read(not_constant_state)
//   not_constant_lsb: bits[1] = bit_slice(not_constant_state_read, start=0,
//                                          width=1)
//   not_constant_next_lsb: bits[1] = not(not_constant_lsb)
//   next_not_constant_state: bits[32] =
//     concat(bit_slice(not_constant_state_read, start=1, width=31),
//            not_constant_next_lsb)
//   next (not_constant_state, next_not_constant_state)
//
//   // `state_read(constant_state)` is replaced by `literal(1)`
//   state_usage: bits[32] = add(literal(1, bits=32),
//                               bit_slice(state_read(not_constant_state),
//                                         start=0, width=1))
//   send_tok: token = send(tkn, state_usage, channel=out)
//   next (send_tok)
// }
// ```
//
// This effectively reduces the number of state elements and simplifies the
// logic by replacing constant state accesses with their known values.
class ProcStateOptimizationPass : public OptimizationProcPass {
 public:
  static constexpr std::string_view kName = "proc_state_opt";
  ProcStateOptimizationPass()
      : OptimizationProcPass(kName, "Proc State Optimization") {}
  ~ProcStateOptimizationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnProcInternal(
      Proc* proc, const OptimizationPassOptions& options, PassResults* results,
      OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_PROC_STATE_OPTIMIZATION_PASS_H_
