// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_BOOLEAN_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_BOOLEAN_SIMPLIFICATION_PASS_H_

#include <cstdint>
#include <optional>
#include <string_view>

#include "absl/status/statusor.h"
#include "absl/types/span.h"
#include "xls/ir/bits.h"
#include "xls/ir/function_base.h"
#include "xls/ir/node.h"
#include "xls/ir/op.h"
#include "xls/ir/source_location.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {
namespace internal {

// Exposed in the header for testing.
class TruthTable {
 public:
  // xyz_present and xyz_negated must be bit_count == 3 for each of the operands
  // on the input frontier (see .cc file for details). A value like xyz_present
  // == 0b100 indicates 'x' is present, 0b011 indicates 'y' and 'z' are present,
  // etc.
  TruthTable(const Bits& xyz_present, const Bits& xyz_negated,
             std::optional<Op> logical_op);

  // Computes the result vector for this operation, as specified in the
  // constructor.
  Bits ComputeTruthTable() const;

  bool MatchesVector(const Bits& table) const;

  // Returns whether the original node matches this logical function with the
  // given operands (note all logical operations we express in this way are
  // symmetrical with respect to permutations in the input operands).
  bool MatchesSymmetrical(Node* original,
                          absl::Span<const Node* const> operands) const;

  // Creates a replacement node to use in lieu of the original that corresponds
  // to this truth table with the given input frontier operands.
  absl::StatusOr<Node*> CreateReplacement(const SourceInfo& original_loc,
                                          absl::Span<Node* const> operands,
                                          FunctionBase* f) const;

  // Gets the truth table (input) vector for operand "i".
  static Bits GetInitialVector(int64_t i);
  static Bits RunNaryOp(Op op, absl::Span<const Bits> operands);

 private:
  Bits xyz_present_;
  Bits xyz_negated_;
  std::optional<Op> logical_op_;
};

}  // namespace internal

// Attempts to simplify bitwise / boolean expressions (e.g. of multiple
// variables).
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `BooleanSimplificationPass` focuses on optimizing logical expressions
// within the IR. It achieves this by analyzing the truth table generated from
// a local cluster of Boolean operations and replacing them with a simpler,
// logically equivalent expression. This is particularly effective for reducing
// complex combinations of `and`, `or`, `not`, `nand`, `nor`, and `xor`
// operations into more fundamental and efficient forms.
//
// The core mechanism involves:
//
// 1.  **Truth Table Generation**: For a given Boolean expression, the pass
//     traces its inputs up to a small, manageable set of "frontier" nodes
//     (typically parameters or results of non-Boolean operations). It then
//     conceptually "flows" all possible combinations of true/false values from
//     these frontier nodes through the intermediate Boolean operations to
//     determine the resulting truth table of the entire expression. This is
//     currently performed for up to 3 frontier nodes (X, Y, Z), resulting in an
//     8-bit truth table.
//
//     Example (conceptual truth table for inputs X, Y, Z):
//
//     ```
//     X: 00001111   // Represents the value of X for all 8 input combinations
//     Y: 00110011   // Represents the value of Y for all 8 input combinations
//     Z: 01010101   // Represents the value of Z for all 8 input combinations
//     // ... The pass computes the output bit vector based on the logic of the
//     //     expression e.g., for `and(X, Y)`, the result would be `00000001`
//     ```
//
//
// 2.  **Truth Table Matching and Replacement**: The computed N-bit truth table
//     is then compared against a pre-computed set of canonical truth tables for
//     various simple Boolean operations (e.g., `and`, `or`, `not`, `nand`). If
//     a match is found and the canonical replacement is simpler (based on a
//     cost heuristic), the original complex Boolean expression is replaced by
//     this simpler form. This can also detect expressions that are always
//     `true` or always `false` and replace them with literal values.
//
//     Example (original expression involving `not` and `and`):
//
//     ```
//     fn f(x: bits[42], y: bits[42]) -> bits[42] {
//       and_op: bits[42] = and(x, y)
//       ret not_op: bits[42] = not(and_op)
//     }
//     ```
//     After `BooleanSimplificationPass`, this could be transformed into:
//
//     ```
//     fn f(x: bits[42], y: bits[42]) -> bits[42] {
//       ret nand_op: bits[42] = nand(x, y)
//     }
//     ```
//
//
// 3.  **Handling of Redundancy and Symmetry**: The pass incorporates knowledge
//     of Boolean algebra rules, including symmetric properties of operations
//     (e.g., `and(A, B)` is equivalent to `and(B, A)`) and the identification
//     of redundant inputs (e.g., in `and(X, X, Y)`, one `X` is redundant).
//
// This pass is fundamental for logic optimization, as it can significantly
// reduce the complexity of Boolean logic, leading to more compact and faster
// hardware implementations.
class BooleanSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "bool_simp";
  BooleanSimplificationPass()
      : OptimizationFunctionBasePass(kName, "boolean simplification") {}

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_BOOLEAN_SIMPLIFICATION_PASS_H_
