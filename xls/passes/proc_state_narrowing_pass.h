// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_PROC_STATE_NARROWING_PASS_H_
#define XLS_PASSES_PROC_STATE_NARROWING_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/proc.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which tries to minimize the size and total number of elements of the
// proc state. The optimizations include removal of dead state elements and
// zero-width elements.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ProcStateNarrowingPass` is an optimization pass designed to reduce the
// bit width of `bits`-typed state elements within a Proc. This is a critical
// optimization for hardware generation, as a smaller bit width for state
// elements directly translates to smaller and more efficient registers in the
// synthesized hardware. The pass achieves this by employing a
// `ProcStateRangeQueryEngine` to analyze the possible range of values a state
// element can take over multiple cycles, and then safely narrows its bit width
// if a smaller range is identified.
//
// The pass focuses on two primary types of bit width reduction:
//
// 1.  **Removal of Known Leading Bits (Zero or One Extension)**:
//     If range analysis can prove that the most significant bits (MSBs) of a
//     state element are always constant (e.g., always zero or always one),
//     these leading redundant bits can be "removed." The state element's type
//     is then truncated to exclude these bits. When the state is read, these
//     bits are re-concatenated as literals to reconstruct the full width for
//     any operations that depend on the original wider value. When a
//     `next_value` is computed, only the non-constant lower bits are extracted.
//
//     Example: If a 32-bit state element `foo` is always updated such that its
//     29 MSBs are consistently zero, the pass can narrow its type to `bits[3]`.
//
//
//     ```
//     // Original state element
//     state_element(foo, bits[32], init=0)
//
//     // Example next_value (simplified, assuming MSBs are always 0)
//     next_value(foo, zero_extend(add(literal(1, bits=3),
//     bit_slice(state_read(foo), 0, 3)), 32))
//     ```
//
//     After narrowing, `foo` might become `bits[3]`:
//
//     ```
//     // Narrowed state element
//     state_element(foo, bits[3], init=0)
//
//     // Read of foo now re-extends it for compatibility
//     extended_foo: bits[32] = concat(literal(0, bits=29), state_read(foo))
//
//     // Next value is computed on the narrowed bits
//     next_value(foo, bit_slice(new_value_for_foo, 0, 3))
//     ```
//
//
// 2.  **Signed Bit Width Narrowing**:
//     For state elements representing signed values, the pass utilizes interval
//     analysis (`interval_ops::MinimumSignedBitCount`) to determine the
//     smallest number of bits strictly necessary to represent the full range of
//     signed values a state element can take. If the actual bit width is larger
//     than this minimum, it is narrowed. To preserve signed semantics, the pass
//     uses `sign_ext` to reconstruct the original width when the state element
//     is read.
//
//     Example: If a 32-bit state element `bar` is known to consistently hold
//     signed values between -8 and 7, it can be narrowed to `bits[4]` (as 4
//     bits can represent signed values from -8 to 7).
//
//
//     ```
//     // Original state element
//     state_element(bar, bits[32], init=0)
//
//     // Example next_value (simplified, range stays within [-8, 7])
//     next_value(bar, add(state_read(bar), literal(1)))
//     ```
//
//     After narrowing:
//
//     ```
//     // Narrowed state element
//     state_element(bar, bits[4], init=0)
//
//     // Read of bar now sign-extends it for compatibility
//     extended_bar: bits[32] = sign_ext(state_read(bar), 32)
//
//     // Next value is computed on the narrowed bits
//     next_value(bar, bit_slice(new_value_for_bar, 0, 4))
//     ```
//
//
// This pass is highly integrated with `ProcStateRangeQueryEngine`, which
// performs an inter-cycle analysis to precisely track the evolution of state
// element values, enabling robust and correct narrowing decisions. The
// transformations involve updating the `StateElement` definition, and modifying
// `StateRead` and `Next` operations to slice/extend or concatenate as
// appropriate, ensuring functional equivalence with the original wider
// representation.
class ProcStateNarrowingPass : public OptimizationProcPass {
 public:
  static constexpr std::string_view kName = "proc_state_narrow";
  ProcStateNarrowingPass()
      : OptimizationProcPass(kName, "Proc State Narrowing") {}
  ~ProcStateNarrowingPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnProcInternal(
      Proc* proc, const OptimizationPassOptions& options, PassResults* results,
      OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_PROC_STATE_NARROWING_PASS_H_
