// Copyright 2023 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_TOKEN_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_TOKEN_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass that simplifies token networks. For example, if an AfterAll node has
// operands where one operand is an ancestor of another in the token graph, then
// the ancestor can be omitted. Similarly, duplicate operands can be removed and
// AfterAlls with one operand can be replaced with their operand.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `TokenSimplificationPass` is a crucial optimization pass in XLS that
// focuses on simplifying the token network within a function or proc. Token
// networks are essential for correctly enforcing ordering constraints between
// side-effecting operations (such as `send` and `receive`) in a dataflow graph.
// This pass aims to reduce the complexity and redundancy in these networks,
// leading to more compact and efficient control logic in the generated
// hardware.
//
// The pass performs several types of simplifications on `token`-typed
// operations, primarily `after_all` and `min_delay`:
//
// 1.  **Simplifying `after_all` Operations**:
//     *   **Single Operand `after_all`**: An `after_all` operation with only
//         one operand (e.g., `after_all(tok)`) is redundant and is replaced
//         directly by its single operand `tok`.
//
//         ```
//         // Original IR
//         after_all.1: token = after_all(tok)
//         next (after_all.1, ...)
//
//         // Optimized IR
//         next (tok, ...)
//         ```
//
//     *   **Duplicate Operands in `after_all`**: If an `after_all` operation
//         has multiple identical operands (e.g., `after_all(tok, tok, tok)`),
//         the duplicates are removed, leaving only one instance of each unique
//         token.
//
//         ```
//         // Original IR
//         after_all.1: token = after_all(tok, tok, tok)
//         next (after_all.1, ...)
//
//         // Optimized IR
//         next (tok, ...)
//         ```
//
//     *   **Nested `after_all` Operations**: If an `after_all` operation has
//         another `after_all` as an operand, and all users of the inner
//         `after_all` are also `after_all` operations, they can be collapsed.
//         This effectively flattens the token dependency chain.
//
//         ```
//         // Original IR
//         after_all.1: token = after_all(tok_a, tok_b)
//         after_all.2: token = after_all(after_all.1, tok_c)
//         next (after_all.2, ...)
//
//         // Optimized IR
//         after_all.new: token = after_all(tok_a, tok_b, tok_c)
//         next (after_all.new, ...)
//         ```
//
//     *   **Replacing Overlapping `after_all` Operands**: If an `after_all`
//         operation has multiple operands where one operand is an ancestor
//         (directly or indirectly) of another in the token graph, the ancestor
//         token can be removed from the `after_all`'s operand list. This is
//         because the dependency is already implied by the descendant token.
//         The pass is conservative and avoids analyzing through `invoke` nodes
//         to ensure correctness before function inlining.
//
//         ```
//         // Original IR
//         send.2: token = send(tok, literal(10), channel=test_channel)
//         send.3: token = send(send.2, literal(10), channel=test_channel)
//         // send.3 depends on send.2
//         after_all.4: token = after_all(tok, send.2, send.3)
//         next (after_all.4, ...)
//
//         // Optimized IR (simplified to the latest token in the chain)
//         // send.2 and tok are removed from after_all.4 because send.3 implies
//         // them
//         next (send.3, ...)
//         ```
//
//
// 2.  **Simplifying `min_delay` Operations**:
//     *   **Zero Delay `min_delay`**: A `min_delay` operation with a delay of 0
//         (e.g., `min_delay(tok, delay=0)`) is a no-operation and is replaced
//         by its operand `tok`. Similarly, `min_delay(after_all(), delay=X)` is
//         replaced by `after_all()`, as there are no actual events to delay.
//
//         ```
//         // Original IR
//         min_delay.1: token = min_delay(tok, delay=0)
//         next (min_delay.1, ...)
//
//         // Optimized IR
//         next (tok, ...)
//         ```
//
//     *   **Nested `min_delay` Operations**: Consecutive `min_delay` operations
//         can be collapsed into a single `min_delay` with the sum of their
//         delays (e.g., `min_delay(min_delay(tok, delay=1), delay=2)` becomes
//         `min_delay(tok, delay=3)`).
//
//         ```
//         // Original IR
//         min_delay.1: token = min_delay(tok, delay=1)
//         min_delay.2: token = min_delay(min_delay.1, delay=2)
//         next (min_delay.2, ...)
//
//         // Optimized IR
//         min_delay.new: token = min_delay(tok, delay=3)
//         next (min_delay.new, ...)
//         ```
//
//     *   **Pushing Down `min_delay` through `after_all`**: If all operands of
//         an `after_all` are `min_delay` operations, the smallest common delay
//         can be factored out and applied to the entire `after_all` operation.
//         This can reduce the total number of `min_delay` operations and
//         simplify scheduling.
//
//         ```
//         // Original IR
//         min_delay.1: token = min_delay(tok_a, delay=1)
//         min_delay.2: token = min_delay(tok_b, delay=2)
//         after_all.3: token = after_all(min_delay.1, min_delay.2)
//         next (after_all.3, ...)
//
//         // Optimized IR (factoring out common delay of 1)
//         min_delay.new: token = min_delay(after_all(tok_a, min_delay(tok_b,
//         delay=1)), delay=1) next (min_delay.new, ...)
//         ```
//
// This pass iteratively applies these simplifications to the token network
// until a fixed point is reached. By reducing redundant token dependencies and
// optimizing delay annotations, the pass contributes to more efficient
// scheduling and resource utilization in the generated hardware.
class TokenSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "token_simp";
  TokenSimplificationPass()
      : OptimizationFunctionBasePass(kName, "Simplify token networks") {}
  ~TokenSimplificationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_TOKEN_SIMPLIFICATION_PASS_H_
