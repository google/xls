// Copyright 2025 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_SELECT_MERGING_PASS_H_
#define XLS_PASSES_SELECT_MERGING_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `SelectMergingPass` is an optimization pass in XLS that focuses on
// merging consecutive `select`-like operations (`PrioritySelect` and
// `OneHotSelect`) into a single, larger `select` operation. This transformation
// can be highly beneficial for hardware synthesis, as it often allows the
// synthesis tool to infer more efficient and compact multiplexer structures
// from a single, unified `select` rather than from a cascade of smaller ones.
//
// The core principle of this pass is to identify patterns where the output of
// one `select` operation is used as an input (a case or a default value) to
// another `select` operation. When such a pattern is found, and certain
// conditions are met (primarily that the inner `select` has only one user),
// the pass merges the two `select`s into a single, equivalent `select`.
//
// **How it Works**:
//
// The pass operates by traversing the IR and applying merging logic to each
// `PrioritySelect` and `OneHotSelect` node it encounters. The transformation
// logic is tailored to the specific type of `select` operation:
//
// 1.  **Merging `OneHotSelect` Operations**:
//     *   **Pattern**: `one_hot_sel(selector_A, cases=[...,
//         one_hot_sel(selector_B, cases=[...]), ...])`
//     *   **Transformation**: The pass constructs a new, larger `one_hot_sel`.
//         *   **New Selector**: The new selector is a `concat` of several
//             components:
//             *   The original selector bits of `selector_A` that did not
//                 correspond to the inner `one_hot_sel`.
//             *   A new set of selector bits created by performing a bitwise
//                 `AND` of the `selector_B` with the bit from `selector_A`
//                 that originally selected the inner `one_hot_sel`. This
//                 effectively qualifies the inner selector with the outer
//                 selection condition.
//         *   **New Cases**: The new set of cases is a flattened list
//             comprising the original cases of both the outer and inner
//             `one_hot_sel`s, in the correct order.
//
// 2.  **Merging `PrioritySelect` Operations**:
//     *   **Pattern**: `priority_sel(selector_A,
//         cases=[..., priority_sel(selector_B, ...), ...], default=...)`
//     *   **Transformation**: Similar to `OneHotSelect`, a new, larger
//        `priority_sel` is constructed.
//         *   **New Selector**: The new selector is also a `concat`, but the
//             logic for combining the selectors is more complex to correctly
//             preserve the priority encoding. It involves `AND`ing the inner
//             selector bits with the outer selector bits and also considering
//             the conditions under which the inner `priority_sel` would fall
//             through to its default value.
//         *   **New Cases and Default**: The new cases are a flattened list of
//             the original cases. The new default value is typically the
//             default value of the inner `priority_sel` if it was part of the
//             default path of the outer `priority_sel`.
//     *   **Selector Swapping for Single-Bit `PrioritySelect`s**: A special
//         heuristic is applied for single-bit `priority_sel`s. If the default
//         value is the one that is a `select`, the pass can effectively negate
//         the selector and swap the case and default values to expose a more
//         direct merging opportunity.
//
// **Key Conditions for Merging**:
//
// *   **Single Use**: The inner `select` operation must have only one user (the
//     outer `select`). This is a critical constraint that prevents the pass
//     from increasing the amount of logic by duplicating the inner `select`'s
//     computation. If the inner `select` were used elsewhere, merging it would
//     require either duplicating it or introducing complex logic, which would
//     likely be counterproductive.
// *   **Matching `select` Types**: The pass is designed to merge `select`s of
//     the same kind (e.g., `OneHotSelect` into `OneHotSelect`,
//     `PrioritySelect` into `PrioritySelect`).
//
// **Benefits**:
//
// *   **Improved Hardware Synthesis**: Synthesis tools are often better at
//     optimizing a single, larger multiplexer structure than a cascade of
//     smaller ones. Merging `select`s can lead to more efficient hardware with
//     reduced area and potentially better timing.
// *   **IR Simplification**: Reduces the depth of the IR graph by collapsing
//     chained `select` operations, making the IR easier for subsequent passes
//     to analyze.
//
// Example (`OneHotSelect` merging):
// Consider a scenario where one `one_hot_sel` is used as a case in another:
//
//
// ```
// // Original IR snippet
// fn f(p0: bits[2], p1: bits[2], x: bits[32], y: bits[32],
//      z: bits[32]) -> bits[32] {
//   one_hot_sel.1: bits[32] = one_hot_sel(p0, cases=[x, y])
//   ret one_hot_sel.2: bits[32] = one_hot_sel(p1, cases=[one_hot_sel.1, z])
// }
// ```
//
//
// If `one_hot_sel.1` has only one user (`one_hot_sel.2`), the
// `SelectMergingPass` can merge them. Let's say `p1` selects `one_hot_sel.1`
// with its 0-th bit.
//
//
// ```
// // Optimized IR (simplified)
// fn f(p0: bits[2], p1: bits[2], x: bits[32], y: bits[32],
//      z: bits[32]) -> bits[32] {
//   // New selector combines p0 and p1
//   new_selector: bits[3] = concat(
//     bit_slice(p1, start=1, width=1), // Original bit 1 of p1
//     and(bit_slice(p1, start=0, width=1), bit_slice(p0, start=1, width=1)),
//     // p1[0] AND p0[1]
//     and(bit_slice(p1, start=0, width=1), bit_slice(p0, start=0, width=1))
//     // p1[0] AND p0[0]
//   )
//   ret one_hot_sel.merged: bits[32] = one_hot_sel(new_selector,
//                                                  cases=[x, y, z])
// }
// ```
//
// This transformation creates a single `one_hot_sel` that can be more
// efficiently synthesized, as it avoids the intermediate multiplexer
// represented by `one_hot_sel.1`.
class SelectMergingPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "select_merge";
  explicit SelectMergingPass()
      : OptimizationFunctionBasePass(kName, "Select Merging") {}
  ~SelectMergingPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_SELECT_MERGING_PASS_H_
