// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_ARRAY_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_ARRAY_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which simplifies or eliminates some array-type operations such as
// ArrayIndex.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ArraySimplificationPass` is a comprehensive optimization pass designed
// to simplify and, where possible, eliminate various array-related operations
// within the XLS IR. The primary objective is to reduce the complexity of array
// manipulation, leading to more efficient and compact hardware implementations.
// This pass employs a combination of pattern matching and range analysis to
// identify and transform redundant or inefficient array constructs.
//
// The pass operates in an iterative, fixed-point manner, continually applying
// transformations until no further simplifications can be made. It focuses on
// `Array`, `ArrayIndex`, `ArrayUpdate`, `ArraySlice`, and `Select` (or
// `PrioritySelect`) operations when they involve array types.
//
// Key simplifications performed by this pass include:
//
// 1.  **Clamping Out-of-Bounds `ArrayIndex` Indices**:
//     If range analysis (`QueryEngine`) can definitively determine that an
//     `ArrayIndex` operation is attempting to access an out-of-bounds memory
//     location, the index is clamped to the maximum in-bounds index (i.e., the
//     last element of the array). This ensures correct behavior in the
//     generated hardware and can simplify subsequent logic by removing checks
//     for illegal accesses.
//
// 2.  **Simplifying `ArrayIndex` Operations**:
//     *   **Empty Indices**: An `array_index(A, {})` operation (where the index
//         list is empty) is replaced directly by the array `A` itself, as it
//         logically references the entire array.
//
//     *   **`ArrayIndex` of `ArrayUpdate` with Matching Indices**: If an
//         `array_index` operation accesses the same index that was previously
//         updated by an `array_update` operation (e.g.,
//         `array_index(array_update(A, V, {idx}), {idx})`), and the index is
//         known to be in bounds, it is replaced directly with the updated value
//         `V`. This bypasses the array storage entirely.
//
//     *   **Trivial Dimensions**: If an `ArrayIndex` accesses an array
//         dimension of size 1 (e.g., `bits[32][1]`), the index for that
//         dimension is replaced with a literal `0`, as there is only one
//         possible element to access. This simplifies the indexing logic.
//
//     *   **`ArrayIndex` of `Array` with Constant First Index**: An
//         `array_index(array(E0, E1, ...), {C, ...})` operation, where `C` is a
//         constant index, is transformed to directly index into the
//         corresponding element `Ec`. This bypasses the array construction,
//         reducing IR nodes.
//
//     *   **`ArrayIndex` of `ArrayConcat` with Constant First Index**: Similar
//         to `Array`, if an `ArrayIndex` accesses an `array_concat` with a
//         constant first index, it bypasses the `array_concat` and directly
//         indexes into the appropriate sub-array within the concatenated
//         structure.
//
//     *   **Consecutive `ArrayIndex` Operations**: A sequence of nested
//         `array_index` operations (e.g., `array_index(array_index(A, {idx0}),
//         {idx1})`) is flattened into a single `array_index(A, {idx0, idx1})`,
//         combining the indices for greater efficiency.
//
//     *   **`ArrayIndex` of `Select` (or `PrioritySelect`)**: An operation of
//         the form `array_index(select(P, cases=[A0, A1]), {idx})` is
//         transformed into `select(P, cases=[array_index(A0, {idx}),
//         array_index(A1, {idx})])`. This effectively pushes the `select`
//         operation inside the array access, potentially reducing the overall
//         multiplexer (mux) width if the array elements are smaller than the
//         entire array. This is particularly beneficial for "small" arrays or
//         when the outer `array_index` is the sole user of the `select`
//         operation.
//
// 3.  **Simplifying `ArrayUpdate` Operations**:
//     *   **Empty Indices**: An `array_update(A, V, {})` operation (with no
//         indices) is replaced directly by the update value `V`, as it
//         logically replaces the entire array.
//
//     *   **Redundant `ArrayUpdate`**: If an `array_update` operation updates
//         an element with its current value (e.g.,
//         `array_update(A, array_index(A, {idx}), {idx})`) and the index is
//         known to be in bounds, it is replaced with the original array `A`, as
//         no actual change occurs.
//
//     *   **`ArrayUpdate` on Unit-Dimension Arrays**: An
//         `array_update(A[1], V, {idx})` (updating a 1-element array, possibly
//         within a multi-dimensional array) is replaced with a `select`
//         operation. This `select` conditionally chooses between an
//         array-packed version of the update value `V` and the original array
//         `A`, based on whether the index `idx` matches the single valid index.
//         This allows for explicit conditional updates for these small arrays.
//
//     *   **Hoisting `ArrayUpdate` above `Array`**: An `array_update` applied
//         to an `array` literal (e.g., `array_update(array(A,B,C), V, {idx})`)
//         can be transformed into a new `array` where the element at `idx` is
//         replaced by `V`, potentially after applying sub-updates if the array
//         is multi-dimensional. This is particularly beneficial for constant
//         arrays.
//
//     *   **Flattening Sequential `ArrayUpdate` Chains**: The pass identifies
//         and flattens sequences of `array_update` operations that modify the
//         same array. If a later update necessarily overwrites elements updated
//         by an earlier `array_update`, the earlier, redundant update can be
//         elided.
//
//     *   **`ArrayUpdate` of `ArrayIndex`**: An `array_update` of the form
//         `array_update(A, array_update(array_index(A, {i}), V, {j}), {i})` can
//         be simplified to `array_update(A, V, {i, j})`, effectively merging
//         nested update operations for increased efficiency.
//
// 4.  **Simplifying `Array` Operations**:
//     *   **Decomposition and Recomposition Elimination**: The pass can detect
//         a pattern where an array is first decomposed into its individual
//         elements (using `array_index` operations) and then immediately
//         recomposed back into an array (using an `array` operation). If the
//         indices are sequential and cover the entire range, this redundant
//         decomposition-recomposition pair is eliminated, replacing the `array`
//         operation with the original source `array` or a simple `array_index`
//         on the source.
//
// 5.  **Simplifying `ArraySlice` Operations**:
//     *   **Literal Start Index**: An `array_slice` operation with a literal
//         start index is replaced by an `array` literal constructed from the
//         directly indexed elements of the source array. This eliminates
//         dynamic slicing operations in hardware.
//
// 6.  **Simplifying `Select` of Array-typed Values**:
//     *   **Conditional Array Assignment**: A `select` of the form
//         `select(P, cases=[A, array_update(A, V, {idx})])` is transformed
//         into `array_update(A, select(P, cases=[array_index(A, {idx}), V]),
//         {idx})`. This optimization hoists the `select` inside the
//         `array_update`, reducing the multiplexer width to operate only on the
//         single array element being conditionally updated.
//
//     *   **`Select` of Arrays to Array of `Selects`**: A `select` operation
//         where all its cases (and optionally default value) are array-typed
//         values (e.g., `select(P, cases=[array_0, array_1])`) can be
//         converted to an `array` of `select` operations (e.g.,
//         `array(select(P, {array_0[0], array_1[0]}), select(P, {array_0[1],
//         array_1[1]}), ...)`). This transformation can expose smaller `select`
//         operations for further optimization but also has the potential to
//         increase logic replication. Therefore, it is applied judiciously
//         based on heuristics.
//
// This pass is essential for translating high-level array abstractions into
// efficient hardware structures by aggressively simplifying and optimizing
// array access and manipulation patterns, contributing significantly to
// improved hardware QoR.
class ArraySimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "array_simp";
  explicit ArraySimplificationPass()
      : OptimizationFunctionBasePass(kName, "Array Simplification") {}

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_ARRAY_SIMPLIFICATION_PASS_H_
