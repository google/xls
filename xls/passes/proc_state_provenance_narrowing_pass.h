// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_PROC_STATE_PROVENANCE_NARROWING_PASS_H_
#define XLS_PASSES_PROC_STATE_PROVENANCE_NARROWING_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/proc.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which tries to minimize the size and total number of elements of the
// proc state. This pass works by examining the provenance of the bits making
// up the next value to determine which (if any) bits are never actually
// modified.
//
// NB This is a separate pass from ProcStateNarrowing for simplicity of
// implementation. That pass mostly assumes we'll have a range-analysis which
// this does not need.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ProcStateProvenanceNarrowingPass` is an optimization pass designed to
// reduce the bit-width of state elements within a Proc. It achieves this by
// performing a detailed "provenance" analysis on the bits that constitute the
// `next_value` of each state element. The goal is to identify which specific
// bits of a state element are *never actually modified* from their initial
// value, regardless of the control flow or data inputs to the Proc. These
// unchanging bits can then be removed from the state element, leading to a
// narrower, more efficient register in hardware.
//
// This pass is distinct from `ProcStateNarrowingPass` (which primarily relies
// on range analysis) because `ProcStateProvenanceNarrowingPass` does not
// require complex range information. Instead, it directly inspects the
// bit-level origins and updates.
//
// **How it Works**:
//
// 1.  **Bit Provenance Analysis (`BitProvenanceAnalysis`)**: The pass utilizes
//     `BitProvenanceAnalysis` to determine, for every bit of every node, its
//     origin. This analysis can trace whether a bit is derived from a specific
//     input bit, a constant, or a combination of sources. It provides a precise
//     understanding of how each bit of a `next_value` is influenced by the
//     current state and inputs.
//
// 2.  **Ternary Query Engine (`LazyTernaryQueryEngine`)**: Alongside
//     provenance, a `LazyTernaryQueryEngine` is used to provide ternary
//     information about bits (known zero, known one, or unknown). This helps in
//     identifying bits
//     that are effectively constant or always take a certain value.
//
// 3.  **`UnchangedBits` Function**: This is the core logic for identifying bits
//     that can be narrowed. For each state element, it examines all its `Next`
//     operations. For a given `Next(state_read, next_value, predicate)`:
//     *   If `next_value` is the same as `state_read`, those bits are trivially
//         unchanged.
//     *   Otherwise, it compares the bits of `next_value` with the
//         `initial_bits` of the state element. Using both ternary and
//         provenance analysis, it identifies bits in `next_value` that are
//         *provably identical* to their corresponding `initial_bits` or are
//         *known to be constants* that match the `initial_bits`.
//     *   The `unchanged_bits` mask is iteratively refined (using bitwise
//         `AND`) across all `Next` operations for a given state element. A bit
//         is deemed "unchanged" only if *all* `Next` operations either preserve
//         its initial value or are predicated off (i.e., don't update it under
//         conditions where it *could* change).
//
// 4.  **Bit Segment Extraction (`ExtractBitSegments`)**: Once the final
//     `unchanged_bits` mask is determined, this function breaks down the state
//     element's bit range into contiguous `BitSegment`s. Each segment is marked
//     as either a constant segment (if it corresponds to bits that are always
//     unchanged and match the initial value) or a variable segment (for bits
//     that can change).
//
// 5.  **`NarrowTransform` (State Element Transformation)**:
//     This custom `Proc::StateElementTransformer` is used to apply the
//     narrowing transformation:
//     *   **New State Element**: The original state element is replaced by a
//         new `StateElement` with a narrower bit-width, comprising only the
//         variable segments identified in step 4.
//     *   **`TransformStateRead`**: When the narrowed `StateElement` is read by
//         a `StateRead` operation, it is reconstructed into its original, wider
//         form. This is done by concatenating the new, narrower `StateRead`
//         output with `Literal` nodes for all the constant segments. This
//         ensures that downstream logic continues to receive the expected
//         full-width value.
//     *   **`TransformNextValue`**: The `next_value` computation is also
//         narrowed. Only the variable segments from the original `next_value`
//         are extracted (using `bit_slice` operations) and concatenated to form
//         the new, narrower `next_value` for the transformed `StateElement`.
//
// **Benefits**:
//
// *   **Significant Area Reduction**: Directly reduces the number of flip-flops
//     (registers) required for state elements, leading to smaller hardware
//     area.
// *   **Power Efficiency**: Fewer registers typically consume less dynamic and
//     static power.
// *   **Improved Optimizability**: A narrower state element simplifies its uses
//     and can expose further optimization opportunities for operations that
//     consume it.
//
// Example:
// Consider a 128-bit state element `foo` in a Proc, where a portion of its bits
// (e.g., bits 32-63) are known to always hold a specific constant value (e.g.,
// `0xFFFF_0000`) and never change.
//
//
// ```
// // Original IR snippet
// package my_package
//
// proc my_proc(foo: bits[128],
//              init=0x0000_0000_FFFF_0000_0000_0000_0000_0000) {
//   // ...
//   // A next_value operation where bits 32-63 (0xFFFF_0000) are always
//   // preserved, but other bits might change based on inputs.
//   next_val_update: bits[128] = some_complex_logic(state_read(foo), input_val)
//   next (foo, next_val_update)
// }
// ```
//
//
// `ProcStateProvenanceNarrowingPass` would identify that bits 32-63 of `foo`
// are unchanging. It would then transform `foo` into a narrower state element,
// effectively removing those constant bits from its storage:
//
//
// ```
// // Optimized IR snippet (simplified, after narrowing and cleanup)
// package my_package
//
// proc my_proc(foo: bits[96],
//              init=0x0000_0000_0000_0000_0000_0000) { // Foo is now 96 bits
//   // ...
//   foo_read_narrow: bits[96] = state_read(foo)
//
//   // Reconstruct original 128-bit value by concatenating narrowed state with
//   // constant bits
//   foo_reconstructed: bits[128] = concat(
//     bit_slice(foo_read_narrow, 64, 32), // High variable bits
//     literal(0x0000_FFFF, bits=32), // Constant bits that were removed
//     bit_slice(foo_read_narrow, 0, 32)  // Low variable bits
//   )
//   // ... downstream logic now uses `foo_reconstructed`
//
//   // Next value also narrowed
//   next_val_update_narrowed: bits[96] = some_complex_logic_narrowed(...)
//   next (foo, next_val_update_narrowed)
// }
// ```
//
// This reduces the physical register size for `foo` by 32 bits, leading to a
// more compact and efficient hardware implementation while maintaining
// functional equivalence.
class ProcStateProvenanceNarrowingPass : public OptimizationProcPass {
 public:
  static constexpr std::string_view kName = "proc_state_provenance_narrow";
  ProcStateProvenanceNarrowingPass()
      : OptimizationProcPass(kName, "Proc State Provenance Narrowing") {}
  ~ProcStateProvenanceNarrowingPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnProcInternal(
      Proc* proc, const OptimizationPassOptions& options, PassResults* results,
      OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_PROC_STATE_PROVENANCE_NARROWING_PASS_H_
