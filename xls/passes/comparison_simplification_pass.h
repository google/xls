// Copyright 2021 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_COMPARISON_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_COMPARISON_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Simplifies logical operations on the results of comparison
// operations. For example:
//
//   eq(x, 0) && ne(x, 1) => eq(x, 0)
//   eq(x, 0) && ne(x, 0) => 0
//   eq(x, 0) || ne(x, 0) => 1
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ComparisonSimplificationPass` is an optimization pass that focuses on
// simplifying logical operations that consume the results of comparison
// operations. Its primary goal is to reduce redundant comparisons and
// streamline complex Boolean expressions derived from equality, inequality, and
// ordering checks, thereby leading to more efficient hardware implementations.
//
// The pass operates in an iterative, fixed-point manner, continuously applying
// simplifications until no further changes can be made. It performs two main
// types of optimizations:
//
// 1.  **Range-Based Simplification of Comparison/Logical Trees**:
//     *   **`ComputeRangeEquivalence`**: This function analyzes single-bit
//         nodes (which typically represent the results of comparisons or
//         logical operations) and determines their equivalent range of values.
//         A `RangeEquivalence` struct is used to store the original `Node` and
//         an `IntervalSet` representing the precise set of values for which the
//         node evaluates to true.
//         *   For basic comparison operations (e.g., `eq(x, 42)`, `ult(x,
//             10)`), it directly computes the `IntervalSet` that makes the
//             comparison true.
//
//         *   For logical operations (`and`, `or`, `not`, `nand`, `nor`) whose
//             operands are also comparison results (or other logical operations
//             with known ranges), it combines their `IntervalSet`s using set
//             intersection (for `and`), set union (for `or`), or set complement
//             (for `not`, `nand`, `nor`).
//
//     *   **Replacing with Constants or Simpler Comparisons**: Once the
//         `RangeEquivalence` for a node is accurately determined, the pass
//         attempts to simplify the node itself:
//         *   **Maximal Range (Always True)**: If the computed `IntervalSet`
//             covers the entire possible range of values for `x`, the node
//             (e.g., a complex Boolean expression) is replaced with a literal
//             `1` (representing true).
//
//         *   **Empty Range (Always False)**: If the `IntervalSet` is empty,
//             indicating that the condition can never be met, the node is
//             replaced with a literal `0` (representing false).
//
//         *   **Precise Value**: If the `IntervalSet` reduces to a single,
//             precise value `C` (e.g., `x` must be `42`), the node is replaced
//             with an `eq(x, C)` operation.
//
//         *   **Complementary Precise Value**: If the `IntervalSet` represents
//             all values except a single value `C`, the node is replaced with a
//             `ne(x, C)` operation.
//
//         *   **ULt/UGt Interval**: If the `IntervalSet` corresponds to a
//             contiguous range starting from 0 up to `C` (e.g., `[0, 42]`),
//             it's replaced with `ult(x, C+1)`. Conversely, if it's a range
//             from `C` to the maximum value (e.g., `[42, MAX]`), it's replaced
//             with `ugt(x, C-1)`.
//
//     *   **Guards against De-optimization**: The pass incorporates checks to
//         prevent replacing existing simple comparison operations (like `eq`,
//         `ne`, `ult`, `ugt`, etc.) or inversions of multi-user comparisons
//         with new, potentially more complex, comparisons. This guards against
//         unintended logic duplication and an increase in hardware area.
//
// 2.  **`TransformDerivedComparisons`**: This function identifies and
//     eliminates redundant comparison operations by recognizing fundamental
//     Boolean identities and relationships:
//     *   **Commuted Operands**: If a comparison `ult(x, y)` exists in the IR,
//         and a redundant `ugt(y, x)` is found, the latter is replaced by the
//         former.
//
//     *   **Inverted Comparison**: If `ult(x, y)` exists, and `uge(x, y)` is
//         found, the latter can be replaced by `not(ult(x, y))`, leveraging the
//         existing comparison.
//
//     *   **Inverted and Commuted Comparison**: If `ult(x, y)` exists, and
//         `ule(y, x)` is found, it can be replaced by `not(ult(x, y))`,
//         combining both the inversion and commutation optimizations.
//
// By aggressively simplifying logical operations over comparisons, this pass
// significantly reduces the complexity of control logic, which is crucial for
// generating smaller and faster hardware designs.
//
// Example: Consider the expression `eq(x, 0) && ne(x, 1)`.
//
//
// ```
// // Original IR snippet
// fn f(x: bits[32]) -> bits[1] {
//   literal.0: bits[32] = literal(value=0)
//   literal.1: bits[32] = literal(value=1)
//   x_eq_0: bits[1] = eq(x, literal.0)
//   x_ne_1: bits[1] = ne(x, literal.1)
//   ret and.final: bits[1] = and(x_eq_0, x_ne_1)
// }
// ```
//
//
// The `ComputeRangeEquivalence` would determine that:
// *   `x_eq_0` is equivalent to `x` being in the range `[[0, 0]]`.
// *   `x_ne_1` is equivalent to `x` being in `[[0, 0], [2, MAX]]`.
// When these two ranges are combined by the `and` operation, the resulting
// effective range for `x` is `[[0, 0]]`. Since this represents `x` being
// precisely equal to `0`, the pass will simplify `and.final` to `eq(x, 0)`:
//
//
// ```
// // Optimized IR (simplified)
// fn f(x: bits[32]) -> bits[1] {
//   literal.0: bits[32] = literal(value=0)
//   ret eq.final: bits[1] = eq(x, literal.0)
// }
// ```
//
// This effectively removes the redundant `ne(x, 1)` comparison, leading to
// simpler logic.
class ComparisonSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "comparison_simp";
  ComparisonSimplificationPass()
      : OptimizationFunctionBasePass(kName, "Comparison Simplification") {}
  ~ComparisonSimplificationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_COMPARISON_SIMPLIFICATION_PASS_H_
