// Copyright 2025 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_NON_SYNTH_SEPARATION_PASS_H_
#define XLS_PASSES_NON_SYNTH_SEPARATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/package.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Separates out non-synthesizable nodes like assert/cover/trace from the main
// function into a cloned function. Every function effectively has two versions,
// one with synthesizable nodes and one without. The synthesizable version
// invokes the non-synthesizable version of its function. This ensures that
// non-synthesizable uses of values do not affect the optimization of the
// synthesizable parts of the function.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `NonSynthSeparationPass` is a crucial optimization pass in XLS that
// isolates non-synthesizable operations (such as `assert`, `cover`, and
// `trace`) from the main, synthesizable logic of a function or proc. This
// separation is essential because non-synthesizable operations can introduce
// data dependencies that might prevent optimizations on the synthesizable parts
// of the design. For instance, a value used in an `assert` could be seen as
// "live" by the Dead Code Elimination (DCE) pass, even if that value is not
// used in any synthesizable computation. This would prevent the logic
// generating that value from being removed.
//
// By separating these concerns, the pass allows the synthesizable parts of the
// design to be aggressively optimized without being constrained by the needs of
// verification and debugging constructs.
//
// **How it Works**:
//
// 1.  **Identification**: The pass first traverses each function and proc in
//     the package to determine if it contains any non-synthesizable nodes
//     (`assert`, `cover`, `trace`). If a function or proc is purely
//     synthesizable, it is left untouched.
//
// 2.  **Cloning**: For each function or proc that contains non-synthesizable
//     operations, a new, separate "non-synthesizable" version is created:
//     *   **For Functions**: The original function is cloned to create a new
//         function (e.g., `f` is cloned to `non_synth_f`).
//
//     *   **For Procs**: The original proc is cloned, but as a `Function`
//         rather than a `Proc`. This is because the non-synthesizable
//         operations are stateless from a hardware perspective (they don't
//         generate registers). Any proc-specific nodes (like `StateRead`,
//         `Next`, `Send`, `Receive`) are handled specially during this cloning:
//         *   `StateRead` operations become `Param`s in the new function.
//
//         *   `Next` operations are handled to update non-synthesizable state,
//             but do not become part of the new function's logic.
//
//         *   `Send` and `Receive` operations are similarly abstracted away,
//             with their data payloads passed as parameters to the new
//             function.
//
// 3.  **Separation**:
//     *   **Original (Synthesizable) Version**: All non-synthesizable nodes are
//         removed from the original function or proc. It is then modified to
//         `invoke` the newly created non-synthesizable function, passing it all
//         the necessary data (e.g., function parameters, proc state, received
//         data) that the non-synthesizable operations depend on. This `invoke`
//         itself is non-synthesizable but has a minimal impact on the
//         synthesizable logic.
//
//     *   **New (Non-Synthesizable) Version**: The cloned function is stripped
//         of all its synthesizable outputs (its return value is made a useless
//         empty tuple). It retains only the logic necessary to support the
//         non-synthesizable operations.
//
// 4.  **`Gate` to `Select` Conversion**: `Gate` operations, which are special
//     power-optimization nodes, are typically not removed by DCE. To prevent
//     their unnecessary duplication in the non-synthesizable function, they are
//     converted to equivalent `select` operations, which can be more easily
//     optimized away if they become redundant.
//
// **Benefits**:
//
// *   **Improved Optimization**: Frees the synthesizable logic from
//     dependencies related to verification and debugging, enabling more
//     aggressive optimizations like DCE, constant folding, and strength
//     reduction.
//
// *   **Clear Separation of Concerns**: Creates a clean architectural
//     separation between synthesizable hardware logic and non-synthesizable
//     verification/debugging logic, improving the clarity and maintainability
//     of the IR.
//
// *   **Correctness**: Ensures that verification constructs like `assert`,
//     `cover`, and `trace` are preserved and correctly reflect the behavior of
//     the design, while not interfering with the synthesis of the core
//     functional logic.
//
// Example:
// Consider a function that contains both a synthesizable computation and an
// `assert`:
//
//
// ```
// // Original IR snippet
// fn my_func(x: bits[32]) -> bits[32] {
//   tok: token = literal(value=token)
//   intermediate: bits[32] = add(x, literal(1))
//   is_zero: bits[1] = eq(intermediate, literal(0))
//   assert.1: token = assert(tok, is_zero, message="intermediate is zero!")
//   ret result: bits[32] = mul(intermediate, literal(2))
// }
// ```
//
//
// After `NonSynthSeparationPass`, the IR would be split into two functions:
//
//
// ```
// // Synthesizable version (original function, modified)
// fn my_func(x: bits[32]) -> bits[32] {
//   intermediate: bits[32] = add(x, literal(1))
//   is_zero: bits[1] = eq(intermediate, literal(0))
//
//   // Invoke the non-synthesizable part, passing necessary values
//   invoke_non_synth: () = invoke(is_zero, to_apply=non_synth_my_func)
//
//   ret result: bits[32] = mul(intermediate, literal(2))
// }
//
// // Non-synthesizable version (newly created function)
// fn non_synth_my_func(is_zero: bits[1]) -> () {
//   tok: token = literal(value=token)
//   assert.1: token = assert(tok, is_zero, message="intermediate is zero!")
//
//   ret useless_return: () = tuple() // Return value is made useless
// }
// ```
//
// In this transformed IR, the main `my_func` is now free of any `assert`
// operations, and optimizations like DCE can proceed on `is_zero` if `result`
// does not depend on it. The `non_synth_my_func` encapsulates the verification
// logic, ensuring it is preserved without hindering the optimization of the
// synthesizable path.
class NonSynthSeparationPass : public OptimizationPass {
 public:
  static constexpr std::string_view kName = "non_synth_separation";
  explicit NonSynthSeparationPass()
      : OptimizationPass(kName, "Non-Synthesizable Separation") {}
  ~NonSynthSeparationPass() override = default;

 protected:
  absl::StatusOr<bool> RunInternal(Package* p,
                                   const OptimizationPassOptions& options,
                                   PassResults* results,
                                   OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_NON_SYNTH_SEPARATION_PASS_H_
