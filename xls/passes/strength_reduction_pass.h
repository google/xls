// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_STRENGTH_REDUCTION_PASS_H_
#define XLS_PASSES_STRENGTH_REDUCTION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Replaces operations with equivalent cheaper operations. For example, multiply
// by a power-of-two constant may be replaced with a shift left.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `StrengthReductionPass` is a crucial optimization pass in XLS that aims
// to improve hardware efficiency by replacing computationally expensive
// operations with equivalent but cheaper alternatives. This transformation is
// fundamental for reducing the area, delay, and power consumption of the
// generated hardware. The pass intelligently identifies patterns where a
// complex operation can be implemented using simpler primitives, often
// leveraging constant operands or known bit patterns.
//
// The pass operates by traversing the IR and applying a variety of strength
// reduction techniques. It utilizes a `UnionQueryEngine` (combining
// `StatelessQueryEngine` and `LazyTernaryQueryEngine`) to analyze the
// properties of nodes, such as whether a value is fully known (constant), its
// leading/trailing zeros, or known sign bits.
//
// Key strength reductions performed by this pass include:
//
// 1.  **Replacement of Known Values with Literals**:
//     If the `QueryEngine` can prove that a node (especially a non-literal
//     operation) always evaluates to a constant value, it's replaced with a
//     `literal` node. This is a general simplification that can occur across
//     various operation types, reducing dynamic computation to a static value.
//
// 2.  **Sinking Operations into `Select`s**:
//     If an operation has one operand that is a `select` (or `priority_select`)
//     with all its cases being known constants, and other operands of the
//     operation are also known constants, the operation can be "sunk" into the
//     `select`. This means the operation is duplicated for each case of the
//     `select`, performed on the constant values, and then a new `select` is
//     formed with the results. This often allows for further constant folding
//     or narrowing of the operations.
//
//
//     ```
//     // Original IR
//     v1 := Select(selector, [const1, const2])
//     v2 := Add(v1, const3)
//
//     // Optimized IR (conceptually)
//     v1_c1 := Add(const1, const3)
//     v1_c2 := Add(const2, const3)
//     v2 := Select(selector, [v1_c1, v1_c2])
//     ```
//
//
// 3.  **Additions (`add`)**:
//     *   **Addition with Zero**: `add(x, 0)` is replaced directly by `x`.
//     *   **Addition to OR (No Carry)**: If `add(A, B)` is such that there are
//         no possible carries between any bit positions (i.e., for any bit
//         position `i`, it's not possible for both `A[i]` and `B[i]` to be `1`
//         simultaneously, as determined by ternary analysis), the `add` can be
//         replaced by a bitwise `or` operation, which is typically cheaper.
//     *   **Splitting Adders (No Carry Propagation)**: At higher optimization
//         levels (`SplitsEnabled`), if `QueryEngine` can determine a bit
//         position in `add(A, B)` where a carry can provably *not* propagate
//         (e.g., if the sum bit `A[i] | B[i]` is always 0), the adder can be
//         split into two smaller adders. The lower-order bits are added
//         independently, and the higher-order bits are added independently,
//         with the results concatenated. This can reduce the critical path
//         delay.
//
// 4.  **Subtractions (`sub`)**:
//     *   **Subtraction by Zero**: `sub(x, 0)` is replaced directly by `x`.
//     *   **Subtracting from All-Ones**: `sub(all_ones, x)` is replaced by
//         `not(x)`.
//     *   **Splitting Subtractors (No Borrow Propagation)**: Similar to adders,
//         at higher optimization levels (`SplitsEnabled`), if a bit position in
//         `sub(A, B)` can be identified where a borrow can provably *not*
//         propagate (e.g., if `A[i]` is always 1 and `B[i]` is always 0), the
//         subtractor can be split into two smaller subtractors, with results
//         concatenated.
//
// 5.  **Bitwise AND with Mask (`and`)**:
//     `and(x, mask)` where `mask` is a constant with a single contiguous run
//     of set bits (e.g., `0b011100`) can be strength-reduced into a `concat` of
//     zeros, a `bit_slice` of `x` (extracting the bits corresponding to the set
//     bits in the mask), and more zeros. This avoids a full bitwise AND for
//     simple masking operations.
//
// 6.  **`Select` to `SignExt` Transformation**:
//     A `select` operation that effectively acts as a sign extension (e.g.,
//     if the selector is 0 it picks 0, if 1 it picks all ones, and then
//     extended to a wider width) can be replaced by a `sign_ext` operation.
//     This is common when a 1-bit predicate controls the sign extension of a
//     value.
//
// 7.  **`SignExt` to `ZeroExt` Transformation**:
//     If `sign_ext(x, ...)` is such that the MSB of `x` is known to be `0` (as
//     determined by `QueryEngine`), the `sign_ext` can be replaced with a
//     `zero_ext`, which is generally simpler to implement in hardware.
//
// 8.  **`Gate` Operations**:
//     *   If the `condition` of a `gate(cond, data)` is a known `0`, the `gate`
//         is replaced with a `literal` `0`.
//     *   If the `condition` is a known `1`, the `gate` is replaced with its
//         `data` operand.
//     *   If the `data` operand is a known `0`, the `gate` is replaced with a
//         `literal` `0` (regardless of the condition).
//
// 9.  **Single-bit `Add` and `Ne` to `Xor`**:
//     For 1-bit operands, `add(x, y)` and `ne(x, y)` are equivalent to
//     `xor(x, y)`, and are transformed accordingly, using the typically cheaper
//     `xor` operation.
//
// 10. **Comparisons against Powers of Two (`uge`, `ult`)**:
//     Comparisons like `x >= 2^K` or `x < 2^K` where `2^K` is a power of two
//     constant, can be simplified to a comparison of a `bit_slice` of `x`
//     (extracting the relevant leading bits) against `0`.
//
// 11. **`Eq(x, 0)` for `bits[2]` to
//     `Not(Or(bit_slice(x,0,1), bit_slice(x,1,1)))`**: This specifically
//     optimizes equality checks against zero for 2-bit values into a more
//     fundamental Boolean logic expression.
//
// 12. **Arithmetic Operations with a Single Unknown Bit**:
//     For expensive arithmetic operations (`smul`, `umul`, `sdiv`, `udiv`,
//     `smod`, `umod`) with two operands where one operand is a constant and the
//     other has only *one* unknown bit (all other bits are known constants),
//     the operation is transformed into a `select` operation. The `select`'s
//     selector is the single unknown bit, and its cases are the two possible
//     results of the arithmetic operation when that unknown bit is 0 or 1. This
//     replaces a complex arithmetic unit with a simple multiplexer for two
//     pre-computed literal results.
//
// The pass is run repeatedly until a fixed point is reached, allowing these
// local transformations to propagate and enable further simplifications across
// the entire IR.
class StrengthReductionPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "strength_red";
  explicit StrengthReductionPass()
      : OptimizationFunctionBasePass(kName, "Strength Reduction") {}
  ~StrengthReductionPass() override = default;

 protected:
  // Run all registered passes in order of registration.
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_STRENGTH_REDUCTION_PASS_H_
