// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_NARROWING_PASS_H_
#define XLS_PASSES_NARROWING_PASS_H_

#include <cstdint>
#include <ostream>
#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// A pass which reduces the width of operations eliminating redundant or unused
// bits.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `NarrowingPass` is a powerful optimization pass in XLS designed to reduce
// the bit width of `bits`-typed operations and values within a function or
// proc.  This is a critical optimization for hardware generation, as a
// reduction in bit widths directly translates to smaller, more efficient, and
// often faster hardware (fewer wires, smaller functional units, and smaller
// registers).  The pass employs various advanced analysis techniques to
// determine the minimum required bit width for each value without altering its
// functional correctness.
//
// The pass is configured with an `AnalysisType` enum, which dictates the
// sophistication of the analysis used:
//
// *   **`kTernary`**: Utilizes a simpler ternary logic-based query engine.
//     This analysis determines for each bit if it is always zero, always one,
//     or unknown.
//
// *   **`kRange`**: Employs a more powerful range analysis to determine the
//     possible numerical bounds (minimum and maximum values) that a bit-vector
//     can take. This provides more precise information for narrowing.
//
// *   **`kRangeWithContext`**: Extends range analysis to be context-sensitive.
//     This means it considers predicates (conditions) of `select` operations
//     and other conditional control flow to derive more precise ranges for
//     values within specific execution paths.
//
// *   **`kRangeWithOptionalContext`**: Allows the choice between `kRange` and
//     `kRangeWithContext` based on the
//     `options.use_context_narrowing_analysis` flag, providing flexibility in
//     trade-off between analysis time and precision.
//
// The pass operates by iteratively traversing the IR and applying
// transformations to nodes where bit widths can be safely reduced. Key
// optimizations include:
//
// 1.  **Replacing Precise Values with Literals**: If an analysis (ternary or
//     range) can definitively determine that a node's value is precisely known
//     (i.e., it always evaluates to a constant), that node is replaced with a
//     `literal` node. This simplifies the graph and can enable further
//     optimizations.
//
// 2.  **Narrowing Comparison Operations**:
//     *   **Stripping Matched Leading/Trailing Bits**: For comparison
//         operations (`eq`, `ne`, `ult`, `ugt`, etc.), if leading or trailing
//         bits of both operands are known to be identical, these matching bits
//         can be logically removed, and the comparison is performed on the
//         narrower remaining bits.
//
//
//         ```
//         // Original: UGt(0b0110_0XXX_0011, 0b0110_0YYY_0011) // bit strings
//         // Leading `0110` and trailing `0011` match for both operands.
//         // Optimized: UGt(0bXXX, 0bYYY)
//         ```
//
//     *   **Signed Comparison Simplification**: Signed comparisons with
//         zero-extended operands (or operands whose MSBs are known to be equal)
//         can often be converted to unsigned comparisons on narrower bit
//         widths, as the sign information becomes redundant.
//
// 3.  **Narrowing `Negate` Operations**:
//     *   **Trailing Zeros**: If an operand to a `negate` operation has known
//         trailing zeros, the `negate` can be performed on the more significant
//         bits, and the trailing zeros re-concatenated, effectively reducing
//         the width of the `negate` operation.
//
//     *   **Sign Extension Hoisting**: For `negate(sign_ext(x))`, if the range
//         analysis shows that `x` cannot be the minimum representable signed
//         value, this can be simplified to `sign_ext(negate(x))`, reducing the
//         width of the `negate` operation. More generally, it finds the minimal
//         bit width for the inner `negate` and then re-extends.
//
// 4.  **Narrowing Shift Operations (`shll`, `shra`, `shrl`)**:
//     *   **Zero Shift Amount**: If a shift amount is provably zero, the shift
//         operation is replaced directly by its value operand (a no-op).
//
//     *   **Known Leading/Trailing Zeros/Sign Bits**: For shift operations, if
//         parts of the `shift_value` are known to be zero or sign bits, the
//         `shift_value` can be sliced to remove these redundant bits before the
//         shift, and the result re-extended (zero-extend or sign-extend) if
//         necessary. The `shift_amount` itself can also be narrowed if it has
//         leading zeros.
//
//     *   **Out-of-Bounds Shifts**: Shift operations that are guaranteed to
//         shift all bits off the end of the operand (resulting in a zero value)
//         are replaced by a literal zero.
//
// 5.  **Narrowing `Add` and `Sub` Operations**:
//     *   **Common Leading Zeros/Sign Bits**: For `add` and `sub` operations,
//         if both operands share a common number of leading zeros (for unsigned
//         results) or sign bits (for signed results), the operation can be
//         performed on a narrower bit width. The result is then zero-extended
//         or sign-extended back to the original width. This includes careful
//         handling of potential overflows for signed additions.
//
// 6.  **Narrowing `Multiply` Operations (`umul`, `smul`, `umulp`, `smulp`)**:
//     *   **Result Wider Than Sum of Operands**: If the declared result width
//         of a multiply operation is greater than the sum of the bit widths of
//         its operands, the multiplication can be performed at the
//         sum-of-operand widths, and the result then extended.
//
//     *   **Operands Wider Than Result**: If the operands are wider than the
//         required result width, they can be narrowed (sliced) before the
//         multiplication, reducing the complexity of the multiplier.
//
//     *   **Extended Operands (Zero-extend/Sign-extend)**: When operands are
//         the results of `zero_ext` or `sign_ext` operations, they can often
//         be narrowed back to their original non-extended width, with the
//         multiplication type adjusted (e.g., `umul` or `smul`) if necessary to
//         maintain correctness.
//
//     *   **Trailing Zeros**: Multiplies where one or both operands have known
//         trailing zeros can be optimized by performing the multiplication on
//         the non-zero bits and concatenating the result with the appropriate
//         number of trailing zeros.
//
//     *   **Partial Product Optimization**: For `umulp`/`smulp` (partial
//         product multiplies), if the two partial products are immediately
//         summed (e.g.,
//         `add(tuple_index(mulp_op, 0), tuple_index(mulp_op, 1))`), the overall
//         operation can be narrowed, and the final sum then extended.
//
// 7.  **Narrowing `ArrayIndex` Operations**:
//     *   **Literal Index Values**: If an index to an `array_index` is a known
//         literal, its bit width can be narrowed to the minimum required to
//         represent the actual array size, saving bits in the index
//         computation.
//
//     *   **Known Zero Index**: If an index is provably zero, it's replaced
//         with a literal zero of appropriate width.
//
//     *   **Known Out-of-Bounds Index**: Similar to
//         `BitSliceSimplificationPass`, if an index is provably out of bounds,
//         it's clamped to the maximum valid index.
//
//     *   **Convert `ArrayIndex` to `Select`**: For `array_index` operations
//         with a small, discrete set of possible index values (based on range
//         analysis), the operation can be converted to a `select` chain, making
//         explicit checks for each possible index value. This can be beneficial
//         for small arrays by removing complex indexing logic.
//
// 8.  **Narrowing `Decode` Operations**:
//     *   **Leading Zeros in Index**: If the index of a `decode` operation has
//         leading zeros, the index can be sliced to remove them, and the
//         `decode` performed on the narrower index, with the result
//         zero-extended if needed.
//
//     *   **Zero Index**: A `decode` with a provably zero index is replaced by
//         a literal one, as `decode(0)` always results in a one-hot encoding
//         with the least significant bit set.
//
// The `NarrowingPass` is typically run repeatedly within an optimization
// pipeline until a fixed point is reached. This iterative process is crucial
// for achieving maximal bit width reduction across the entire IR, as narrowing
// one node can often enable further narrowing of its consumers or producers.
class NarrowingPass : public OptimizationFunctionBasePass {
 public:
  enum class AnalysisType : uint8_t {
    kTernary,
    kRange,
    // Use the select context of instructions when calculating ranges.
    kRangeWithContext,
    // Use the select context controlled by the optimization options.
    kRangeWithOptionalContext,
  };
  static constexpr std::string_view kName = "narrow";
  explicit NarrowingPass(AnalysisType analysis = AnalysisType::kRange)
      : OptimizationFunctionBasePass(ConfiguredName(analysis), "Narrowing"),
        analysis_(analysis) {}
  ~NarrowingPass() override = default;

 protected:
  AnalysisType analysis_;

  AnalysisType RealAnalysis(const OptimizationPassOptions& options) const;
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;

 private:
  static std::string_view ConfiguredName(AnalysisType analysis) {
    switch (analysis) {
      case AnalysisType::kTernary:
        return "narrow(Ternary)";
      case AnalysisType::kRange:
        return "narrow(Range)";
      case AnalysisType::kRangeWithContext:
        return "narrow(Context)";
      case AnalysisType::kRangeWithOptionalContext:
        return "narrow(OptionalContext)";
    }
  }
};

std::ostream& operator<<(std::ostream& os, NarrowingPass::AnalysisType a);

}  // namespace xls

#endif  // XLS_PASSES_NARROWING_PASS_H_
