// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_CONCAT_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_CONCAT_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which simplifies concats. This includes removing single-operand concats,
// flattening trees of dependent concats, and others.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ConcatSimplificationPass` is an optimization pass in XLS that focuses
// on simplifying `concat` operations in the Intermediate Representation (IR).
// Concatenation is a fundamental operation in hardware description languages,
// used to combine smaller bit vectors into larger ones. This pass aims to
// reduce the complexity, improve the readability, and optimize the hardware
// implementation of `concat` operations and related patterns by applying
// various rewrite rules.
//
// The pass operates by iteratively processing `concat` nodes using a worklist
// algorithm. This ensures that newly created or modified `concat` nodes are
// re-evaluated for further simplification. Additionally, it performs a second
// pass over other operations that interact with `concat`s to identify further
// optimization opportunities.
//
// Here's a detailed breakdown of the key optimizations performed:
//
// 1.  **Removing Trivial Concats (Single Operand)**:
//     If a `concat` operation has only one operand, it effectively acts as an
//     identity operation. The pass replaces such a `concat` with its single
//     operand, eliminating the redundant node and simplifying the dataflow.
//
//     ```
//     concat(x) => x
//     ```
//
//
// 2.  **Flattening Trees of Concats**:
//     Nested `concat` operations (e.g., `concat(A, concat(B, C))`) are
//     flattened into a single `concat` operation with all the original leaf
//     operands. This reduces the depth of the IR graph, simplifies subsequent
//     analyses, and can lead to more compact hardware.
//
//     ```
//     concat(a, b, concat(c, concat(d, e))) => concat(a, b, c, d, e)
//     ```
//
//
// 3.  **Merging Consecutive Literal Operands**:
//     If a `concat` operation has two or more consecutive operands that are
//     known literals, these literals are merged into a single, wider literal.
//     This reduces both the number of operands to the `concat` and the total
//     number of literal nodes in the graph.
//
//     ```
//     concat(literal_1, literal_2, x, literal_3, literal_4)
//     // => concat(merged_literal_1_2, x, merged_literal_3_4)
//     ```
//
//
// 4.  **Eliminating Zero-Bit Operands**:
//     Any operand to a `concat` that has a bit width of zero (e.g., `bits[0]`)
//     is functionally a no-op. The pass identifies and removes such operands
//     from the `concat`'s operand list, cleaning up the IR.
//
// 5.  **Hoisting `Reverse` Operations above `Concat`s**:
//     If a `concat` operation is used by a single `reverse` operation (and has
//     no other non-reducible users), the `reverse` operation is "hoisted" above
//     the `concat`. This means the `reverse` is applied individually to each
//     operand of the `concat`, and then those reversed operands are
//     concatenated in reverse order. This can expose more optimization
//     opportunities for the individual `reverse` operations.
//
//     ```
//     reverse(concat(a, b, c)) => concat(reverse(c), reverse(b), reverse(a))
//     ```
//
//
// 6.  **Merging Consecutive Bit Slices**:
//     If a `concat` has consecutive operands that are `bit_slice` operations
//     from the *same source node* and slice *consecutive bits*, these two
//     `bit_slice`s are merged into a single, wider `bit_slice`. This simplifies
//     the slicing logic and reduces the number of intermediate nodes.
//
//     ```
//     concat(bit_slice(x, start=2, width=2), bit_slice(x, start=0, width=2))
//     // => concat(bit_slice(x, start=0, width=4))
//     ```
//
//
// 7.  **Hoisting Bitwise Operations above `Concat`s
//     (`TryHoistBitWiseOperation`)**: If a bitwise operation (e.g., `and`,
//     `or`, `xor`) has all its operands as `concat` operations, the bitwise
//     operation can be "hoisted" above the concatenations. This means the
//     operands of the original `concat`s are sliced into corresponding bit
//     ranges, the bitwise operation is applied to these slices, and then the
//     results are re-concatenated. This often exposes opportunities for common
//     subexpression elimination or further simplification on the smaller
//     bitwise operations.
//
//     ```
//     xor(concat(a, b), concat(c, d)) => concat(xor(a, c), xor(b, d))
//     ```
//
//
// 8.  **Hoisting Bitwise Operations with Constants above `Concat`s
//     (`TryHoistBitWiseWithConstant`)**: This is a specialized version of
//     hoisting bitwise operations. If a binary bitwise operation has one
//     constant operand and one `concat` operand, the bitwise operation can be
//     distributed across the `concat`'s operands and combined with
//     corresponding slices of the constant. This effectively narrows the
//     operations.
//
//     ```
//     // Given x: bits[8], y: bits[8]
//     and(0b10101011, concat(x, y))
//     // => concat(and(x, 0b1010), and(y, 0b1011))
//     ```
//
//
// 9.  **Narrowing and Hoisting Bitwise Operations
//     (`TryNarrowAndHoistBitWiseOperation`)**: This optimization specifically
//     targets scenarios where a `concat` is used as an operand to a bitwise
//     operation (like `and`, `or`, `xor`), and the `concat` itself has one
//     constant operand (0 or all ones) and one variable operand. The goal is
//     to narrow the bitwise operation to only the "interesting" bits (those
//     from the variable operand) and hoist it above the `concat`. This can
//     significantly reduce the bit width of the affected operations.
//
//     ```
//     // Given x: bits[10], b: bits[4]
//     or(x, concat(0b111111, b)) // concat(6 ones, b)
//     // => concat(0b111111, or(bit_slice(x, 0, 4), b))
//     ```
//
//
// 10. **Bypassing Reduction of Concatenation
//     (`TryBypassReductionOfConcatenation`)**: If a bitwise reduction
//     operation (e.g., `or_reduce`, `and_reduce`, `xor_reduce`) is applied to
//     a `concat` operation, it can be bypassed. The reduction is distributed
//     to each operand of the `concat`, and then a new non-reductive bitwise
//     operation (e.g., `or`, `and`, `xor`) combines the results. This can
//     simplify complex reduction paths.
//
//     ```
//     or_reduce(concat(a, b)) => or(or_reduce(a), or_reduce(b))
//     ```
//
//
// 11. **Distributing Reducible Operations
//     (`TryDistributeReducibleOperation`)**: This optimization distributes
//     `eq` and `ne` operations across `concat`s. If `eq(concat(A, B), C)` is
//     found, it's transformed into `and(eq(A, slice(C)), eq(B, slice(C)))`.
//     For `ne`, the transformation uses an `or` of `ne`s. This helps "see
//     through" concatenations to simplify comparisons with composite values.
//
//     ```
//     // Given x: bits[5], y: bits[10]
//     eq(concat(x, y), literal(0, bits=15))
//     // => and(eq(x, literal(0, bits=5)), eq(y, literal(0, bits=10)))
//     ```
//
//
// The `ConcatSimplificationPass` is a powerful and multi-faceted pass that
// significantly contributes to the overall quality of the generated hardware by
// producing a more compact, efficient, and readable IR.
class ConcatSimplificationPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "concat_simp";
  explicit ConcatSimplificationPass()
      : OptimizationFunctionBasePass(kName, "Concat simplification") {}
  ~ConcatSimplificationPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_CONCAT_SIMPLIFICATION_PASS_H_
