// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_INLINING_PASS_H_
#define XLS_PASSES_INLINING_PASS_H_

#include <string_view>

#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "xls/ir/nodes.h"
#include "xls/ir/package.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Inlines a package toward the `top` function/proc.
//
// If `full` then all functions are inlined into the `top`.
//
// If `leaf` then only leaf functions are inlined into their caller. This allows
// other passes to optimize on smaller graphs.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `InliningPass` is a fundamental optimization pass in XLS that transforms
// `invoke` operations (function calls) by replacing them with the actual body
// of the invoked function. This is a powerful compiler optimization that
// eliminates the overhead associated with function calls, exposes more
// optimization opportunities for subsequent passes (such as Common
// Subexpression Elimination or Dead Code Elimination), and can ultimately lead
// to more monolithic and potentially faster hardware designs.
//
// The pass supports two primary modes of inlining, controlled by the
// `InlineDepth` enum:
//
// 1.  **`kFull` (Full Inlining)**:
//     In this mode, the pass attempts to recursively inline all functions into
//     their callers, working its way up the call graph towards the top-level
//     function or proc. The process continues until only the top-level entity
//     remains (or until it encounters foreign functions, which are external
//     hardware blocks and cannot be inlined).
//
// 2.  **`kLeafOnly` (Leaf-Only Inlining)**:
//     This mode selectively inlines only "leaf" functionsâ€”those that do not
//     call any other functions themselves (or only call foreign functions).
//     This can be beneficial when other optimization passes are more effective
//     on smaller, already-inlined graphs, or when fine-grained control over
//     inlining is desired. It also inlines functions that have a single caller
//     and only call leaf functions, or another function which is already being
//     inlined.
//
// **How it Works**:
//
// 1.  **Call Graph Analysis**: The pass initially constructs a `CallGraph` for
//     the entire package. This graph precisely depicts the calling
//     relationships between different functions.
//
// 2.  **Inlining Order**: Functions are processed for inlining in a post-order
//     traversal of the call graph (i.e., leaf functions are processed first).
//     This strategic order ensures that when a function `Foo` is inlined into
//     its callers, any functions called by `Foo` have already been inlined (if
//     eligible), thereby preventing redundant work and simplifying the overall
//     inlining process.
//
// 3.  **`InlineInvoke` Function**: This template function is responsible for
//     the actual inlining of a single `invoke` operation:
//     *   **Operand Mapping**: It establishes a mapping from the parameters of
//         the invoked function to the corresponding actual arguments (operands)
//         of the `invoke` instruction.
//
//     *   **Node Cloning and Rewiring**: It traverses the body of the invoked
//         function in topological order. For each node within the invoked
//         function, it clones the node into the caller function. During this
//         cloning process, any references to parameters of the invoked function
//         are transparently replaced with their corresponding arguments from
//         the `invoke` operation.
//
//     *   **Source Location Propagation**: Source location information is
//         meticulously merged from the original nodes and the `invoke`
//         instruction to maintain traceability and debugging information.
//
//     *   **Name Propagation**: Node names are propagated intelligently to
//         preserve readability after inlining:
//         *   If the invoked function's parameter name is a prefix of a node's
//             name, and the corresponding `invoke` operand also has an assigned
//             name, the inlined node's name is derived by substituting the
//             parameter name with the operand's name.
//
//         *   If the `invoke` instruction itself has an assigned name, the
//             return value of the inlined function inherits that name.
//
//         *   If neither of the above applies, and the inlined node had a name
//             derived from a parameter, that derived name is used.
//
//     *   **Cover and Assert Label Deduplication**: For `cover` and `assert`
//         operations, if inlining would result in multiple instances with
//         identical labels, the labels are modified to include a unique prefix
//         (derived from the caller function and a unique `inline_count`) to
//         ensure uniqueness in the generated Verilog.
//
//     *   **Replacement and Removal**: Finally, the original `invoke`
//         instruction is replaced by the return value of the inlined function
//         (or a tuple if the function returns multiple values), and the
//         `invoke` node itself is removed from the caller function as it is no
//         longer needed.
//
// By aggressively inlining functions, `InliningPass` creates larger, flatter
// graphs that provide subsequent optimization passes with a broader scope for
// analysis and transformation, ultimately leading to more optimized hardware
// designs.
//
// Example (Full Inlining):
// Consider a `caller` function that invokes a `callee` function:
//
//
// ```
// // Original IR
// package some_package
//
// fn callee(x: bits[32], y: bits[32]) -> bits[32] {
//   ret add.1: bits[32] = add(x, y)
// }
//
// fn caller() -> bits[32] {
//   literal.2: bits[32] = literal(value=2)
//   ret invoke.3: bits[32] = invoke(literal.2, literal.2, to_apply=callee)
// }
// ```
//
//
// After `InliningPass` (with `kFull` depth), the `invoke.3` in `caller` would
// be replaced by the body of `callee`, resulting in:
//
//
// ```
// // Optimized IR (after Inlining and a subsequent DCE pass)
// package some_package
//
// fn caller() -> bits[32] {
//   literal.2: bits[32] = literal(value=2)
//   // callee's body is inlined here
//   add.1: bits[32] = add(literal.2, literal.2)
//   ret add.1
// }
// ```
//
// This effectively eliminates the function call overhead and exposes the
// `add.1` to further optimizations within the `caller` function. For
// `kLeafOnly`, `callee` would be inlined into `caller`, but if `caller` itself
// was called by another function, that outer function would not have `caller`
// inlined into it. If `caller` called another function `callee2` which itself
// called a third function `callee3` then `callee3` would be inlined into
// `callee2` but `callee2` would not be inlined into `caller`.
class InliningPass : public OptimizationPass {
 public:
  enum class InlineDepth {
    kFull,
    kLeafOnly,
  };
  static constexpr std::string_view kName = "inlining";
  explicit InliningPass(InlineDepth depth = InlineDepth::kFull)
      : OptimizationPass(ConfiguredName(depth), "Inlines invocations"),
        depth_(depth) {}

  // Inline a single invoke instruction. Provided for test and utility
  // (ir_minimizer) use.
  // Because this is only for ir-minimizer use it allows the inlined function to
  // have invokes in the function code.
  static absl::Status InlineOneInvoke(Invoke* invoke);

 protected:
  absl::StatusOr<bool> RunInternal(Package* p,
                                   const OptimizationPassOptions& options,
                                   PassResults* results,
                                   OptimizationContext& context) const override;
  InlineDepth depth_;

 private:
  static std::string_view ConfiguredName(InlineDepth depth) {
    switch (depth) {
      case InlineDepth::kFull:
        return "inlining";
      case InlineDepth::kLeafOnly:
        return "leaf-inlining";
    }
  }
};

}  // namespace xls

#endif  // XLS_PASSES_INLINING_PASS_H_
