// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#ifndef XLS_PASSES_TABLE_SWITCH_PASS_H_
#define XLS_PASSES_TABLE_SWITCH_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// TableSwitchPass converts chains of Select nodes into ArrayIndex ops.
// These chains have the form:
// sel.(N)(eq.X, literal.A, literal.B)
// sel.(N+1)(eq.Y, sel.(N), literal.C)
// sel.(N+2)(eq.Z, sel.(N+1), literal.D)
// And so on. In these chains, eq.X, eq.Y, and eq.Z must all be comparisons of
// the same value against different literals.
//
// Current limitations:
//  - Either the start or end index in the chain must be 0.
//  - The increment between indices must be positive or negative 1.
//  - There can be no "gaps" between indices.
//  - The Select ops have to be binary (i.e., selecting between only two cases).
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `TableSwitchPass` is an optimization pass in XLS that transforms specific
// chains of `select` (or `priority_select`) nodes into more efficient
// `array_index` operations. This is a crucial optimization for hardware
// synthesis, as it converts a series of conditional branches into a direct
// table lookup mechanism, which can be implemented more compactly and with
// lower delay in hardware, especially when the conditions are based on
// comparing a single value against a set of constants.
//
// The pass specifically targets `select` chains that conform to the following
// pattern:
//
// *   **Chained `Select` or `PrioritySelect` Operations**: The pass identifies
//     sequences of `select` or `priority_select` nodes where:
//     *   The selector of each `select` is a comparison (e.g., `eq` or `ne`)
//         of a common "index" value against a distinct literal "key."
//     *   The result of one `select` operation feeds into a case (or the
//         default value) of the next `select` operation in the chain, creating
//         a cascaded lookup structure.
//     *   The "value" chosen by each matching comparison in the chain is a
//         literal.
//
// The pass then conceptually constructs a lookup table (represented as an array
// of literal values) where the common "index" value from the `select` chain is
// used to directly access an element in this array, and the elements of the
// array are the "value" literals from the original `select` chain.
//
// **How it Works**:
//
// 1.  **`MatchLinks`**: This is the core pattern-matching function. It
//     recursively traverses the `select` chain, extracting essential
//     information about each "link" (each `select` node) in the chain. This
//     information includes the common `index` node, the literal `key` it's
//     compared against, the `value` literal chosen if the comparison is true,
//     and the `next` node in the chain if the comparison is false. It also
//     handles `PrioritySelect` operations where the selector is a `concat` of
//     single-bit selectors, identifying individual bits of the selector as
//     corresponding to specific cases.
//
// 2.  **`LinksToTable`**: Once a complete chain of `Link`s is identified, this
//     function attempts to convert it into a `Value` that represents a literal
//     array. It maps the `key`s from the `Link`s to corresponding indices in
//     this array, with the associated `value` literals becoming the array
//     elements. The function intelligently handles situations where the index
//     space is not fully covered by explicit `Link`s, filling in the gaps with
//     the "else" value (the default or fall-through value from the original
//     chain).
//
// 3.  **Replacement**: If `LinksToTable` successfully generates a valid
//     literal array, the entire `select` chain (or the part of a
//     `priority_select` chain that can be converted) is replaced by an
//     `array_index` operation. The index for this `array_index` is the common
//     `index` node from the original `select` chain, and the array being
//     indexed is the newly created literal array.
//
// **Current Limitations (as described in the code)**:
//
// *   Either the start or end index in the chain must be 0.
// *   The increment between indices must be positive or negative 1.
// *   There can be no "gaps" between indices.
// *   The `Select` ops must be binary (i.e., selecting between only two cases).
//
// Example (simplification of a binary tree of `sel` operations performing a
// lookup):
//
//
// ```
// // Original IR snippet
// fn main(index: bits[32]) -> bits[32] {
//   literal.0: bits[32] = literal(value=0)
//   literal.1: bits[32] = literal(value=1)
//   literal.2: bits[32] = literal(value=2)
//   literal.3: bits[32] = literal(value=3)
//   eq.10: bits[1] = eq(index, literal.0)
//   eq.11: bits[1] = eq(index, literal.1)
//   eq.12: bits[1] = eq(index, literal.2)
//   eq.13: bits[1] = eq(index, literal.3)
//   sel.20: bits[32] = sel(eq.10, cases=[literal.0, literal.1])
//   sel.21: bits[32] = sel(eq.11, cases=[sel.20, literal.2])
//   sel.22: bits[32] = sel(eq.12, cases=[sel.21, literal.3])
//   ret sel.23: bits[32] = sel(eq.13, cases=[sel.22, literal.4])
// }
// ```
//
//
// The `TableSwitchPass` would recognize this pattern and convert it into
// (conceptually):
//
//
// ```
// // Optimized IR (simplified)
// fn main(index: bits[32]) -> bits[32] {
//   // ...
//   // Constructed array of values from the selects
//   array_literal: bits[32][5] = literal(value={1, 2, 3, 4, 0}) // Assuming 0
//   is the default/else value
//   ret array_index.new: bits[32] = array_index(array_literal, indices=[index])
// }
// ```
//
// This transformation significantly simplifies the hardware required for such
// lookup-like structures by replacing complex multiplexing logic with a direct
// memory access or a simpler decoder for the array index, leading to improved
// hardware QoR.
class TableSwitchPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "table_switch";
  TableSwitchPass()
      : OptimizationFunctionBasePass(kName, "Table switch conversion") {}

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_TABLE_SWITCH_PASS_H_
