// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_LUT_CONVERSION_PASS_H_
#define XLS_PASSES_LUT_CONVERSION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which opportunistically converts nodes to lookup tables (selects) where
// we can prove it's beneficial.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `LutConversionPass` is an optimization pass in XLS that intelligently
// converts complex combinational logic into more efficient lookup tables
// (LUTs). These LUTs are represented in the IR as `select` operations. This is
// particularly beneficial for hardware synthesis, especially for FPGA targets
// where LUTs are fundamental configurable logic blocks, capable of implementing
// arbitrary Boolean functions very efficiently within a fixed-size resource.
// The pass aims to improve hardware area and potentially delay by replacing
// complex gate-level logic with a single, equivalent `select` operation.
//
// **How it Works**:
//
// 1.  **Identifying `Select` Operations and Selectors**: The pass iterates
//     through nodes in reverse topological order, focusing on `select`
//     operations. For each `select`, it analyzes its `selector` input.
//
// 2.  **Minimum Cut Analysis for Selector**: The core of this pass involves a
//     "minimum cut" analysis performed on the `selector` node, facilitated by
//     `DataflowGraphAnalysis`. This analysis identifies the minimal set of
//     ancestor nodes (`min_cut`) of the `selector` that, when their values are
//     known, completely determine the value of the `selector`.
//     *   A crucial parameter, `max_unknown_bits`, is used with
//         `GetMinCutFor`. This sets an upper limit on the number of "unknown"
//         bits (bits whose values are not fixed to 0 or 1) allowed in the
//         `min_cut`. If the number of unknown bits exceeds this limit, the cut
//         is considered too large to be efficiently represented as a LUT, and
//         the optimization is not performed. This prevents the generation of
//         excessively large LUTs that might consume too many hardware
//         resources.
//
// 3.  **Constructing the Lookup Table (Truth Table)**: If a sufficiently small
//     `min_cut` is found, the pass then constructs a conceptual lookup table.
//     This involves:
//     *   **Enumerating all `min_cut` values**: It systematically iterates
//         through all possible combinations of values that the nodes in the
//         `min_cut` can take.
//
//     *   **Simulating the `selector`**: For each combination of `min_cut`
//         values, it uses an `IrInterpreter` to simulate the sub-graph that
//         computes the `selector` and determines its resulting value.
//
//     *   **Mapping Selector Values to Case Results**: With the `selector`
//         values determined for each `min_cut` combination, the pass then knows
//         precisely which case of the original `select` operation would be
//         chosen. It fetches the corresponding output value from that case (or
//         the default value of the original `select`). This effectively creates
//         a mapping from each `min_cut` combination to the final output value
//         of the original `select` operation.
//
// 4.  **Replacing with a New `Select` (LUT)**: Finally, the original `select`
//     operation is replaced by a new `select` operation that directly
//     implements the lookup table:
//     *   **New Selector**: A new selector for this LUT is constructed by
//         concatenating the "unknown" bits of the `min_cut` nodes. These are
//         the bits that actually differentiate the behavior of the `selector`.
//
//     *   **New Cases**: The cases of the new `select` are the computed output
//         values (from step 3) for each possible combination of the new
//         selector bits. The order of these cases is determined by the
//         enumeration of `min_cut` values.
//
// **Benefits**:
//
// *   **Area Optimization**: By replacing complex gate-level logic with
//     efficient LUT structures, this pass can significantly reduce the overall
//     hardware area, especially for FPGA-based designs.
//
// *   **Performance Improvement**: LUTs typically have predictable and often
//     low delay characteristics, which can lead to improved timing performance
//     for the converted logic.
//
// *   **IR Simplification**: Can simplify complex logical structures into a
//     single `select` node, making the IR more abstract and easier to manage
//     for subsequent optimization stages.
//
// Example:
// Consider a `select` operation whose `selector` is derived from a complex
// arithmetic expression of `x`, for instance, `selector = add(x, x)`
// (effectively `2*x`). The cases of the `select` are literals.
//
//
// ```
// // Original IR snippet
// fn simple_select(x: bits[3]) -> bits[3] {
//   literal.0: bits[3] = literal(value=0)
//   literal.1: bits[3] = literal(value=1)
//   literal.2: bits[3] = literal(value=2)
//   literal.3: bits[3] = literal(value=3)
//   doubled_x: bits[3] = add(x, x) // Selector for the final select
//   selector: bits[3] = doubled_x
//   ret result: bits[3] =
//               sel(selector,
//                   cases=[literal.0, literal.1, literal.2, literal.3],
//                   default=x)
// }
// ```
//
//
// The `LutConversionPass` would identify `selector` (which is `doubled_x`) as a
// target. It would perform a minimum cut on `selector` and find that `x` is the
// minimal set of inputs. It would then enumerate all possible values for `x` (0
// to 7 for `bits[3]`), compute the `selector` value and the `select` result
// for each `x`, creating a new `select` with `x` as its selector and the
// computed results as cases:
//
//
// ```
// // Optimized IR (simplified after LutConversionPass and a DCE pass)
// fn simple_select(x: bits[3]) -> bits[3] {
//   // ... (literals 0-3 remain if still used elsewhere, otherwise removed by
//   //     DCE)
//   ret result: bits[3] = sel(x, cases=[
//     literal(value=0), // x=0, doubled_x=0 -> cases[0]
//     literal(value=2), // x=1, doubled_x=2 -> cases[2]
//     x,                // x=2, doubled_x=4 -> default
//     x,                // x=3, doubled_x=6 -> default
//     literal(value=0), // x=4, doubled_x=0 -> cases[0]
//     literal(value=2), // x=5, doubled_x=2 -> cases[2]
//     x,                // x=6, doubled_x=4 -> default
//     x                 // x=7, doubled_x=6 -> default
//   ]) // Cases derived from evaluating the original select for each possible x
// }
// ```
//
// The resulting `select` directly maps `x` to the output, effectively
// converting the `add` and original `select` into a single, more efficient LUT
// implementation.
class LutConversionPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "lut_conversion";
  explicit LutConversionPass()
      : OptimizationFunctionBasePass(kName, "LUT Conversion") {}
  ~LutConversionPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_LUT_CONVERSION_PASS_H_
