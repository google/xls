// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_MAP_INLINING_PASS_H_
#define XLS_PASSES_MAP_INLINING_PASS_H_

#include <string_view>

#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/ir/nodes.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// A pass to convert map nodes to in-line Invoke nodes. We don't directly lower
// maps to Verilog.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `MapInliningPass` is an optimization pass that transforms `map`
// operations in the XLS IR into a series of explicit `invoke` operations. In
// the XLS compilation flow, `map` operations represent a high-level construct
// that applies a function to each element of an array. Since target hardware
// description languages like Verilog do not directly support `map` operations,
// this pass is crucial for lowering this abstraction to a more
// hardware-friendly representation.
//
// The pass operates as follows:
//
// 1.  **Identification of `map` nodes**: It traverses the IR to identify all
//     `map` instructions.
//
// 2.  **Transformation**: For each `map` instruction, it replaces the `map`
//     node with an `array` operation. This `array` operation is composed of
//     multiple `invoke` operations, where each `invoke` corresponds to one
//     application of the mapped function to an element of the input array.
//
//     *   For an input array of size `N`, the `map` operation
//         `map(input_array, to_apply=map_fn)` is replaced by an `array` of `N`
//         elements.
//
//     *   Each element of this newly constructed `array` is an `invoke`
//         operation.
//
//     *   Each `invoke` operation is explicitly passed a single element from
//         the `input_array` (accessed via `array_index` using a literal index)
//         and applies the `map_fn` to it.
//
// This effectively "unrolls" the `map` operation, making each application of
// the `map_fn` to an array element an explicit operation in the IR. This is
// analogous to how a loop unrolling pass might transform a `counted_for` loop.
//
// Example:
// Consider a `map` operation that applies `map_fn` to an array `a`:
//
//
// ```
// fn map_fn(x: bits[32]) -> bits[16] {
//   ret bit_slice.1: bits[16] = bit_slice(x, start=0, width=16)
// }
//
// fn main(a: bits[32][4]) -> bits[16][4] {
//   ret result: bits[16][4] = map(a, to_apply=map_fn)
// }
// ```
//
//
// After `MapInliningPass`, the `map` operation would be replaced by an `array`
// of four `invoke` operations, each applying `map_fn` to a specific element of
// `a`:
//
//
// ```
// fn map_fn(x: bits[32]) -> bits[16] {
//   ret bit_slice.1: bits[16] = bit_slice(x, start=0, width=16)
// }
//
// fn main(a: bits[32][4]) -> bits[16][4] {
//   array_index.0: bits[32] = array_index(a, indices=[literal(0)])
//   invoke.0: bits[16] = invoke(array_index.0, to_apply=map_fn)
//   array_index.1: bits[32] = array_index(a, indices=[literal(1)])
//   invoke.1: bits[16] = invoke(array_index.1, to_apply=map_fn)
//   array_index.2: bits[32] = array_index(a, indices=[literal(2)])
//   invoke.2: bits[16] = invoke(array_index.2, to_apply=map_fn)
//   array_index.3: bits[32] = array_index(a, indices=[literal(3)])
//   invoke.3: bits[16] = invoke(array_index.3, to_apply=map_fn)
//   ret array.4: bits[16][4] = array(invoke.0, invoke.1, invoke.2, invoke.3)
// }
// ```
//
// This transformation is crucial for enabling the subsequent stages of hardware
// synthesis.
class MapInliningPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "map_inlining";
  MapInliningPass();

  // Inline a single Map instruction. Provided for test and utility
  // (ir_minimizer) use.
  static absl::Status InlineOneMap(Map* map);

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* function, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;

  // Replaces a single Map node with a CountedFor operation.
  absl::Status ReplaceMap(Map* map) const;
};

}  // namespace xls

#endif  // XLS_PASSES_MAP_INLINING_PASS_H_
