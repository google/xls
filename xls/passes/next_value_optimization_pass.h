// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_NEXT_VALUE_OPTIMIZATION_PASS_H_
#define XLS_PASSES_NEXT_VALUE_OPTIMIZATION_PASS_H_

#include <cstdint>
#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/proc.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which tries to optimize `next_value` nodes within a Proc.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// This pass performs several key optimizations to simplify the logic related to
// state updates and expose further opportunities for other passes.
//
// Optimizations include:
//
// 1. **Removing Literal Predicates**: If a `next_value` node has a predicate
//    that evaluates to a constant `false`, the `next_value` operation is dead
//    and thus removed. If the predicate is a constant `true`, the predicate
//    is removed, making the `next_value` unconditional.
//
//    Example (dead next_value):
//
//    ```
//    x: bits[32]
//    next_value(x, value=my_value, predicate=literal(value=0, bits=1))
//    ```
//
//    This `next_value` would be entirely removed, as it will never update `x`.
//
// 2. **Splitting Select-based Values**: When a `next_value` operation's `value`
//    operand is a `select`, `priority_sel`, or `one_hot_sel` operation, this
//    pass can split the single `next_value` into multiple `next_value` nodes.
//    Each new `next_value` corresponds to one of the select's cases, and its
//    predicate is the condition under which that specific case would be chosen.
//    This can lead to more granular control over state updates and enable
//    further optimizations on individual branches.
//
//    Example (splitting a `select`):
//
//    ```
//    x: bits[2]
//    select_val: bits[2] = select(x,
//                                 cases=[literal(2), literal(1)],
//                                 default=literal(3))
//    next_value(x, value=select_val)
//    ```
//
//    This could be transformed into (simplified representation):
//
//    ```
//    next_value(x, value=literal(2), predicate=eq(x, literal(0)))
//    next_value(x, value=literal(1), predicate=eq(x, literal(1)))
//    next_value(x, value=literal(3), predicate=ugt(x, literal(1)))
//    ```
//
//    This splitting is controlled by the `max_split_depth` parameter to prevent
//    excessive IR growth.
//
// 3. **Handling Non-Synthesizable State Elements**: The pass identifies
//    `state-element`s that are marked as non-synthesizable and are performing
//    an identity update. In such cases, it removes the read of the
//    synthesizable version, allowing subsequent passes (like conditional
//    specialization) to more effectively predicate the state read.
//
// For best results, this pass should be run after any transformations that
// modernize old-style `next (...)` lines into explicit `next_value` nodes.
class NextValueOptimizationPass : public OptimizationProcPass {
 public:
  static constexpr std::string_view kName = "next_value_opt";

  static constexpr int64_t kDefaultMaxSplitDepth = 10;
  explicit NextValueOptimizationPass(
      int64_t max_split_depth = kDefaultMaxSplitDepth)
      : OptimizationProcPass(kName, "Next Value Optimization"),
        max_split_depth_(max_split_depth) {}
  ~NextValueOptimizationPass() override = default;

 protected:
  const int64_t max_split_depth_;
  absl::StatusOr<bool> RunOnProcInternal(
      Proc* proc, const OptimizationPassOptions& options, PassResults* results,
      OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_NEXT_VALUE_OPTIMIZATION_PASS_H_
