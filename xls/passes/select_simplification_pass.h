// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_SELECT_SIMPLIFICATION_PASS_H_
#define XLS_PASSES_SELECT_SIMPLIFICATION_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Base class which simplifies selects and one-hot-selects. Example
// optimizations include removing dead arms and eliminating selects with
// constant selectors.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `SelectSimplificationPass` (and its variant
// `SelectRangeSimplificationPass`) is a comprehensive optimization pass in XLS
// designed to simplify `select`, `one_hot_select`, and `priority_select`
// operations within the Intermediate Representation (IR). These operations are
// fundamental for implementing conditional logic in hardware, and their
// efficient representation directly impacts critical hardware metrics like
// area, delay, and power consumption.
//
// The pass employs various advanced analysis techniques, including ternary
// analysis (`LazyTernaryQueryEngine`) and interval/range analysis
// (`PartialInfoQueryEngine`), to identify and apply a wide array of
// simplifications.
//
// The `SelectSimplificationPassBase` class provides common infrastructure for
// these passes, enabling them to share much of the core simplification logic
// while allowing for differences in the depth of analysis. The
// `range_analysis_` flag within `SelectSimplificationPassBase` determines
// whether to use the more exhaustive `PartialInfoQueryEngine` (for
// `SelectRangeSimplificationPass`) or the generally faster
// `LazyTernaryQueryEngine` (for `SelectSimplificationPass`).
//
// Here's a breakdown of the key optimizations performed by these passes:
//
// 1.  **Simplification of `Select` with Constant Selector**:
//     If the `selector` input to a `select` operation is a known constant
//     value, the `select` can be replaced directly by the case corresponding to
//     that constant value (or the default value if the selector is out of the
//     valid case bounds). This completely eliminates the need for multiplexer
//     logic.
//
// 2.  **Simplification of `PrioritySelect` with Known Selector Pattern**:
//     If the `QueryEngine` can determine that a `priority_select`'s selector
//     has a specific, predictable pattern (e.g., it is known to have a `1` at a
//     certain position followed by all zeros), the `priority_select` can be
//     replaced directly by the case corresponding to that known pattern. If the
//     selector is proven to be all zeros, it's replaced by the default value.
//
// 3.  **Three-Way Comparison Simplification (`Select` and `PrioritySelect`)**:
//     This optimization recognizes common patterns of nested `select` or
//     `priority_select` operations that implement a three-way comparison (e.g.,
//     `if (a > b) ... else if (a < b) ... else ...`). It rewrites these
//     structures into a more canonical form, often replacing one of the
//     comparisons with an equality check (`Op::kEq`), which can be cheaper or
//     expose further optimization opportunities. It handles various
//     configurations, including complex concatenated selectors for
//     `priority_select`.
//
// 4.  **Simplification of `OneHotSelect` with Constant Selector**:
//     If the `selector` of a `one_hot_select` is a known constant (typically a
//     bit vector with at most one bit set), the `one_hot_select` can be
//     replaced by a bitwise `OR` of only the cases that are activated by the
//     constant selector. If no bits are set in the selector, it's replaced by a
//     literal zero.
//
// 5.  **`Select` with Identical Cases**:
//     If all cases (and optionally the default value) of a `select` operation
//     are logically identical, the `select` can be replaced directly by that
//     common value.
//
// 6.  **`OneHotSelect` with Identical Cases**:
//     If all cases of a `one_hot_select` are identical, it can be significantly
//     simplified. The original `one_hot_select` is replaced by a binary
//     `select` whose selector is `(original_selector != 0)` and whose cases are
//     `(default_value_of_zero, common_case_value)`. This reduces a potentially
//     wide one-hot selection to a single binary choice.
//
// 7.  **Reordering `Select` Cases (Unary Selector Functions)**:
//     If a `select`'s selector is a simple unary function of another base value
//     (e.g., `x + 1`, `x * 2`, `-x`), the `select` can be rewritten such that
//     the base value (`x`) becomes its new selector, and its cases are
//     reordered to reflect the transformation caused by the unary function.
//     This can simplify the selector's computation.
//
// 8.  **Decomposing Tuple-Typed `Select`s**:
//     If a `select`, `one_hot_select`, or `priority_select` operates on
//     tuple-typed cases and produces a tuple-typed output, it can be decomposed
//     into a `tuple` of individual `select` operations. Each new `select`
//     operates on a specific element of the tuple, potentially breaking down
//     complex wide-data multiplexers into narrower ones, which often leads to
//     better hardware utilization.
//
// 9.  **Commoning Equivalent Cases in `OneHotSelect` and `PrioritySelect`**:
//     *   For `OneHotSelect`: If multiple cases are logically identical, their
//         corresponding selector bits are OR-reduced together, and the common
//         case is used only once in the new `one_hot_select`, reducing the
//         number of cases and narrowing the selector width.
//     *   For `PrioritySelect`: Adjacent cases with identical outputs can be
//         merged by OR-reducing their corresponding selector bits. This reduces
//         the number of cases and simplifies the priority encoder logic.
//
// 10. **Absorbing Inverted 1-bit Selectors**:
//     If a `select` or `priority_select` has a 1-bit selector that is the
//     result of a `not` operation (e.g., `select(not(p), A, B)`), the `not`
//     operation can be absorbed into the `select`. The `select`'s selector
//     becomes `p`, and its true/ false cases are appropriately swapped.
//
// 11. **Decomposing Single-bit, Two-Way `Select`s into ANDs and ORs**:
//     For 1-bit `select`, `priority_select`, and `one_hot_select` operations
//     (with specific conditions for `one_hot_select`), the pass can decompose
//     them into a combination of `and` and `or` gates. For example, `select(S,
//     A, B)` can be transformed into `(S & A) | (!S & B)`. This exposes more
//     fine-grained Boolean logic for further gate-level optimizations.
//
// 12. **`OneHot` to `PrioritySelect` Conversion**:
//     If a `one_hot_select`'s selector is itself a `one_hot` operation, and
//     that inner `one_hot` operation has no other users (making it redundant as
//     a separate entity), the `one_hot_select` can be replaced by an equivalent
//     `priority_select`. This often simplifies the control logic by leveraging
//     the inherent priority encoding.
//
// 13. **Simplification of `OneHot` Operations**:
//     *   **Single-bit Input `kOneHot`**: If a `one_hot` operation takes a
//         single-bit input and produces a 2-bit output (e.g., `x` -> `(not(x),
//         x)`), it can be replaced by a `concat` of the input and its inverse.
//     *   **Mutually Exclusive Input `kOneHot`**: If the input to a `one_hot`
//         operation is known to have at most one bit set, the `one_hot`
//         operation can be replaced by a `concat` of an `eq(input, 0)`
//         comparison and the original input. This is a common pattern for
//         "valid-and-data" signaling.
//     *   **Single Unknown Bit Input `kOneHot`**: If the input to a `kOneHot`
//         operation has exactly one unknown bit (all other bits are known
//         constants), the `one_hot` can be simplified to a `select` on that
//         unknown bit, with its cases being the two possible `one_hot` outputs
//         when the unknown bit is 0 or 1.
//
// 14. **Converting `Select` to Masking (`and`)**:
//     If a `select` (or `one_hot_select`, `priority_select`) has only one
//     non-zero case, and all other cases (or the default value) are known to be
//     zero, it can be simplified to a bitwise `AND` operation. One operand of
//     the `AND` is the non-zero case, and the other is a sign-extended version
//     of the predicate that selects that non-zero case. This replaces a
//     multiplexer with a simpler masking operation.
//
// 15. **Splitting Bit-Based `Select`s (Worklist-driven)**:
//     At higher optimization levels (`SplitsEnabled`), the pass can split
//     `one_hot_select` and `priority_select` operations into smaller ones if it
//     finds runs of bits in their cases that are either all distinct or all
//     non-distinct (meaning they share the same bit source). This is driven by
//     a worklist, allowing breaking down wide multiplexers into smaller,
//     potentially more efficient components, and exposing further optimization
//     opportunities.
//
// The pass is typically run in a fixed-point manner, as each transformation can
// expose new opportunities for other simplifications. The combination of
// various analysis techniques (ternary, range, bit provenance) and a wide
// range of rewrite rules makes `SelectSimplificationPass` a powerful tool for
// optimizing conditional logic in XLS, ultimately leading to more compact and
// performant hardware.
class SelectSimplificationPassBase : public OptimizationFunctionBasePass {
 public:
  ~SelectSimplificationPassBase() override = default;

 protected:
  explicit SelectSimplificationPassBase(std::string_view short_name,
                                        std::string_view name,
                                        bool with_range_analysis = false)
      : OptimizationFunctionBasePass(short_name, name),
        range_analysis_(with_range_analysis) {}

  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;

  bool range_analysis_;
};

// Pass which simplifies selects and one-hot-selects. Example optimizations
// include removing dead arms and eliminating selects with constant selectors.
// Uses ternary analysis to determine possible values.
class SelectSimplificationPass : public SelectSimplificationPassBase {
 public:
  static constexpr std::string_view kName = "select_simp";
  SelectSimplificationPass()
      : SelectSimplificationPassBase(kName, "Select Simplification",
                                     /*with_range_analysis=*/false) {}
  ~SelectSimplificationPass() override = default;
};

// Pass which simplifies selects and one-hot-selects. Example optimizations
// include removing dead arms and eliminating selects with constant selectors.
// Uses range analysis to determine possible values.
class SelectRangeSimplificationPass : public SelectSimplificationPassBase {
 public:
  static constexpr std::string_view kName = "select_range_simp";
  SelectRangeSimplificationPass()
      : SelectSimplificationPassBase(kName, "Select Range Simplification",
                                     /*with_range_analysis=*/true) {}
  ~SelectRangeSimplificationPass() override = default;
};

}  // namespace xls

#endif  // XLS_PASSES_SELECT_SIMPLIFICATION_PASS_H_
