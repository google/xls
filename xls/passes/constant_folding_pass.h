// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef XLS_PASSES_CONSTANT_FOLDING_PASS_H_
#define XLS_PASSES_CONSTANT_FOLDING_PASS_H_

#include <string_view>

#include "absl/status/statusor.h"
#include "xls/ir/function_base.h"
#include "xls/passes/optimization_pass.h"
#include "xls/passes/pass_base.h"

namespace xls {

// Pass which performs constant folding. Every op with only literal operands is
// replaced by a equivalent literal. Runs DCE after constant folding.
//
// Note: What follows was generated by the Gemini LLM. Not human verified.
//
// The `ConstantFoldingPass` is an optimization pass in XLS that performs the
// crucial task of constant folding across the Intermediate Representation (IR).
// Its primary function is to identify and evaluate operations where all
// operands are compile-time constants, and then replace these operations with a
// single `literal` node that represents the computed result. This process
// significantly simplifies the IR, reduces the number of active operations in
// the data path, and ultimately contributes to smaller, faster, and more
// efficient hardware.
//
// The pass operates by traversing the nodes of a function or proc in
// topological order. For each node, it determines if it is "constant foldable"
// based on the following criteria:
//
// 1.  **Not Already a Literal**: The node itself must not already be a
//     `literal` node, as there would be no further simplification.
//
// 2.  **Has Users (or Implicit Use)**: The node must be either consumed by at
//     least one other node, or have an implicit use (e.g., being the return
//     value of a function, a state element of a proc, or an I/O operation).
//     Nodes without users are considered dead code and are typically removed
//     by a subsequent Dead Code Elimination (DCE) pass.
//
// 3.  **Not Token-Typed**: Nodes with a `token` type cannot be folded into a
//     `literal`, as tokens represent ordering constraints rather than data
//     values.
//
// 4.  **Not Side-Effecting (with exception for `gate`)**: Operations that have
//     side effects (e.g., `send`, `receive`) generally cannot be
//     constant-folded, as their execution order and effects are crucial for
//     correctness. An exception is made for `gate` operations, which can be
//     folded if their condition and data inputs are constant, as the `gate`
//     effectively becomes a simple pass-through or a zero.
//
// 5.  **All Operands are Known Constants**: Critically, all of the node's
//     operands must either be `literal` values themselves, or be other nodes
//     whose values are provably constant at compile time (as determined by a
//     `StatelessQueryEngine`).
//
// If a node successfully meets these criteria, the pass proceeds to:
//
// 1.  Collect the `Value` of each of its constant operands.
//
// 2.  Interpret the operation using these constant `Value`s to compute its
//     result.
//
// 3.  Replace the original operation node with a new `literal` node containing
//     the computed `Value`.
//
// After the `ConstantFoldingPass` is applied, a `DeadCodeEliminationPass` is
// typically run to remove any operations that became dead as a result of their
// uses being replaced by literals.
//
// Example:
// Consider a function with an `add` operation whose operands are both literals:
//
//
// ```
// // Original IR
// fn IdenticalLiterals() -> bits[8] {
//   literal.1: bits[8] = literal(value=42)
//   literal.2: bits[8] = literal(value=123)
//   ret add.3: bits[8] = add(literal.1, literal.2)
// }
// ```
//
//
// The `ConstantFoldingPass` would identify `add.3` as constant foldable. It
// would evaluate `42 + 123` to `165` and replace `add.3` with a new literal
// node:
//
//
// ```
// // Optimized IR (after ConstantFolding and a subsequent DCE pass)
// fn IdenticalLiterals() -> bits[8] {
//   ret literal.new: bits[8] = literal(value=165)
// }
// ```
//
//
// This optimization is foundational for many other passes, as it reduces
// complex expressions to their simplest forms, making subsequent analyses and
// transformations more effective.
class ConstantFoldingPass : public OptimizationFunctionBasePass {
 public:
  static constexpr std::string_view kName = "const_fold";
  ConstantFoldingPass()
      : OptimizationFunctionBasePass(kName, "Constant folding") {}
  ~ConstantFoldingPass() override = default;

 protected:
  absl::StatusOr<bool> RunOnFunctionBaseInternal(
      FunctionBase* f, const OptimizationPassOptions& options,
      PassResults* results, OptimizationContext& context) const override;
};

}  // namespace xls

#endif  // XLS_PASSES_CONSTANT_FOLDING_PASS_H_
