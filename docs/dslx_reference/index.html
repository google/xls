


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <link rel="canonical" href="https://google.github.io/xls/dslx_reference/">
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.5.7">
    
    
      
        <title>Reference - XLS: Accelerated HW Synthesis</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.b8ac9624.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#dslx-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://google.github.io/xls/" title="XLS: Accelerated HW Synthesis" class="md-header-nav__button md-logo" aria-label="XLS: Accelerated HW Synthesis">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            XLS: Accelerated HW Synthesis
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Reference
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/google/xls/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://google.github.io/xls/" title="XLS: Accelerated HW Synthesis" class="md-nav__button md-logo" aria-label="XLS: Accelerated HW Synthesis">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    XLS: Accelerated HW Synthesis
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/google/xls/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      IR
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="IR" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        IR
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ir_semantics/" title="Semantics" class="md-nav__link">
      Semantics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../optimizations/" title="Optimizations" class="md-nav__link">
      Optimizations
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-3" type="checkbox" id="nav-2-3">
    
    <label class="md-nav__link" for="nav-2-3">
      Scheduling
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scheduling" data-md-level="2">
      <label class="md-nav__title" for="nav-2-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scheduling
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../scheduling/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../delay_estimation/" title="Delay Estimation" class="md-nav__link">
      Delay Estimation
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ir_visualization/" title="Visualizer" class="md-nav__link">
      Visualizer
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-5" type="checkbox" id="nav-2-5">
    
    <label class="md-nav__link" for="nav-2-5">
      Native JIT
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Native JIT" data-md-level="2">
      <label class="md-nav__title" for="nav-2-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Native JIT
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ir_jit/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../data_layout/" title="Data Layout" class="md-nav__link">
      Data Layout
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../solvers/" title="Formal" class="md-nav__link">
      Formal
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      DSLX
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="DSLX" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        DSLX
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Reference
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2z"/></svg>
        </span>
      </label>
    
    <a href="./" title="Reference" class="md-nav__link md-nav__link--active">
      Reference
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    Overview
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comments" class="md-nav__link">
    Comments
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#identifiers" class="md-nav__link">
    Identifiers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-functions" class="md-nav__link">
    Parametric Functions
  </a>
  
    <nav class="md-nav" aria-label="Parametric Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#explicit-parametric-instantiation" class="md-nav__link">
    Explicit parametric instantiation
  </a>
  
    <nav class="md-nav" aria-label="Explicit parametric instantiation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expression-ambiguity" class="md-nav__link">
    Expression ambiguity
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-calls" class="md-nav__link">
    Function Calls
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#types" class="md-nav__link">
    Types
  </a>
  
    <nav class="md-nav" aria-label="Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bit-type" class="md-nav__link">
    Bit Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum-types" class="md-nav__link">
    Enum Types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuple-type" class="md-nav__link">
    Tuple Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#struct-types" class="md-nav__link">
    Struct Types
  </a>
  
    <nav class="md-nav" aria-label="Struct Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#struct-update-syntax" class="md-nav__link">
    Struct Update Syntax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-structs" class="md-nav__link">
    Parametric Structs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#understanding-nominal-typing" class="md-nav__link">
    Understanding Nominal Typing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-type" class="md-nav__link">
    Array Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-aliases" class="md-nav__link">
    Type Aliases
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-casting" class="md-nav__link">
    Type Casting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-checking-and-inference" class="md-nav__link">
    Type Checking and Inference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-inference-details" class="md-nav__link">
    Type Inference Details
  </a>
  
    <nav class="md-nav" aria-label="Type Inference Details">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#operator-example" class="md-nav__link">
    Operator Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-errors" class="md-nav__link">
    Type errors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-bindings-names-and-the-environment" class="md-nav__link">
    Let Bindings, Names, and the Environment
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#statements" class="md-nav__link">
    Statements
  </a>
  
    <nav class="md-nav" aria-label="Statements">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#imports" class="md-nav__link">
    Imports
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#public-module-members" class="md-nav__link">
    Public module members
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    Const
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#expressions" class="md-nav__link">
    Expressions
  </a>
  
    <nav class="md-nav" aria-label="Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unary-expressions" class="md-nav__link">
    Unary Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-expressions" class="md-nav__link">
    Binary Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparison-expressions" class="md-nav__link">
    Comparison Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat-expression" class="md-nav__link">
    Concat Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#match-expression" class="md-nav__link">
    Match Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-expression" class="md-nav__link">
    let Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ternary-if-expression" class="md-nav__link">
    Ternary If Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterable-expression" class="md-nav__link">
    Iterable Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for-expression" class="md-nav__link">
    for Expression
  </a>
  
    <nav class="md-nav" aria-label="for Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    Blueprint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numerical-conversions-numerical-conversions" class="md-nav__link">
    Numerical Conversions {#numerical-conversions}
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-conversions" class="md-nav__link">
    Array Conversions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit-slice-expressions" class="md-nav__link">
    Bit Slice Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-understanding-parametricity-constraints-and-unification" class="md-nav__link">
    Advanced Understanding: Parametricity, Constraints, and Unification
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operator-precedence" class="md-nav__link">
    Operator Precedence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#builtins" class="md-nav__link">
    Builtins
  </a>
  
    <nav class="md-nav" aria-label="Builtins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clz-ctz" class="md-nav__link">
    clz, ctz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signex" class="md-nav__link">
    signex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rev" class="md-nav__link">
    rev
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_slice_update" class="md-nav__link">
    bit_slice_update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitwise-reduction-builtins" class="md-nav__link">
    Bitwise reduction builtins
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert_eq" class="md-nav__link">
    assert_eq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trace" class="md-nav__link">
    trace!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fail" class="md-nav__link">
    fail!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-and-debugging" class="md-nav__link">
    Testing and Debugging
  </a>
  
    <nav class="md-nav" aria-label="Testing and Debugging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    Unit Tests
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quickcheck" class="md-nav__link">
    QuickCheck
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2" type="checkbox" id="nav-3-2">
    
    <label class="md-nav__link" for="nav-3-2">
      Examples
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Examples" data-md-level="2">
      <label class="md-nav__title" for="nav-3-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Examples
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../dslx_intro_example1/" title="CRC32" class="md-nav__link">
      CRC32
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../fpadd_example/" title="FP adder" class="md-nav__link">
      FP adder
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../dslx_intro_example3/" title="Prefix Scan" class="md-nav__link">
      Prefix Scan
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../fuzzer/" title="Fuzzer" class="md-nav__link">
      Fuzzer
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Code Generation
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Code Generation" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Code Generation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../vast/" title="VAST" class="md-nav__link">
      VAST
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Tools
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Tools" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Tools
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../build_system/" title="Build System" class="md-nav__link">
      Build System
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tools_quick_start/" title="Quick Start" class="md-nav__link">
      Quick Start
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tools/" title="Listing" class="md-nav__link">
      Listing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../interpreters/" title="Interpreters" class="md-nav__link">
      Interpreters
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      Development
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Development" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Development
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../contributing/" title="Contributing" class="md-nav__link">
      Contributing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../xls_style/" title="Style Guide" class="md-nav__link">
      Style Guide
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../adding_ir_operation/" title="Adding a new IR operation" class="md-nav__link">
      Adding a new IR operation
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    Overview
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comments" class="md-nav__link">
    Comments
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#identifiers" class="md-nav__link">
    Identifiers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-functions" class="md-nav__link">
    Parametric Functions
  </a>
  
    <nav class="md-nav" aria-label="Parametric Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#explicit-parametric-instantiation" class="md-nav__link">
    Explicit parametric instantiation
  </a>
  
    <nav class="md-nav" aria-label="Explicit parametric instantiation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expression-ambiguity" class="md-nav__link">
    Expression ambiguity
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-calls" class="md-nav__link">
    Function Calls
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#types" class="md-nav__link">
    Types
  </a>
  
    <nav class="md-nav" aria-label="Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bit-type" class="md-nav__link">
    Bit Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum-types" class="md-nav__link">
    Enum Types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuple-type" class="md-nav__link">
    Tuple Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#struct-types" class="md-nav__link">
    Struct Types
  </a>
  
    <nav class="md-nav" aria-label="Struct Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#struct-update-syntax" class="md-nav__link">
    Struct Update Syntax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-structs" class="md-nav__link">
    Parametric Structs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#understanding-nominal-typing" class="md-nav__link">
    Understanding Nominal Typing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-type" class="md-nav__link">
    Array Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-aliases" class="md-nav__link">
    Type Aliases
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-casting" class="md-nav__link">
    Type Casting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-checking-and-inference" class="md-nav__link">
    Type Checking and Inference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-inference-details" class="md-nav__link">
    Type Inference Details
  </a>
  
    <nav class="md-nav" aria-label="Type Inference Details">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#operator-example" class="md-nav__link">
    Operator Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-errors" class="md-nav__link">
    Type errors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-bindings-names-and-the-environment" class="md-nav__link">
    Let Bindings, Names, and the Environment
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#statements" class="md-nav__link">
    Statements
  </a>
  
    <nav class="md-nav" aria-label="Statements">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#imports" class="md-nav__link">
    Imports
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#public-module-members" class="md-nav__link">
    Public module members
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    Const
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#expressions" class="md-nav__link">
    Expressions
  </a>
  
    <nav class="md-nav" aria-label="Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unary-expressions" class="md-nav__link">
    Unary Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-expressions" class="md-nav__link">
    Binary Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparison-expressions" class="md-nav__link">
    Comparison Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat-expression" class="md-nav__link">
    Concat Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#match-expression" class="md-nav__link">
    Match Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-expression" class="md-nav__link">
    let Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ternary-if-expression" class="md-nav__link">
    Ternary If Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterable-expression" class="md-nav__link">
    Iterable Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for-expression" class="md-nav__link">
    for Expression
  </a>
  
    <nav class="md-nav" aria-label="for Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    Blueprint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numerical-conversions-numerical-conversions" class="md-nav__link">
    Numerical Conversions {#numerical-conversions}
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-conversions" class="md-nav__link">
    Array Conversions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit-slice-expressions" class="md-nav__link">
    Bit Slice Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-understanding-parametricity-constraints-and-unification" class="md-nav__link">
    Advanced Understanding: Parametricity, Constraints, and Unification
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operator-precedence" class="md-nav__link">
    Operator Precedence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#builtins" class="md-nav__link">
    Builtins
  </a>
  
    <nav class="md-nav" aria-label="Builtins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clz-ctz" class="md-nav__link">
    clz, ctz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signex" class="md-nav__link">
    signex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rev" class="md-nav__link">
    rev
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_slice_update" class="md-nav__link">
    bit_slice_update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitwise-reduction-builtins" class="md-nav__link">
    Bitwise reduction builtins
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert_eq" class="md-nav__link">
    assert_eq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trace" class="md-nav__link">
    trace!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fail" class="md-nav__link">
    fail!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-and-debugging" class="md-nav__link">
    Testing and Debugging
  </a>
  
    <nav class="md-nav" aria-label="Testing and Debugging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    Unit Tests
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quickcheck" class="md-nav__link">
    QuickCheck
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/google/xls/tree/main/docs_src/dslx_reference.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <h1 id="dslx-reference">DSLX Reference</h1>
<h3 id="overview">Overview</h3>
<p>DSLX is a domain specific, dataflow-oriented functional language used to build
hardware that can also run effectively as host software. Within the XLS project,
DSLX is also referred to as "the DSL". The DSL targets the XLS compiler (via
conversion to XLS IR) to enable flows for FPGAs and ASICs.</p>
<p>DSLX mimics Rust, while being an immutable expression-based dataflow DSL with
hardware-oriented features; e.g. arbitrary bitwidths, entirely fixed size
objects, fully analyzeable call graph, etc. To avoid arbitrary new
syntax/semantics choices the DSL mimics Rust where it is reasonably possible;
for example, integer conversions all follow the same semantics as Rust.</p>
<p>Note: There are <em>some</em> unnecessary differences today from Rust syntax due to
early experimentation, but they are quickly being removed to converge on Rust
syntax.</p>
<p>Note that other frontends to XLS core functionality will become available in the
future; e.g. <a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc">xlscc</a>, for users
familiar with the C++-and-pragma style of HLS computation. XLS team develops the
DSL as part of the XLS project because we believe it can offer significant
advantages over the C++-with-pragmas approach.</p>
<p>Dataflow DSLs are a good fit for describing hardware, compared to languages
whose design assumes
<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">von Neumann style computation</a>
(global mutable state, sequential mutation by a sequential thread of control).
Using a Domain Specific Language (DSL) provides a more hardware-oriented
representation of a given computation that matches XLS compiler (IR) constructs
closely. The DSL also allows an exploration of HLS without being encumbered by
C++ language or compiler limitations such as non-portable pragmas, magic macros,
or semantically important syntactic conventions. The language is still
experimental and likely to change, but it is already useful for experimentation
and exploration.</p>
<p>This document provides a reference for DSLX, mostly by example. After perusing
it and learning about the language features, we recommend exploring the
following, detailed examples to learn how the language features are put to
action:</p>
<ol>
<li>
<p><a href="../dslx_intro_example1/">CRC32</a></p>
</li>
<li>
<p><a href="../fpadd_example/">Floating-point addition</a></p>
</li>
<li>
<p><a href="../dslx_intro_example3/">Prefix Sum Computation</a></p>
</li>
</ol>
<p>In this document we use the function to compute a CRC32 checksum to describe
language features. The full code is in
<a href="https://github.com/google/xls/tree/main/xls/examples/dslx_intro/crc32_one_byte.x"><code>examples/dslx_intro/crc32_one_byte.x</code></a>.</p>
<h3 id="comments">Comments</h3>
<p>Just as in languages like Rust/C++, comments start with <code>//</code> and last through
the end of the line.</p>
<h3 id="identifiers">Identifiers</h3>
<p>All identifiers, eg., for function names, parameters, and values, follow the
typical naming rules of other languages. The identifiers can start with a
character or an underscore, and can then contain more characters, underscores,
or numbers. Valid examples are:</p>
<pre><code>a                 // valid
CamelCase         // valid
like_under_scores // valid
__also_ok         // valid
_Ok123_321        // valid
_                 // valid

2ab               // not valid
&amp;ade              // not valid
</code></pre>

<p>However, we suggest the following <strong>DSLX style rules</strong>, which mirror the
<a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust naming conventions</a>.</p>
<ul>
<li>Functions are <code>written_like_this</code></li>
</ul>
<ul>
<li>User-defined data types are <code>NamesLikeThis</code></li>
</ul>
<ul>
<li>Constant bindings are <code>NAMES_LIKE_THIS</code></li>
</ul>
<ul>
<li><code>_</code> is the "black hole" identifier -- a name that you can bind to but should
    never read from, akin to Rust's wildcard pattern match or Python's "unused
    identifier" convention. It should never be referred to in an expression
    except as a "sink".</li>
</ul>
<p>NOTE Since mutable locals are not supported, there is also
<a href="https://github.com/google/xls/issues/212">support for "tick identifiers"</a>,
where a ' character may appear anywhere after the first character of an
identifier to indicate "prime"; e.g. <code>let state' = update(state);</code>. By
convention ticks usually come at the end of an identifier. Since this is not
part of Rust's syntax, it is considered experimental at this time.</p>
<h2 id="functions">Functions</h2>
<p>Function definitions begin with the keyword <code>fn</code>, followed by the function name,
a parameter list to the function in parenthesis, followed by an <code>-&gt;</code> and the
return type of the function. After this, curly braces denote the begin and end
of the function body.</p>
<p>The list of parameters can be empty.</p>
<p>A single input file can contain many functions.</p>
<p>Simple examples:</p>
<pre><code>fn ret3() -&gt; u32 {
   3   // this function always returns 3.
}

fn add1(x: u32) -&gt; u32 {
   x + u32:1   // returns x + 1, but you knew that.
}
</code></pre>

<p>Functions return the result of their last computed expression as their return
value. There are no explicit return statements. By implication, functions return
exactly one expression; they can't return multiple expressions (but this may
change in the future as we migrate towards some Rust semantics).</p>
<p>Tuples should be returned if a function needs to return multiple values.</p>
<h3 id="parameters">Parameters</h3>
<p>Parameters are written as pairs <code>name</code> followed by a colon <code>:</code> followed by the
<code>type</code> of that parameter. Each parameter needs to declare its own type.</p>
<p>Examples:</p>
<pre><code>// a simple parameter x of type u32
   x: u32

// t is a tuple with 2 elements.
//   the 1st element is of type u32
//   the 2nd element is a tuple with 3 elements
//       the 1st element is of type u8
//       the 2nd element is another tuple with 1 element of type u16
//       the 3rd element is of type u8
   t: (u32, (u8, (u16,), u8))
</code></pre>

<h3 id="parametric-functions">Parametric Functions</h3>
<p>DSLX functions can be parameterized in terms of the types of its arguments and
in terms of types derived from other parametric values. For instance:</p>
<pre><code>fn double(n: bits[32]) -&gt; bits[32] {
  n * bits[32]:2
}

fn self_append&lt;A: u32, B: u32 = double(A)&gt;(x: bits[A]) -&gt; bits[B] {
  x++x
}

fn main() -&gt; bits[10] { self_append(bits[5]:1) }
</code></pre>

<p>In <code>self_append(bits[5]:1)</code>, we see that <code>A = 5</code> based off of formal argument
instantiation. Using that value, we can evaluate <code>B = double(A=5)</code>. This derived
expression is analogous to C++'s constexpr â€“ a simple expression that can be
evaluated at that point in compilation.</p>
<p>See
<a href="#advanced-understanding-parametricity-constraints-and-unification">advanced understanding</a>
for more information on parametricity.</p>
<h4 id="explicit-parametric-instantiation">Explicit parametric instantiation</h4>
<p>In some cases, parametric values cannot be inferred from function arguments,
such as in the
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/explicit_parametric_simple.x"><code>explicit_parametric_simple.x</code></a>
test:</p>
<pre><code>fn add_one&lt;E:u32, F:u32, G:u32 = E+F&gt;(lhs: bits[E]) -&gt; bits[G] { ... }
</code></pre>

<p>For this call to instantiable, both <code>E</code> and <code>F</code> must be specified. Since <code>F</code>
can't be inferred from an argument, we must rely on <em>explicit parametrics</em>:</p>
<pre><code>  add_one&lt;u32:1, {u32:2 + u32:3}&gt;(u1:1);
</code></pre>

<p>This invocation will bind <code>1</code> to <code>E</code>, <code>5</code> to <code>F</code>, and <code>6</code> to <code>G</code>. Note the curly
braces around the expression-defined parametric: simple literals and constant
references do not need braces (but they <em>can</em> have them), but any other
expression requires them.</p>
<h5 id="expression-ambiguity">Expression ambiguity</h5>
<p>Without curly braces, explicit parametric expressions could be ambiguous;
consider the following, slightly changed from the previous example:</p>
<pre><code>  add_one&lt;u32:1, u32:2&gt;(u32:3)&gt;(u1:1);
</code></pre>

<p>Is the statement above computing <code>add_one&lt;1, (2 &gt; 3)&gt;(1)</code>, or is it computing
<code>(zero&lt;1, 2&gt;(3)) &gt; 1)</code>? Without additional (and subtle and perhaps surprising)
contextual precedence rules, this would be ambiguous and could lead to a parse
error or, even worse, unexpected behavior.</p>
<p>Fortunately, we can look to Rust for inspiration. Rust's const generics RPF
introduced the <code>{ }</code> syntax for disambiguating just this case in generic
specifications. With this, any expressions present in a parametric specification
must be contained within curly braces, as in the original example.</p>
<p>At present, if the braces are omitted, some unpredictable error will occur. Work
to improve this is tracked in
<a href="https://github.com/google/xls/issues/321">XLS GitHub issue #321</a>.</p>
<h3 id="function-calls">Function Calls</h3>
<p>Function calls are expressions and look and feel just like one would expect from
other languages. For example:</p>
<pre><code>fn callee(x: bits[32], y: bits[32]) -&gt; bits[32] {
  x + y
}
fn caller() -&gt; u32 {
  callee(u32:2, u32:3)
}
</code></pre>

<p>If more than one value should be returned by a function, a tuple type should be
returned.</p>
<h2 id="types">Types</h2>
<h3 id="bit-type">Bit Type</h3>
<p>The most fundamental type in DSLX is a variable length bit type denoted as
<code>bits[n]</code>, where <code>n</code> is a constant. For example:</p>
<pre><code>bits[0]   // possible, but, don't do that

bits[1]   // a single bit
uN[1]     // explicitly noting single bit is unsigned
u1        // convenient shorthand for bits[1]

bits[8]   // an 8-bit datatype, yes, a byte
u8        // convenient shorthand for bits[8]
bits[32]  // a 32-bit datatype
u32       // convenient shorthand for bits[32]
bits[256] // a 256-bit datatype
</code></pre>

<p>DSLX introduces aliases for commonly used types, such as <code>u8</code> for an 8-wide bit
type, or <code>u32</code> for a 32-bit wide bit type. These are defined up to <code>u64</code>.</p>
<p>All <code>u*</code>, <code>uN[*]</code>, and <code>bits[*]</code> types are interpreted as unsigned integers.
Signed integers are specified via <code>s*</code> and <code>sN[*]</code>. Similarly to unsigned
numbers, the <code>s*</code> shorthands are defined up to <code>s64</code>. For example:</p>
<pre><code>sN[0]
s0

sN[1]
s1

sN[64]
s64

sN[256]
</code></pre>

<p>Signed numbers differ in their behavior from unsigned numbers primarily via
operations like comparisons, (variable width) multiplications, and divisions.</p>
<h3 id="enum-types">Enum Types</h3>
<p>DSLX supports enumerations as a way of defining a group of related, scoped,
named constants that do not pollute the module namespace. For example:</p>
<pre><code>enum Opcode : u3 {
  FIRE_THE_MISSILES = 0,
  BE_TIRED = 1,
  TAKE_A_NAP = 2,
}

fn get_my_favorite_opcode() -&gt; Opcode {
  Opcode::FIRE_THE_MISSILES
}
</code></pre>

<p>Note the use of the double-colon to reference the enum value. This code
specifies that the enum behaves like a <code>u3</code>: its storage and extension (via
casting) behavior are defined to be those of a <code>u3</code>. Attempts to define an enum
value outside of the representable <code>u3</code> range will produce a compile time error.</p>
<pre><code>enum Opcode : u3 {
  FOO = 8  // Causes compile time error!
}
</code></pre>

<p>Enums can be compared for equality/inequality, but they do not permit arithmetic
operations, they must be cast to numerical types in order to perform arithmetic:</p>
<pre><code>fn same_opcode(x: Opcode, y: Opcode) -&gt; bool {
  x == y  // ok
}

fn next_in_sequence(x: Opcode, y: Opcode) -&gt; bool {
  // x+1 == y // does not work, arithmetic!
  u3:x + u3:1 == u3:y  // ok, casted first
}
</code></pre>

<p>As mentioned above, casting of enum-values works with the same casting/extension
rules that apply to the underlying enum type definition. For example, this cast
will sign extend because the source type for the enum is signed. (See
<a href="#numerical-conversions">numerical conversions</a> for the full description of
extension/truncation behavior.)</p>
<pre><code>enum MySignedEnum : s3 {
  LOW = -1
  ZERO = 0
  HIGH = 1
}

fn extend_to_32b(x: MySignedEnum) -&gt; u32 {
  u32:x  // Sign-extends because the source type is signed.
}

#![test]
fn extend_to_32b {
  assert_eq(extend_to_32b(MySignedEnum::LOW), u32:-1)
}
</code></pre>

<p>Casting <em>to</em> an enum is also permitted. However, in most cases errors from
invalid casting can only be found at runtime, e.g., in the DSL interpreter or
flagging a fatal error from hardware. Because of that, it is recommended to
avoid such casts as much as possible.</p>
<h3 id="tuple-type">Tuple Type</h3>
<p>A tuple is a fixed-size ordered set, containing elements of heterogeneous types.
Tuples elements can be any type, e.g. bits, arrays, structs, tuples. Tuples may
be empty (an empty tuple is also known as the unit type), or contain one or more
types.</p>
<p>Examples:</p>
<pre><code>() // the unit type, carries no information

let pair = (0b100, 0b101) // a tuple containing two bits elements

// The type of a tuple with 2 elements.
//   the 1st element is of type u32
//   the 2nd element is a tuple with 3 elements
//       the 1st element is of type u8
//       the 2nd element is another tuple with 1 element of type u16
//       the 3rd element is of type u8
(u32, (u8, (u16,), u8)
</code></pre>

<p>To access individual tuple elements use simple indices, starting at 0. For
example, to access the second element of a tuple (index 1):</p>
<pre><code>let t = (u32:2, u8:3);
assert_eq(u8:3, t[1])
</code></pre>

<p>Tuples can be destructured, which provides a convenient syntax to name elements
of a tuple, if only at the use site:</p>
<pre><code>let t = (u32:2, u8:3);
let (a, b) = t;
let _ = assert_eq(u32:2, a);
assert_eq(u8:3, b)
</code></pre>

<p>Just as values can be discarded in a <code>let</code> by using the "black hole identifier"
<code>_</code>, don't-care values can also be discarded when destructuring a tuple:</p>
<pre><code>let t = (u32:2, u8:3, true);
let (_, _, v) = t;
assert_eq(v, true)
</code></pre>

<h3 id="struct-types">Struct Types</h3>
<p>Structures are similar to tuples, but provide two additional capabilities: we
name the slots (i.e. struct fields have names while tuple elements only have
positions), and we introduce a new type.</p>
<p>The following syntax is used to define a struct:</p>
<pre><code>struct Point {
  x: u32,
  y: u32
}
</code></pre>

<p>Once a struct is defined it can be constructed by naming the fields in any
order:</p>
<pre><code>struct Point {
  x: u32,
  y: u32,
}

#![test]
fn struct_equality {
  let p0 = Point { x: u32:42, y: u32:64 };
  let p1 = Point { y: u32:64, x: u32:42 };
  assert_eq(p0, p1)
}
</code></pre>

<p>There is a simple syntax when creating a struct whose field names match the
names of in-scope values:</p>
<pre><code>struct Point { x: u32, y: u32, }

#![test]
fn struct_equality {
  let x = u32:42;
  let y = u32:64;
  let p0 = Point { x, y };
  let p1 = Point { y, x };
  assert_eq(p0, p1)
}
</code></pre>

<p>Struct fields can also be accessed with "dot" syntax:</p>
<pre><code>struct Point {
  x: u32,
  y: u32,
}

fn f(p: Point) -&gt; u32 {
  p.x + p.y
}

fn main() -&gt; u32 {
  f(Point { x: u32:42, y: u32:64 })
}

#![test]
fn main {
  assert_eq(u32:106, main())
}
</code></pre>

<p>Note that structs cannot be mutated "in place", the user must construct new
values by extracting the fields of the original struct mixed together with new
field values, as in the following:</p>
<pre><code>struct Point3 {
  x: u32,
  y: u32,
  z: u32,
}

fn update_y(p: Point3, new_y: u32) -&gt; Point3 {
  Point3 { x: p.x, y: new_y, z: p.z }
}

fn main() -&gt; Point3 {
  let p = Point3 { x: u32:42, y: u32:64, z: u32:256 };
  update_y(p, u32:128)
}

#![test]
fn main {
  let want = Point3 { x: u32:42, y: u32:128, z: u32:256 };
  assert_eq(want, main())
}
</code></pre>

<h4 id="struct-update-syntax">Struct Update Syntax</h4>
<p>The DSL has syntax for conveniently producing a new value with a subset of
fields updated to reduce verbosity. The "struct update" syntax is:</p>
<pre><code>fn update_y(p: Point3) -&gt; Point3 {
  Point3 { y: u32:42, ..p }
}

fn update_x_and_y(p: Point3) -&gt; Point3 {
  Point3 { x: u32:42, y: u32:42, ..p }
}
</code></pre>

<h4 id="parametric-structs">Parametric Structs</h4>
<p>DSLX also supports parametric structs. For more information on how
type-parametricity works, see the <a href="#parametric-functions">parametric functions</a>
section.</p>
<pre><code>fn double(n: u32) -&gt; u32 { n * u32:2 }

struct Point&lt;N: u32, M: u32 = double(N)&gt; Point { x: bits[N], y: bits[M], }

fn make_point&lt;A: u32, B: u32&gt; make_point(x: bits[A], y: bits[B]) -&gt; Point[A, B] {
  Point{ x, y }
}

#![test]
fn struct_construction {
  let p = make_point(u16:42, u32:42);
  assert_eq(u16:42, p.x)
}
</code></pre>

<h4 id="understanding-nominal-typing">Understanding Nominal Typing</h4>
<p>As mentioned above, a struct definition introduces a new type. Structs are
nominally typed, as opposed to structurally typed (note that tuples are
structurally typed). This means that structs with different names have different
types, regardless of whether those structs have the same structure (i.e. even
when all the fields of two structures are identical, those structures are a
different type when they have a different name).</p>
<pre><code>struct Point {
  x: u32,
  y: u32,
}

struct Coordinate {
  x: u32,
  y: u32,
}

fn f(p: Point) -&gt; u32 {
  p.x + p.y
}

#![test]
fn ok {
  assert_eq(f(Point { x: u32:42, y: u32:64 }), u32:106)
}

#![test]
fn type_checker_error {
  assert_eq(f(Coordinate { x: u32:42, y: u32:64 }), u32:106)
}
</code></pre>

<h3 id="array-type">Array Type</h3>
<p>Arrays can be constructed via bracket notation. All values that make up the
array must have the same type. Arrays can be indexed with indexing notation
(<code>a[i]</code>) to retrieve a single element.</p>
<pre><code>fn main(a: u32[2], i: u1) -&gt; u32 {
  a[i]
}

#![test]
fn main {
  let x = u32:42;
  let y = u32:64;
  // Make an array with &quot;bracket notation&quot;.
  let my_array: u32[2] = [x, y];
  let _ = assert_eq(main(my_array, u1:0), x);
  let _ = assert_eq(main(my_array, u1:1), y);
  ()
}
</code></pre>

<p>Because arrays with repeated trailing elements are common, the DSL supports
ellipsis (<code>...</code>) at the end of an array to fill the remainder of the array with
the last noted element. Because the compiler must know how many elements to
fill, in order to use the ellipsis the type must be annotated explicitly as
shown.</p>
<pre><code>fn make_array(x: u32) -&gt; u32[3] {
  u32[3]:[u32:42, x, ...]
}

#![test]
fn make_array {
  let _ = assert_eq(u32[3]:[u32:42, u32:42, u32:42], make_array(u32:42));
  let _ = assert_eq(u32[3]:[u32:42, u32:64, u32:64], make_array(u32:64));
  ()
}
</code></pre>

<p>TODO(meheff): Explain arrays and the intricacies of our bits type interpretation
and how it affects arrays of bits etc.</p>
<h3 id="type-aliases">Type Aliases</h3>
<p>DLSX supports the definition of type aliases.</p>
<p>Type aliases can be used to provide a more human-readable name for an existing
type. The new name is on the left, the existing name on the right:</p>
<pre><code>type Weight = u6;
</code></pre>

<p>We can create an alias for an imported type:</p>
<pre><code>import xls.dslx.interpreter.tests.mod_imported

type MyEnum = mod_imported::MyEnum;

fn main(x: u8) -&gt; MyEnum {
  x as MyEnum
}

#![test]
fn main {
  let _ = assert_eq(main(u8:42), MyEnum::FOO);
  let _ = assert_eq(main(u8:64), MyEnum::BAR);
  ()
}
</code></pre>

<p>Type aliases can also provide a descriptive name for a tuple type (which is
otherwise anonymous). For example, to define a tuple type that represents a
float number with a sign bit, an 8-bit mantissa, and a 23-bit mantissa, one
would write:</p>
<pre><code>type F32 = (u1, u8, u23)
</code></pre>

<p>After this definition, the <code>F32</code> may be used as a type annotation
interchangeably with <code>(u1, u8, u23)</code>.</p>
<p>Note, however, that structs are generally preferred for this purpose, as they
are more readable and users do not need to rely on tuple elements having a
stable order in the future (i.e., they are resilient to refactoring).</p>
<h3 id="type-casting">Type Casting</h3>
<p>Bit types can be cast from one bit-width to another with the <code>as</code> keyword. Types
can be widened (increasing bit-width), narrowed (decreasing bit-width) and/or
changed between signed and unsigned. Some examples are found below. See
<a href="#numerical-conversions">Numerical Conversions</a> for a description of the
semantics.</p>
<pre><code>#![test]
fn narrow_cast {
  let twelve = u4:0b1100;
  assert_eq(twelve as u2, u2:0)
}

#![test]
fn widen_cast {
  let three = u2:0b11;
  assert_eq(three as u4, u4:3)
}

#![test]
fn narrow_signed_cast {
  let negative_seven = s4:0b1001;
  assert_eq(negative_seven as u2, u2:1)
}

#![test]
fn widen_signed_cast {
  let negative_one = s2:0b11;
  assert_eq(negative_one as s4, s4:-1)
}

#![test]
fn widen_to_unsigned {
  let negative_one = s2:0b11;
  assert_eq(negative_one as u3, u3:0b111)
}

#![test]
fn widen_to_signed {
  let three = u2:0b11;
  assert_eq(three as u3, u3:0b011)
}
</code></pre>

<h3 id="type-checking-and-inference">Type Checking and Inference</h3>
<p>DSLX performs type checking and produces an error if types in an expression
don't match up.</p>
<p><code>let</code> expressions also perform type inference, which is quite convenient. For
example, instead of writing:</p>
<pre><code>let ch: u32 = (e &amp; f) ^ ((!e) &amp; g);
let (h, g, f): (u32, u32, u32) = (g, f, e);
</code></pre>

<p>one can write the following, as long as the types can be properly inferred:</p>
<pre><code>let ch = (e &amp; f) ^ ((!e) &amp; g);
let (h, g, f) = (g, f, e);
</code></pre>

<p>Note that type annotations can still be added and be used for program
understanding, as they they will be checked by DSLX.</p>
<h3 id="type-inference-details">Type Inference Details</h3>
<p>DSLX uses deductive type inference to check the types present in the program.
Deductive type inference is a set of (typically straight-forward) deduction
rules: Hindley-Milner style deductive type inference determines the result type
of a function with a rule that only observes the input types to that function.
(Note that operators like '+' are just slightly special functions in that they
have pre-defined special-syntax-rule names.)</p>
<h4 id="operator-example">Operator Example</h4>
<p>For example, consider the binary (meaning takes two operands) / infix (meaning
it syntactically is placed in the center of its operands) '+' operator. The
simple deductive type inference rule for '+' is:</p>
<p><code>(T, T) -&gt; T</code></p>
<p>Meaning that the left hand side operand to the '+' operator is of some type
(call it T), the right hand side operand to the '+' operator must be of that
same type, T, and the result of that operator is then (deduced) to be of the
same type as its operands, T.</p>
<p>Let's instantiate this rule in a function:</p>
<pre><code>fn add_wrapper(x: bits[2], y: bits[2]) -&gt; bits[2] {
  x + y
}
</code></pre>

<p>This function wraps the '+' operator. It presents two arguments to the '+'
operator and then checks that the annotated return type on <code>add_wrapper</code> matches
the deduced type for the body of that function; that is, we ask the following
question of the '+' operator (since the type of the operands must be known at
the point the add is performed):</p>
<p><code>(bits[2], bits[2]) -&gt; ?</code></p>
<p>To resolve the '?' the following procedure is being used:</p>
<ul>
<li>Pattern match the rule given above <code>(T, T) -&gt; T</code> to determine the type T:
    the left hand side operand is <code>bits[2]</code>, called T.</li>
<li>Check that the right hand side is also that same T, which it is: another
    <code>bits[2]</code>.</li>
<li>Deduce that the result type is that same type T: <code>bits[2]</code>.</li>
<li>That becomes the return type of the body of the function. Check that it is
    the same type as the annotated return type for the function, and it is!</li>
</ul>
<p>The function is annotated to return <code>bits[2]</code>, and the deduced type of the body
is also <code>bits[2]</code>. Qed.</p>
<h4 id="type-errors">Type errors</h4>
<p>A <strong>type error</strong> would occur in the following:</p>
<pre><code>fn add_wrapper(x: bits[2], y: bits[3]) -&gt; bits[2] {
  x + y
}
</code></pre>

<p>Applying the type deduction rule for '+' finds an inconsistency. The left hand
side operand has type <code>bits[2]</code>, called T, but the right hand side is <code>bits[3]</code>,
which is not the same as T. Because the deductive type inference rule does not
say what to do when the operand types are different, it results in a type error
which is flagged at this point in the program.</p>
<h4 id="let-bindings-names-and-the-environment">Let Bindings, Names, and the Environment</h4>
<p>All expressions in the language's expression grammar have a deductive type
inference rule. The types must be known for inputs to an operator/function
(otherwise there'd be a use-before-definition error) and every expression has a
way to determine its type from its operand expressions.</p>
<p>A more interesting deduction rule comes into view with "let" expressions, which
are of the form:</p>
<p><code>let $name: $annotated_type = $expr in $subexpr</code></p>
<p>An example of this is:</p>
<p><code>let x: u32 = u32:2 in x</code></p>
<p>That's an expression which evaluates to the value '2' of type <code>u32</code>.</p>
<p>In a let expression like this, we say <code>$name</code> gets "bound" to a value of type
<code>$annotated_type</code>. The let typecheck must both check that <code>$expr</code> is of type
<code>$annotated_type</code>, as well as determine the type of <code>$subexpr</code>, which is the
type of the overall "let expression".</p>
<p>This leads to the deduction rule that "let just returns the type of <code>$subexpr</code>".
But, in this example, the subexpr needs some information from the outer <code>let</code>
expression, because if asked "what's the type of some symbol <code>y</code>" one
immediately asks "well what comes before that in the program text?"</p>
<p>Let bindings lead to the introduction of the notion of an <em>environment</em> that is
passed to type inference rules. The deduction rule says, "put the bindings that
<code>$name</code> is of type <code>$annotated_type</code> in the environment, then deduce the type of
<code>$subexpr</code>. Then we can simply say that the type of some identifier
<code>$identifier</code> is the type that we find looking up <code>$identifier</code> up in that
environment.</p>
<p>In the DSLX prototype code this environment is called the <code>Bindings</code>, and it
maps identifiers to the AST node that defines the name (<code>{Text: AstNode}</code>),
which can be combined with a mapping from AST node to its deduced type
(<code>{AstNode: ConcreteType}</code>) to resolve the type of an identifier.</p>
<h2 id="statements">Statements</h2>
<h3 id="imports">Imports</h3>
<p>DSLX modules can import other modules via the <code>import</code> keyword. Circular imports
are not permitted (the dependencies among DSLX modules must form a DAG, as in
languages like Go).</p>
<p>The import statement takes the following form (note the lack of semicolon):</p>
<pre><code>import path.to.my.imported_module
</code></pre>

<p>With that statement, the module will be accessible as (the trailing identifier
after the last dot) <code>imported_module</code>; e.g. the program can refer to
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code>.</p>
<p>NOTE Imports are relative to the Bazel "depot root" -- for external use of the
tools a <code>DSLX_PATH</code> will be exposed, akin to a <code>PYTHONPATH</code>, for users to
indicate paths where were should attempt module discovery.</p>
<p>NOTE Importing <strong>does not</strong> introduce any names into the current file other than
the one referred to by the import statement. That is, if <code>imported_module</code> had a
constant defined in it <code>FOO</code>, this is referred to via <code>imported_module::FOO</code>,
<code>FOO</code> does not "magically" get put in the current scope. This is analogous to
how wildcard imports are discouraged in other languages (e.g. <code>from import *</code> in
Python) on account of leading to "namespace pollution" and needing to specify
what happens when names conflict.</p>
<p>If you want to change the name of the imported module (for reference inside of
the importing file) you can use the <code>as</code> keyword:</p>
<pre><code>import path.to.my.imported_module as im
</code></pre>

<p>Just using the above construct,
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code> is <em>not</em> valid, only
<code>im::IMPORTED_MODULE_PUBLIC_CONSTANT</code>. However, both statements can be used on
different lines:</p>
<pre><code>import path.to.my.imported_module
import path.to.my.imported_module as im
</code></pre>

<p>In this case, either <code>im::IMPORTED_MODULE_PUBLIC_CONSTANT</code> or
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code> can be used to refer to the
same thing.</p>
<p>Here is an example using the same function via two different aliases for the
same module:</p>
<pre><code>import xls.dslx.interpreter.tests.mod_imported
import xls.dslx.interpreter.tests.mod_imported as mi

fn main(x: u3) -&gt; u1 {
  mod_imported::my_lsb(x) || mi::my_lsb(x)
}

#![test]
fn main {
  assert_eq(u1:0b1, main(u3:0b001))
}
</code></pre>

<h3 id="public-module-members">Public module members</h3>
<p>Module members are private by default and not accessible from any importing
module. To make a member public/visible to importing modules, the <code>pub</code> keyword
must be added as a prefix; e.g.</p>
<pre><code>const FOO = u32:42;      // Not accessible to importing modules.
pub const BAR = u32:64;  // Accessible to importing modules.
</code></pre>

<p>This applies to other things defined at module scope as well: functions, enums,
type aliases, etc.</p>
<pre><code>import xls.dslx.interpreter.tests.mod_imported
import xls.dslx.interpreter.tests.mod_imported as mi

fn main(x: u3) -&gt; u1 {
  mod_imported::my_lsb(x) || mi::my_lsb(x)
}

#![test]
fn main {
  assert_eq(u1:0b1, main(u3:0b001))
}
</code></pre>

<h3 id="const">Const</h3>
<p>The <code>const</code> keyword is used to define module-level constant values. Named
constants should be usable anywhere a literal value can be used:</p>
<pre><code>const FOO = u8:42;

fn match_const(x: u8) -&gt; u8 {
  match x {
    FOO =&gt; u8:0,
    _ =&gt; u8:42,
  }
}

#![test]
fn match_const_not_binding {
  let _ = assert_eq(u8:42, match_const(u8:0));
  let _ = assert_eq(u8:42, match_const(u8:1));
  let _ = assert_eq(u8:0, match_const(u8:42));
  ()
}

fn h(t: (u8, (u16, u32))) -&gt; u32 {
  match t {
    (FOO, (x, y)) =&gt; (x as u32) + y,
    (_, (y, u32:42)) =&gt; y as u32,
    _ =&gt; u32:7,
  }
}

#![test]
fn match_nested {
  let _ = assert_eq(u32:3, h((u8:42, (u16:1, u32:2))));
  let _ = assert_eq(u32:1, h((u8:0, (u16:1, u32:42))));
  let _ = assert_eq(u32:7, h((u8:0, (u16:1, u32:0))));
  ()
}
</code></pre>

<h2 id="expressions">Expressions</h2>
<h3 id="unary-expressions">Unary Expressions</h3>
<p>DSLX supports three types of unary expressions:</p>
<ul>
<li>bit-wise not (the <code>!</code> operator)</li>
<li>negate (the <code>-</code> operator, computes the two's complement negation)</li>
</ul>
<h3 id="binary-expressions">Binary Expressions</h3>
<p>DSLX support a familiar set of binary expressions. For those, both operands to
the expression must be of the same bit type (i.e., not arrays or tuples). This
is true even for the shift operators.</p>
<ul>
<li>shift-right (<code>&gt;&gt;</code>)</li>
<li>shift-right arithmetic (<code>&gt;&gt;&gt;</code>)</li>
<li>shift-left (<code>&lt;&lt;</code>)</li>
<li>bit-wise or (<code>|</code>)</li>
<li>bit-wise and (<code>&amp;</code>)</li>
<li>add (<code>+</code>)</li>
<li>subtract (<code>-</code>)</li>
<li>xor (<code>^</code>)</li>
<li>multiply (<code>*</code>)</li>
<li>logical or (<code>||</code>)</li>
<li>logical and (<code>&amp;&amp;</code>)</li>
</ul>
<h3 id="comparison-expressions">Comparison Expressions</h3>
<p>For comparison expressions the types of both operands must match. However these
operations return a result of type <code>bits[1]</code>, aka <code>bool</code>.</p>
<ul>
<li>equal (<code>==</code>)</li>
<li>not-equal (<code>!=</code>)</li>
<li>greater-equal (<code>&gt;=</code>)</li>
<li>greater (<code>&gt;</code>)</li>
<li>less-equal (<code>&lt;=</code>)</li>
<li>less (<code>&lt;</code>)</li>
</ul>
<h3 id="concat-expression">Concat Expression</h3>
<p>TODO(meheff): Explain the intricacies of our bits type interpretation and how it
affects concat.</p>
<h3 id="match-expression">Match Expression</h3>
<p>Match expressions permit "pattern matching" on data, like a souped-up switch
statement. It can both test for values (like a conditional guard) and bind
values to identifiers for subsequent use. For example:</p>
<pre><code>fn f(t: (u8, u32)) -&gt; u32 {
  match t {
    (u8:42, y) =&gt; y,
    (_, y) =&gt; y+u8:77
  }
}
</code></pre>

<p>If the first member of the tuple is the value is <code>42</code>, we pass the second tuple
member back as-is from the function. Otherwise, we add <code>77</code> to the value and
return that. The <code>_</code> symbolizes "I don't care about this value".</p>
<p>Just like literal constants, pattern matching can also match via named
constants; For example, consider this variation on the above:</p>
<pre><code>const MY_FAVORITE_NUMBER = u8:42;
fn f(t: (u8, u32)) -&gt; u32 {
  match t {
    (MY_FAVORITE_NUMBER, y) =&gt; y,
    (_, y) =&gt; y+u8:77
  }
}
</code></pre>

<p>This also works with nested tuples; for example:</p>
<pre><code>const MY_FAVORITE_NUMBER = u8:42;
fn f(t: (u8, (u16, u32))) -&gt; u32 {
  match t {
    (MY_FAVORITE_NUMBER, (y, z)) =&gt; u32:y+z,
    (_, (y, u32:42)) =&gt; u32:y,
    _ =&gt; u32:7
  }
}
</code></pre>

<p>Here we use a "catch all" wildcard pattern in the last match arm to ensure the
match expression always matches the input somehow.</p>
<h3 id="let-expression">let Expression</h3>
<p>let expressions work the same way as let expressions in other functional
languages (such as the ML family languages). let expressions provide a nested,
lexically-scoped, list of binding definitions. The scope of the binding is the
expression on the right hand side of the declaration. For example:</p>
<pre><code>let a: u32 = u32:1 + u32:2;
let b: u32 = a + u32:3;
b
</code></pre>

<p>would bind (and return as a value) the value <code>6</code> which corresponds to <code>b</code> when
evaluated. In effect there is little difference to other languages like C/C++ or
Python, where the same result would be achieved with code similar to this:</p>
<pre><code>a = 1 + 2
b = a + 3
return b
</code></pre>

<p>However, <code>let</code> expressions are lexically scoped. In above example, the value <code>3</code>
is bound to <code>a</code> only during the combined let expression sequence. There is no
other type of scoping in DSLX.</p>
<h3 id="ternary-if-expression">Ternary If Expression</h3>
<p>Note: ternary expression syntax is expected to change to mimic Rust's, see
<a href="https://github.com/google/xls/issues/318">#318</a>.</p>
<p>DSLX offers a ternary <code>if</code> expression, which is very similar to the Python
ternary <code>if</code>. Blueprint:</p>
<pre><code>consequent if condition else alternate
</code></pre>

<p>This corresponds to the C/C++ ternary <code>?:</code> operator, but with the order of the
operands changed:</p>
<pre><code>condition ? consequent : alternate
</code></pre>

<p>For example, in the FP adder module (modules/fpadd_2x32.x), there is code like
the following:</p>
<pre><code>[...]
let result_sfd = result_sfd if wide_exponent &lt; u9:255 else u23:0;
let result_exponent = wide_exponent as u8 if wide_exponent &lt; u9:255 else u8:255;
</code></pre>

<h3 id="iterable-expression">Iterable Expression</h3>
<p>Iterable expressions are used in counted for loops. DSLX currently supports two
types of iterable expressions, <code>range</code> and <code>enumerate</code>.</p>
<p>The range expression <code>range(m, n)</code> produces values from m to n-1 (similar to how
typical loops are constructed in C/C++). This example will run from 0 to 4
(exclusive):</p>
<pre><code>for (i, accum): (u32, u32) in range(u32:0, u32:4) {
</code></pre>

<p><code>enumerate</code> iterates over the elements of an array type and produces pairs of
<code>(index, value)</code>, similar to enumeration constructs in languages like Python or
Go.</p>
<p>In the example below, the loop will iterate 8 times, following the array
dimension of <code>x</code>. Each iteration produces a tuple with the current index (<code>i</code>
ranging from 0 to 7) and the value at the index (<code>e = x[i]</code>).</p>
<pre><code>fn prefix_scan_eq(x: u32[8]) -&gt; bits[8,3] {
  let (_, _, result) =
    for ((i, e), (prior, count, result)): ((u32, u32), (u32, u3, bits[8,3]))
        in enumerate(x) {...
</code></pre>

<h3 id="for-expression">for Expression</h3>
<p>DSLX currently supports synthesis of "counted" for loops (loops that have a
clear upper bound on their number of iterations). These loops are capable of
being generated as unrolled pipeline stages: when generating a pipeline, the XLS
compiler will unroll and specialize the iterations.</p>
<p>NOTE In the future support for loops with an unbounded number of iterations may
be permitted, but will only be possible to synthesize as a time-multiplexed
implementation, since pipelines cannot be unrolled indefinitely.</p>
<h4 id="blueprint">Blueprint</h4>
<pre><code>for (index, accumulator): (type-of-index, type-of-accumulator) in iterable {
   body-expression
} (initial-accumulator-value)
</code></pre>

<p>Because DSLX is a pure dataflow description, a for loop is an expression that
produces a value. As a result, you grab the output of a for loop just like any
other expression:</p>
<pre><code>let final_accum = for (i, accum) in range(u32:0, u32:8) {
  let new_accum = f(accum);
  new_accum
}(init_accum);
</code></pre>

<p>Conceptually the for loop "evolves" the accumulator as it iterates, and
ultimately pops it out as the result of its evaluation.</p>
<h4 id="examples">Examples</h4>
<p>Add up all values from 0 to 4 (exclusive). Note that we pass the accumulator's
initial value in as a parameter to this expression.</p>
<pre><code>for (i, accum): (u32, u32) in range(u32:0, u32:4) {
  accum + i
}(u32:0)
</code></pre>

<p>To add up values from 7 to 11 (exclusive), one would write:</p>
<pre><code>let base = u32:7;
for (i, accum): (u32, u32) in range(u32:0, u32:4) {
  accum + base + i
}(u32:0)
</code></pre>

<p>"Loop invariant" values (values that do not change as the loop runs) can be used
in the loop body, for example, note the use of <code>outer_thing</code> below:</p>
<pre><code>let outer_thing: u32 = u32:42;
for (i, accum): (u32, u32) in range(u32:0, u32:4) {
    accum + i + outer_thing
}(u32:0)
</code></pre>

<p>Both the index and accumulator can be of any valid type, in particular, the
accumulator can be a tuple type, which is useful for evolving a bunch of values.
For example, this for loop "evolves" two arrays:</p>
<pre><code>for (i, (xs, ys)): (u32, (u16[3], u8[3])) in range(u32:0, u32:4) {
  ...
}((init_xs, init_ys))
</code></pre>

<p>Note in the above example arrays are dataflow values just like anything else. To
conditionally update an array every other iteration:</p>
<pre><code>let result: u4[8] = for (i, array) in range(u32:0, u32:8) {
  // Update every other cell with the square of the index.
  update(array, i, i*i) if i % 2 == 0 else array
}(u4[8]:[0, ...]);
</code></pre>

<h3 id="numerical-conversions-numerical-conversions">Numerical Conversions {#numerical-conversions}</h3>
<p>DSLX adopts the
<a href="https://doc.rust-lang.org/1.30.0/book/first-edition/casting-between-types.html">Rust rules</a>
for semantics of numeric casts:</p>
<ul>
<li>Casting from larger bit-widths to smaller bit-widths will truncate (to the
    LSbs).</li>
<li>Casting from a smaller bit-width to a larger bit-width will zero-extend if
    the source is unsigned, sign-extend if the source is signed.</li>
<li>Casting from a bit-width to its own bit-width, between signed/unsigned, is a
    no-op.</li>
</ul>
<pre><code>#![test]
fn numerical_conversions {
  let s8_m2 = s8:-2;
  let u8_m2 = u8:-2;
  // Sign extension (source type is signed).
  let _ = assert_eq(s32:-2, s8_m2 as s32);
  let _ = assert_eq(u32:-2, s8_m2 as u32);
  let _ = assert_eq(s16:-2, s8_m2 as s16);
  let _ = assert_eq(u16:-2, s8_m2 as u16);
  // Zero extension (source type is unsigned).
  let _ = assert_eq(u32:0xfe, u8_m2 as u32);
  let _ = assert_eq(s32:0xfe, u8_m2 as s32);
  // Nop (bitwidth is unchanged).
  let _ = assert_eq(s8:-2, s8_m2 as s8);
  let _ = assert_eq(s8:-2, u8_m2 as s8);
  let _ = assert_eq(u8:-2, u8_m2 as u8);
  let _ = assert_eq(s8:-2, u8_m2 as s8);
  ()
}
</code></pre>

<h3 id="array-conversions">Array Conversions</h3>
<p>Casting to an array takes bits from the MSb to the LSb; that is, the group of
bits including the MSb ends up as element 0, the next group ends up as element
1, and so on.</p>
<p>Casting from an array to bits performs the inverse operation: element 0 becomes
the MSbs of the resulting value.</p>
<p>All casts between arrays and bits must have the same total bit count.</p>
<pre><code>fn cast_to_array(x: u6) -&gt; u2[3] {
  x as u2[3]
}

fn cast_from_array(a: u2[3]) -&gt; u6 {
  a as u6
}

fn concat_arrays(a: u2[3], b: u2[3]) -&gt; u2[6] {
  a ++ b
}

#![test]
fn cast_to_array {
  let a_value: u6 = u6:0b011011;
  let a: u2[3] = cast_to_array(a_value);
  let a_array = u2[3]:[1, 2, 3];
  let _ = assert_eq(a, a_array);
  // Note: converting back from array to bits gives the original value.
  let _ = assert_eq(a_value, cast_from_array(a));

  let b_value: u6 = u6:0b111001;
  let b_array: u2[3] = u2[3]:[3, 2, 1];
  let b: u2[3] = cast_to_array(b_value);
  let _ = assert_eq(b, b_array);
  let _ = assert_eq(b_value, cast_from_array(b));

  // Concatenation of bits is analogous to concatenation of their converted
  // arrays. That is:
  //
  //  convert(concat(a, b)) == concat(convert(a), convert(b))
  let concat_value: u12 = a_value ++ b_value;
  let concat_array: u2[6] = concat_value as u2[6];
  let _ = assert_eq(concat_array, concat_arrays(a_array, b_array));

  // Show a few classic &quot;endianness&quot; example using 8-bit array values.
  let x = u32:0xdeadbeef;
  let _ = assert_eq(x as u8[4], u8[4]:[0xde, 0xad, 0xbe, 0xef]);
  let y = u16:0xbeef;
  let _ = assert_eq(y as u8[2], u8[2]:[0xbe, 0xef]);

  ()
}
</code></pre>

<h3 id="bit-slice-expressions">Bit Slice Expressions</h3>
<p>DSLX supports Python-style bit slicing over bits types. Note that bits are
numbered 0..N starting "from the right (as you would write it on paper)" --
least significant bit, AKA LSb -- for example:</p>
<pre><code>    Bit    6 5 4 3 2 1 0
  Value    1 0 0 0 1 1 1
</code></pre>

<p>A slice expression <code>[n:m]</code> means to get from bit <code>n</code> (inclusive) to bit 'm'
exclusive. This can be confusing, because the <code>n</code> stands to the left of <code>m</code> in
the expression, but bit <code>n</code> would be to the 'right' of <code>m</code> in the classical bit
numbering (note: Not in the classical array visualization, where element 0 is
usually drawn to the left).</p>
<p>For example, the expression <code>[0:2]</code> would yield:</p>
<pre><code>    Bit    6 5 4 3 2 1 0
  Value    1 0 0 0 1 1 1
                     ^ ^  included
                   ^      excluded

  Result:  0b11
</code></pre>

<p>Note that, as of now, the indices for this <code>[n:m]</code> form must be literal numbers
(so the compiler can determine the width of the result). To perform a slice with
a non-literal-number start position, see the <code>+:</code> form described below.</p>
<p>The slicing operation also support the python style slices with offsets from
start or end. To visualize, one can think of <code>x[ : -1]</code> as the equivalent of
<code>x[from the start : bitwidth - 1]</code>. Correspondingly, <code>x[-1 : ]</code> can be
visualized as <code>[ bitwidth - 1 : to the end]</code>.</p>
<p>For example, to get all bits, except the MSb (from the beginning, until the top
element minus 1):</p>
<pre><code>x[:-1]
</code></pre>

<p>Or to get the left-most 2 bits (from bitwidth - 2, all the way to the end):</p>
<pre><code>x[-2:]
</code></pre>

<p>There is also a "counted" form <code>x[start +: bits[N]]</code> - starting from a specified
bit, slice out the next <code>N</code> bits. This is equivalent to: <code>bits[N]:(x &gt;&gt; start)</code>.
The type can be specified as either signed or unsigned; e.g. <code>[start +: s8]</code>
will produce an 8-bit signed value starting at <code>start</code>, whereas <code>[start +: u4]</code>
will produce a 4-bit unsigned number starting at <code>start</code>.</p>
<p><a href="https://github.com/google/xls/tree/main/xls/dslx/tests/bit_slice_syntax.x">Here are many more examples</a>:</p>
<pre><code>// Identity function helper.
fn id&lt;N: u32&gt;(x: bits[N]) -&gt; bits[N] { x }

#![test]
fn bit_slice_syntax {
  let x = u6:0b100111;
  // Slice out two bits.
  let _ = assert_eq(u2:0b11, x[0:2]);
  let _ = assert_eq(u2:0b11, x[1:3]);
  let _ = assert_eq(u2:0b01, x[2:4]);
  let _ = assert_eq(u2:0b00, x[3:5]);

  // Slice out three bits.
  let _ = assert_eq(u3:0b111, x[0:3]);
  let _ = assert_eq(u3:0b011, x[1:4]);
  let _ = assert_eq(u3:0b001, x[2:5]);
  let _ = assert_eq(u3:0b100, x[3:6]);

  // Slice out from the end.
  let _ = assert_eq(u1:0b1, x[-1:]);
  let _ = assert_eq(u1:0b1, x[-1:6]);
  let _ = assert_eq(u2:0b10, x[-2:]);
  let _ = assert_eq(u2:0b10, x[-2:6]);
  let _ = assert_eq(u3:0b100, x[-3:]);
  let _ = assert_eq(u3:0b100, x[-3:6]);
  let _ = assert_eq(u4:0b1001, x[-4:]);
  let _ = assert_eq(u4:0b1001, x[-4:6]);

  // Slice both relative to the end (MSb).
  let _ = assert_eq(u2:0b01, x[-4:-2]);
  let _ = assert_eq(u2:0b11, x[-6:-4]);

  // Slice out from the beginning (LSb).
  let _ = assert_eq(u5:0b00111, x[:-1]);
  let _ = assert_eq(u4:0b0111, x[:-2]);
  let _ = assert_eq(u3:0b111, x[:-3]);
  let _ = assert_eq(u2:0b11, x[:-4]);
  let _ = assert_eq(u1:0b1, x[:-5]);

  // Slicing past the end just means we hit the end (as in Python).
  let _ = assert_eq(u1:0b1, x[5:7]);
  let _ = assert_eq(u1:0b1, x[-7:1]);
  let _ = assert_eq(bits[0]:0, x[-7:-6]);
  let _ = assert_eq(bits[0]:0, x[-6:-6]);
  let _ = assert_eq(bits[0]:0, x[6:6]);
  let _ = assert_eq(bits[0]:0, x[6:7]);
  let _ = assert_eq(u1:1, x[-6:-5]);

  // Slice of a slice.
  let _ = assert_eq(u2:0b11, x[:4][1:3]);

  // Slice of an invocation.
  let _ = assert_eq(u2:0b01, id(x)[2:4]);

  // Explicit-width slices.
  let _ = assert_eq(u2:0b01, x[2+:u2]);
  let _ = assert_eq(s3:0b100, x[3+:s3]);
  let _ = assert_eq(u3:0b001, x[5+:u3]);
  ()
}
</code></pre>

<h3 id="advanced-understanding-parametricity-constraints-and-unification">Advanced Understanding: Parametricity, Constraints, and Unification</h3>
<p>An infamous wrinkle is introduced for parametric functions: consider the
following function:</p>
<pre><code>fn add_wrapper&lt;T: type, U: type&gt;(x: T, y: U) -&gt; T {
  x + y
}
</code></pre>

<p>Based on the inference rule, we know that '+' can only type check when the
operand types are the same. This means we can conclude that type <code>T</code> is the same
as type <code>U</code>. Once we determine this, we need to make sure anywhere <code>U</code> is used
it is consistent with the fact it is the same as <code>T</code>. In a sense the + operator
is "adding a constraint" that <code>T</code> is equivalent to <code>U</code>, and trying to check that
fact is valid is under the purview of type inference. The fact that the
constraint is added that <code>T</code> and <code>U</code> are the same type is referred to as
"unification", as what was previously two entities with potentially different
constraints now has a single set of constraints that comes from the union of its
operand types.</p>
<p>DSLX's typechecker will go through the body of parametric functions per
invocation. As such, the typechecker will always have the invocation's
parametric values for use in asserting type consistency against "constraints"
such as derived parametric expressions, body vs. annotated return type equality,
and expression inference rules.</p>
<h3 id="operator-precedence">Operator Precedence</h3>
<p>DSLX's operator precedence matches Rust's. Listed below are DSLX's operators in
descending precedence order. Binary operators at the same level share the same
associativity and will be grouped accordingly.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unary <code>-</code> <code>!</code></td>
<td>n/a</td>
</tr>
<tr>
<td><code>as</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>\|</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>Left to right</td>
</tr>
</tbody>
</table>
<h2 id="builtins">Builtins</h2>
<p>This section describes the built-in functions provided for use in the DSL that
do not need to be explicitly imported.</p>
<p>A note on "Parallel Primitives": the DSL is expected to grow additional support
for use of high-level parallel primitives over time, adding operators for
order-insensitive reductions, scans, groupings, and similar. By making these
operations known to the compiler in their high level form, we potentially enable
optimizations and analyses on their higher level ("lifted") form. As of now,
<code>map</code> is the sole parallel-primitive-oriented built-in.</p>
<h3 id="map">map</h3>
<p><code>map</code>, similarly to other languages, executes a transformation function on all
the elements of an original array to produce the resulting "mapped' array.
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/map_of_stdlib_parametric.x">For example</a>:
taking the absolute value of each element in an input array:</p>
<pre><code>import std

fn main(x: s3[3]) -&gt; s3[3] {
  let y: s3[3] = map(x, std::abs);
  y
}

#![test]
fn main_test() {
  let got: s3[3] = main(s3[3]:[-1, 1, 0]);
  assert_eq(s3[3]:[1, 1, 0], got)
}
</code></pre>

<p>Note that map is special, in that we can pass it a callee <em>as if</em> it were a
value. As a function that "takes" a function as an argument, <code>map</code> is a special
builtin -- in language implementor parlance it is a <em>higher order function</em>.</p>
<p>Implementation note: Functions are not first class values in the DSL, so the
name of the function must be referred to directly.</p>
<p>Note: Novel higher order functions (e.g. if a user wanted to write their own
<code>map</code>) cannot currently be written in user-level DSL code.</p>
<h3 id="clz-ctz">clz, ctz</h3>
<p>DSLX provides the common "count leading zeroes" and "count trailing zeroes"
functions:</p>
<pre><code>  let x0 = u32:0x0FFFFFF8;
  let x1 = clz(x0);
  let x2 = ctz(x0);
  let _ = assert_eq(u32:4, x1);
  assert_eq(u32:3, x2)
</code></pre>

<h3 id="signex">signex</h3>
<p>Casting has well-defined extension rules, but in some cases it is necessary to
be explicit about sign-extensions, if just for code readability. For this, there
is the <code>signex</code> builtin.</p>
<p>To invoke the <code>signex</code> builtin, provide it with the operand to sign extend
(lhs), as well as the target type to extend to: these operands may be either
signed or unsigned. Note that the <em>value</em> of the right hand side is ignored,
only its type is used to determine the result type of the sign extension.</p>
<pre><code>  let x = u8:-1;
  let s: s32 = signex(x, s32:0);
  let u: u32 = signex(x, u32:0);
  assert_eq(u32:s, u)
</code></pre>

<p>Note that both <code>s</code> and <code>u</code> contain the same bits in the above example.</p>
<h3 id="rev">rev</h3>
<p><code>rev</code> is used to reverse the bits in an unsigned bits value. The LSb in the
input becomes the MSb in the result, the 2nd LSb becomes the 2nd MSb in the
result, and so on.</p>
<pre><code>// (Dummy) wrapper around reverse.
fn wrapper&lt;N: u32&gt;(x: bits[N]) -&gt; bits[N] {
  rev(x)
}

// Target for IR conversion that works on u3s.
fn main(x: u3) -&gt; u3 {
  wrapper(x)
}

// Reverse examples.
#![test]
fn reverse {
  let _ = assert_eq(u3:0b100, main(u3:0b001));
  let _ = assert_eq(u3:0b001, main(u3:0b100));
  let _ = assert_eq(bits[0]:0, rev(bits[0]:0));
  let _ = assert_eq(u1:1, rev(u1:1));
  let _ = assert_eq(u2:0b10, rev(u2:0b01));
  let _ = assert_eq(u2:0b00, rev(u2:0b00));
  ()
}
</code></pre>

<h3 id="bit_slice_update">bit_slice_update</h3>
<p><code>bit_slice_update(subject, start, value)</code> returns a copy of the bits-typed value
<code>subject</code> where the contiguous bits starting at index <code>start</code> (where 0 is the
least-significant bit) are replaced with <code>value</code>. The bit-width of the returned
value is the same as the bit-width of <code>subject</code>. Any updated bit indices which
are out of bounds (if <code>start + bit-width(value) &gt;= bit-width(subject)</code>) are
ignored. Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/bit_slice_update.x"><code>dslx/tests/bit_slice_update.x</code></a>.</p>
<h3 id="bitwise-reduction-builtins">Bitwise reduction builtins</h3>
<p>These are unary reduction operations applied to a bits-typed value:</p>
<ul>
<li><code>and_reduce</code>: evaluates to bool:1 if all bits of the input are set, and 0
    otherwise.</li>
<li><code>or_reduce</code>: evaluates to bool:1 if any bit of the input is set, and 0
    otherwise.</li>
<li><code>xor_reduce</code>: evaluates to bool:1 if there is an odd number of bits set in
    the input, and 0 otherwise.</li>
</ul>
<p>These functions return the identity element of the respective operation for
trivial (0 bit wide) inputs:</p>
<pre><code>#![test]
fn trivial_reduce {
  let _ = assert_eq(and_reduce(bits[0]:0), true);
  let _ = assert_eq(or_reduce(bits[0]:0), false);
  let _ = assert_eq(xor_reduce(bits[0]:0), false);
  ()
}
</code></pre>

<h3 id="update">update</h3>
<p><code>update(array, index, new_value)</code> returns a copy of <code>array</code> where <code>array[index]</code>
has been replaced with <code>new_value</code>, and all other elements are unchanged. Note
that this is <em>not</em> an in-place update of the array, it is an "evolution" of
<code>array</code>. It is the compiler's responsibility to optimize by using mutation
instead of copying, when it's safe to do. The compiler makes a best effort to do
this, but can't guarantee the optimization is always made.</p>
<h3 id="assert_eq">assert_eq</h3>
<p>In a unit test pseudo function all valid DSLX code is allowed. To evaluate test
results DSLX provides the <code>assert_eq</code> primitive (we'll add more of those in the
future). Here is an example of a <code>divceil</code> implementation with its corresponding
tests:</p>
<pre><code>fn divceil(x: u32, y: u32) -&gt; u32 {
  (x-u32:1) / y + u32:1
}

#![test]
fn test_divceil() {
  let _ = assert_eq(u32:3, divceil(u32:5, u32:2));
  let _ = assert_eq(u32:2, divceil(u32:4, u32:2));
  let _ = assert_eq(u32:2, divceil(u32:3, u32:2));
  let _ = assert_eq(u32:1, divceil(u32:2, u32:2));
  _
}
</code></pre>

<p>Note that in this example, the final <code>let _ = ... in _</code> construct could be
omitted.</p>
<p><code>assert_eq</code> cannot be synthesized into equivalent Verilog. Because of that it is
recommended to use it within <code>test</code> constructs (interpretation) only.</p>
<h3 id="trace">trace!</h3>
<p>DSLX supports printf-style debugging via the <code>trace!</code> builtin, which allows
dumping of current values to stdout. For example:</p>
<pre><code>fn decode_s_instruction(ins: u32) -&gt; (u12, u5, u5, u3, u7) {
   let imm_11_5 = (ins &gt;&gt; u32:25);
   let rs2 = (ins &gt;&gt; u32:20) &amp; u32:0x1F;
   let rs1 = (ins &gt;&gt; u32:15) &amp; u32:0x1F;
   let funct3 = (ins &gt;&gt; u32:12) &amp; u32:0x07;
   let imm_4_0 = (ins &gt;&gt; u32:7) &amp; u32:0x1F;
   let opcode = ins &amp; u32:0x7F;
   let _ = trace!(imm_11_5);
   let _ = trace!(imm_4_0);
   (u12:(u7:imm_11_5 ++ u5:imm_4_0), u5:rs2, u5:rs1, u3:funct3, u7:opcode)
}

</code></pre>

<p>would produce the following output, with each trace being annotated with its
corresponding source position:</p>
<pre><code>[...]
[ RUN      ] decode_s_test_lsb
trace of imm_11_5 @ 69:17-69:27: bits[32]:0x1
trace of imm_4_0 @ 70:17-70:26: bits[32]:0x1
[...]
</code></pre>

<p><code>trace</code> also returns the value passed to it, so it can be used inline, as in:</p>
<pre><code>match trace!(my_thing) {
   [...]
}
</code></pre>

<p>To see the values of <em>all</em> expressions during interpretation, invoke the
interpreter or test with the <code>--trace_all</code> flag:</p>
<pre><code>$ ./interpreter_main clz.x -logtostderr -trace_all
[ RUN      ] clz
trace of (u3:0) @ clz.x:2:24: bits[3]:0x0
trace of (u3:0b111) @ clz.x:2:34-2:39: bits[3]:0x7
trace of clz((u3:0b111)) @ clz.x:2:30-2:40: bits[3]:0x0
trace of assert_eq((u3:0), clz((u3:0b111))) @ clz.x:2:20-2:41: ()
trace of (u3:1) @ clz.x:3:24: bits[3]:0x1
trace of (u3:0b011) @ clz.x:3:34-3:39: bits[3]:0x3
trace of clz((u3:0b011)) @ clz.x:3:30-3:40: bits[3]:0x1
trace of assert_eq((u3:1), clz((u3:0b011))) @ clz.x:3:20-3:41: ()
trace of (u3:2) @ clz.x:4:24: bits[3]:0x2
trace of (u3:0b001) @ clz.x:4:34-4:39: bits[3]:0x1
trace of clz((u3:0b001)) @ clz.x:4:30-4:40: bits[3]:0x2
trace of assert_eq((u3:2), clz((u3:0b001))) @ clz.x:4:20-4:41: ()
trace of (u3:3) @ clz.x:5:24: bits[3]:0x3
trace of (u3:0b000) @ clz.x:5:34-5:39: bits[3]:0x0
trace of clz((u3:0b000)) @ clz.x:5:30-5:40: bits[3]:0x3
trace of assert_eq((u3:3), clz((u3:0b000))) @ clz.x:5:20-5:41: ()
trace of () @ clz.x:6:3-6:5: ()
[       OK ] clz

</code></pre>

<p>Implementation note: tracing has no equivalent node in the IR (nor would such a
node make sense), so any <code>trace!</code> builtin invocations are silently dropped
during conversion to XLS IR.</p>
<h3 id="fail">fail!</h3>
<p>Note: this section describes work-in-progress functionality, currently <code>fail!</code>
will only trigger in DSL interpretation (it is discarded in IR conversion).
Support for converting <code>fail!</code> to XLS <code>assert</code> IR is tracked in
<a href="https://github.com/google/xls/issues/232">#232</a> -- support for indicating the
assertion was triggered in the JIT is tracked in
<a href="https://github.com/google/xls/issues/308">#308</a></p>
<p>The <code>fail!</code> builtin indicates dataflow that should not be occurring in practice.
Its general signature is:</p>
<pre><code>fail!(fallback_value)
</code></pre>

<p>The <code>fail!</code> builtin can be thought of as a "fatal assertion macro". It is used
to <strong>annotate dataflow that should not occur in practice</strong> and, if triggered,
should raise a fatal error in simulation (e.g. via a JIT-execution failure
status or a Verilog assertion when running in RTL simulation).</p>
<p>Note, however, that XLS will permit users to avoid inserting
fatal-error-signaling hardware that correspond to this <code>fail!</code> -- assuming it
will not be triggered in practice minimizes its cost in synthesized form. In
this situation, <strong>when it is "erased", it acts as the identity function</strong>,
propagating the <code>fallback_value</code>. This allows XLS to keep well defined semantics
even when fatal assertion hardware is not present.</p>
<p>Example: if only these two enum values shown should be possible (say, as a
documented <a href="https://en.wikipedia.org/wiki/Precondition">precondition</a> for
<code>main</code>):</p>
<pre><code>fn main(x: EnumType) -&gt; u32 {
  match x {
    EnumType::FIRST =&gt; u32:0,
    EnumType::SECOND =&gt; u32:1,
    _ =&gt; fail!(u32:0),
  }
}
</code></pre>

<p>The <code>fail!(u32:0)</code> above indicates that a) that match arm <em>should</em> not be
reached (and if it is in the JIT or RTL simulation it will cause an error status
or assertion failure respectively), but b) provides a fallback value to use (of
the appropriate type) in case it were to happen in synthesized gates which did
not insert fatal-error-indicating hardware.</p>
<h2 id="testing-and-debugging">Testing and Debugging</h2>
<p>DSLX allows specifying tests right in the implementation file via the <code>test</code> and
<code>quickcheck</code> directives.</p>
<p>Having key test code in the implementation file serves two purposes. It helps to
ensure the code behaves as expected. Additionally it serves as 'executable'
documentation, similar in spirit to Python doc strings.</p>
<h3 id="unit-tests">Unit Tests</h3>
<p>Unit tests are specified by the <code>test</code> directive, as seen below:</p>
<pre><code class="dslx">#![test]
fn test_reverse() {
  let _ = assert_eq(u1:1, rev(u1:1));
  let _ = assert_eq(u2:0b10, rev(u2:0b01));
  let _ = assert_eq(u2:0b00, rev(u2:0b00));
  ()
}
</code></pre>

<p>The DSLX interpreter will execute all functions that are proceeded by a <code>test</code>
directive. These functions should be non-parametric, take no arguments, and
should return a unit-type.</p>
<p>Unless otherwise specified in the implementation's build configs, functions
called by unit tests are also converted to XLS IR and run through the
toolchain's LLVM JIT. The resulting values from the DSLX interpreter and the
LLVM JIT are compared against each other to assert equality. This is to ensure
DSLX implementations are IR-convertable and that IR translation is correct.</p>
<h3 id="quickcheck">QuickCheck</h3>
<p>QuickCheck is a <a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">testing framework concept</a> founded on
property-based testing. Instead of specifying expected and test values,
QuickCheck asks for properties of the implementation that should hold true
against any input of the specified type(s). In DSLX, we use the <code>quickcheck</code>
directive to designate functions to be run via the toolchain's QuickCheck
framework. Here is an example that complements the unit testing of DSLX's <code>rev</code>
implementation from above:</p>
<pre><code>// Reversing a value twice gets you the original value.

#![quickcheck]
fn prop_double_reverse(x: u32) -&gt; bool {
  x == rev(rev(x))
}
</code></pre>

<p>The DSLX interpreter will also execute all functions that are proceeded by a
<code>quickcheck</code> directive. These functions should be non-parametric and return a
<code>bool</code>. The framework will provide randomized input based on the types of the
arguments to the function (e.g. above, the framework will provided randomized
<code>u32</code>'s as <code>x</code>).</p>
<p>By default, the framework will run the function against 1000 sets of randomized
inputs. This default may be changed by specifying the <code>test_count</code> key in the
<code>quickcheck</code> directive before a particular test:</p>
<pre><code>#![quickcheck(test_count=50000)]
</code></pre>

<p>The framework also allows programmers to specify a seed to use in generating the
random inputs, as opposed to letting the framework pick one. The seed chosen for
production can be found in the execution log.</p>
<p>For determinism, the DSLX interpreter should be run with the <code>seed</code> flag:
<code>./interpreter_main --seed=1234 &lt;DSLX source file&gt;</code></p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../solvers/" title="Formal" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Formal
              </div>
            </div>
          </a>
        
        
          <a href="../dslx_intro_example1/" title="CRC32" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                CRC32
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.d1f5a259.min.js"></script>
      <script src="../assets/javascripts/bundle.d5fec882.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.fae956e7.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>