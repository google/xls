
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://google.github.io/xls/dslx_reference/">
      
      
        <link rel="prev" href="../solvers/">
      
      
        <link rel="next" href="../dslx_std/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.6">
    
    
      
        <title>Reference - XLS: Accelerated HW Synthesis</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.558e4712.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.2505c338.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#dslx-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="XLS: Accelerated HW Synthesis" class="md-header__button md-logo" aria-label="XLS: Accelerated HW Synthesis" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            XLS: Accelerated HW Synthesis
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Reference
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/google/xls/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="XLS: Accelerated HW Synthesis" class="md-nav__button md-logo" aria-label="XLS: Accelerated HW Synthesis" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    XLS: Accelerated HW Synthesis
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/google/xls/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2" tabindex="0" aria-expanded="false">
          Tutorials
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Tutorials" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Tutorials
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_2_2" type="checkbox" id="__nav_2_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2_2" tabindex="0" aria-expanded="false">
          DSLX
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="DSLX" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          DSLX
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/hello_xls/" class="md-nav__link">
        Hello, XLS!
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/float_to_int/" class="md-nav__link">
        Basic logic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/intro_to_parametrics/" class="md-nav__link">
        Intro to parameterics
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/crc32/" class="md-nav__link">
        For expressions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/prefix_scan/" class="md-nav__link">
        Enumerate and match
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/intro_to_procs/" class="md-nav__link">
        Intro to Procs
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_2_3" type="checkbox" id="__nav_2_3" >
      
      
      
        <label class="md-nav__link" for="__nav_2_3" tabindex="0" aria-expanded="false">
          XLS[cc]
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="XLS[cc]" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_3">
          <span class="md-nav__icon md-icon"></span>
          XLS[cc]
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_overview/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_channels/" class="md-nav__link">
        Channels
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_state/" class="md-nav__link">
        State
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
        <label class="md-nav__link" for="__nav_3" tabindex="0" aria-expanded="false">
          IR
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="IR" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          IR
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ir_overview/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ir_semantics/" class="md-nav__link">
        Semantics
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../optimizations/" class="md-nav__link">
        Optimizations
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_3_4" type="checkbox" id="__nav_3_4" >
      
      
      
        <label class="md-nav__link" for="__nav_3_4" tabindex="0" aria-expanded="false">
          Scheduling
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Scheduling" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_4">
          <span class="md-nav__icon md-icon"></span>
          Scheduling
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../scheduling/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../delay_estimation/" class="md-nav__link">
        Delay Estimation
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ir_visualization/" class="md-nav__link">
        Visualizer
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_3_6" type="checkbox" id="__nav_3_6" >
      
      
      
        <label class="md-nav__link" for="__nav_3_6" tabindex="0" aria-expanded="false">
          Native JIT
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Native JIT" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_6">
          <span class="md-nav__icon md-icon"></span>
          Native JIT
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ir_jit/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_layout/" class="md-nav__link">
        Data Layout
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../solvers/" class="md-nav__link">
        Formal
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      
      
        <label class="md-nav__link" for="__nav_4" tabindex="0" aria-expanded="true">
          DSLX
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="DSLX" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          DSLX
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Reference
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    Overview
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comments" class="md-nav__link">
    Comments
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#identifiers" class="md-nav__link">
    Identifiers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-functions" class="md-nav__link">
    Parametric Functions
  </a>
  
    <nav class="md-nav" aria-label="Parametric Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#explicit-parametric-instantiation" class="md-nav__link">
    Explicit parametric instantiation
  </a>
  
    <nav class="md-nav" aria-label="Explicit parametric instantiation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expression-ambiguity" class="md-nav__link">
    Expression ambiguity
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-calls" class="md-nav__link">
    Function Calls
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#types" class="md-nav__link">
    Types
  </a>
  
    <nav class="md-nav" aria-label="Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bit-type" class="md-nav__link">
    Bit Type
  </a>
  
    <nav class="md-nav" aria-label="Bit Type">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#character-constants" class="md-nav__link">
    Character Constants
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum-types" class="md-nav__link">
    Enum Types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuple-type" class="md-nav__link">
    Tuple Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#struct-types" class="md-nav__link">
    Struct Types
  </a>
  
    <nav class="md-nav" aria-label="Struct Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#struct-update-syntax" class="md-nav__link">
    Struct Update Syntax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-structs" class="md-nav__link">
    Parametric Structs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#understanding-nominal-typing" class="md-nav__link">
    Understanding Nominal Typing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-type" class="md-nav__link">
    Array Type
  </a>
  
    <nav class="md-nav" aria-label="Array Type">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#character-string-constants" class="md-nav__link">
    Character String Constants
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-aliases" class="md-nav__link">
    Type Aliases
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-casting" class="md-nav__link">
    Type Casting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-checking-and-inference" class="md-nav__link">
    Type Checking and Inference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-inference-details" class="md-nav__link">
    Type Inference Details
  </a>
  
    <nav class="md-nav" aria-label="Type Inference Details">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#type-inference-background" class="md-nav__link">
    Type Inference Background
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bindings-and-environment" class="md-nav__link">
    Bindings and Environment
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operator-example" class="md-nav__link">
    Operator Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-errors" class="md-nav__link">
    Type errors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-bindings-names-and-the-environment" class="md-nav__link">
    Let Bindings, Names, and the Environment
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#statements" class="md-nav__link">
    Statements
  </a>
  
    <nav class="md-nav" aria-label="Statements">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#imports" class="md-nav__link">
    Imports
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#public-module-members" class="md-nav__link">
    Public module members
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    Const
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#expressions" class="md-nav__link">
    Expressions
  </a>
  
    <nav class="md-nav" aria-label="Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#literals" class="md-nav__link">
    Literals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unary-expressions" class="md-nav__link">
    Unary Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-expressions" class="md-nav__link">
    Binary Expressions
  </a>
  
    <nav class="md-nav" aria-label="Binary Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shift-expressions" class="md-nav__link">
    Shift Expressions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparison-expressions" class="md-nav__link">
    Comparison Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat-expression" class="md-nav__link">
    Concat Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-expressions" class="md-nav__link">
    Block Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#match-expression" class="md-nav__link">
    Match Expression
  </a>
  
    <nav class="md-nav" aria-label="Match Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#redundant-patterns" class="md-nav__link">
    Redundant Patterns
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-expression" class="md-nav__link">
    let Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if-expression" class="md-nav__link">
    If Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterable-expression" class="md-nav__link">
    Iterable Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for-expression" class="md-nav__link">
    for Expression
  </a>
  
    <nav class="md-nav" aria-label="for Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    Blueprint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numerical-conversions" class="md-nav__link">
    Numerical Conversions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-conversions" class="md-nav__link">
    Array Conversions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit-slice-expressions" class="md-nav__link">
    Bit Slice Expressions
  </a>
  
    <nav class="md-nav" aria-label="Bit Slice Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#width-slice" class="md-nav__link">
    Width Slice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit-slice-examples" class="md-nav__link">
    Bit Slice Examples
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-understanding-parametricity-constraints-and-unification" class="md-nav__link">
    Advanced Understanding: Parametricity, Constraints, and Unification
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operator-precedence" class="md-nav__link">
    Operator Precedence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#builtins" class="md-nav__link">
    Builtins
  </a>
  
    <nav class="md-nav" aria-label="Builtins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#add_with_carry" class="md-nav__link">
    add_with_carry
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smulp-and-umulp" class="md-nav__link">
    smulp and umulp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clz-ctz" class="md-nav__link">
    clz, ctz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#one_hot" class="md-nav__link">
    one_hot
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signex" class="md-nav__link">
    signex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    slice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rev" class="md-nav__link">
    rev
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_slice_update" class="md-nav__link">
    bit_slice_update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitwise-reduction-builtins-and_reduce-or_reduce-xor_reduce" class="md-nav__link">
    Bitwise reduction builtins: and_reduce, or_reduce, xor_reduce
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert_eq-assert_lt" class="md-nav__link">
    assert_eq, assert_lt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trace_fmt" class="md-nav__link">
    trace_fmt!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fail" class="md-nav__link">
    fail!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cover" class="md-nav__link">
    cover!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gate" class="md-nav__link">
    gate!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-and-debugging" class="md-nav__link">
    Testing and Debugging
  </a>
  
    <nav class="md-nav" aria-label="Testing and Debugging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    Unit Tests
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quickcheck" class="md-nav__link">
    QuickCheck
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_std/" class="md-nav__link">
        Standard Library
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../floating_point/" class="md-nav__link">
        Floating Point
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../fuzzer/" class="md-nav__link">
        Fuzzer
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_bytecode_interpreter/" class="md-nav__link">
        Interpreter
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
        <label class="md-nav__link" for="__nav_5" tabindex="0" aria-expanded="false">
          Code Generation
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Code Generation" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Code Generation
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../codegen_options/" class="md-nav__link">
        Codegen Options
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ir_lowering/" class="md-nav__link">
        IR Lowering
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../vast/" class="md-nav__link">
        VAST
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
        <label class="md-nav__link" for="__nav_6" tabindex="0" aria-expanded="false">
          Tools
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Tools" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Tools
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../build_system/" class="md-nav__link">
        Build System
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bazel_rules_macros/" class="md-nav__link">
        Bazel Rules And Macros
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools_quick_start/" class="md-nav__link">
        Quick Start
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tools/" class="md-nav__link">
        Listing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../interpreters/" class="md-nav__link">
        Interpreters
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
        <label class="md-nav__link" for="__nav_7" tabindex="0" aria-expanded="false">
          Development
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Development" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Development
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_style/" class="md-nav__link">
        Style Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../adding_ir_operation/" class="md-nav__link">
        Adding a new IR operation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ideas_and_projects/" class="md-nav__link">
        Ideas and Projects
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../fpga_characterization/" class="md-nav__link">
        FPGA characterization (experimental)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_8" type="checkbox" id="__nav_8" >
      
      
      
        <label class="md-nav__link" for="__nav_8" tabindex="0" aria-expanded="false">
          NoC
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="NoC" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          NoC
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_readme/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_8_2" type="checkbox" id="__nav_8_2" >
      
      
      
        <label class="md-nav__link" for="__nav_8_2" tabindex="0" aria-expanded="false">
          Topologies
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Topologies" data-md-level="2">
        <label class="md-nav__title" for="__nav_8_2">
          <span class="md-nav__icon md-icon"></span>
          Topologies
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_topologies/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_dimension_order_topology/" class="md-nav__link">
        Dimension Order
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_tree_topology/" class="md-nav__link">
        Tree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_butterfly_topology/" class="md-nav__link">
        k-ary n-fly Butterfly
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_fully_connected_topology/" class="md-nav__link">
        Fully Connected
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_star_topology/" class="md-nav__link">
        Star
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xls_noc_glossary/" class="md-nav__link">
        Glossary
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    Overview
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comments" class="md-nav__link">
    Comments
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#identifiers" class="md-nav__link">
    Identifiers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-functions" class="md-nav__link">
    Parametric Functions
  </a>
  
    <nav class="md-nav" aria-label="Parametric Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#explicit-parametric-instantiation" class="md-nav__link">
    Explicit parametric instantiation
  </a>
  
    <nav class="md-nav" aria-label="Explicit parametric instantiation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expression-ambiguity" class="md-nav__link">
    Expression ambiguity
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-calls" class="md-nav__link">
    Function Calls
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#types" class="md-nav__link">
    Types
  </a>
  
    <nav class="md-nav" aria-label="Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bit-type" class="md-nav__link">
    Bit Type
  </a>
  
    <nav class="md-nav" aria-label="Bit Type">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#character-constants" class="md-nav__link">
    Character Constants
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum-types" class="md-nav__link">
    Enum Types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuple-type" class="md-nav__link">
    Tuple Type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#struct-types" class="md-nav__link">
    Struct Types
  </a>
  
    <nav class="md-nav" aria-label="Struct Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#struct-update-syntax" class="md-nav__link">
    Struct Update Syntax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametric-structs" class="md-nav__link">
    Parametric Structs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#understanding-nominal-typing" class="md-nav__link">
    Understanding Nominal Typing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-type" class="md-nav__link">
    Array Type
  </a>
  
    <nav class="md-nav" aria-label="Array Type">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#character-string-constants" class="md-nav__link">
    Character String Constants
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-aliases" class="md-nav__link">
    Type Aliases
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-casting" class="md-nav__link">
    Type Casting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-checking-and-inference" class="md-nav__link">
    Type Checking and Inference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-inference-details" class="md-nav__link">
    Type Inference Details
  </a>
  
    <nav class="md-nav" aria-label="Type Inference Details">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#type-inference-background" class="md-nav__link">
    Type Inference Background
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bindings-and-environment" class="md-nav__link">
    Bindings and Environment
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operator-example" class="md-nav__link">
    Operator Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type-errors" class="md-nav__link">
    Type errors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-bindings-names-and-the-environment" class="md-nav__link">
    Let Bindings, Names, and the Environment
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#statements" class="md-nav__link">
    Statements
  </a>
  
    <nav class="md-nav" aria-label="Statements">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#imports" class="md-nav__link">
    Imports
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#public-module-members" class="md-nav__link">
    Public module members
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    Const
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#expressions" class="md-nav__link">
    Expressions
  </a>
  
    <nav class="md-nav" aria-label="Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#literals" class="md-nav__link">
    Literals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unary-expressions" class="md-nav__link">
    Unary Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-expressions" class="md-nav__link">
    Binary Expressions
  </a>
  
    <nav class="md-nav" aria-label="Binary Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shift-expressions" class="md-nav__link">
    Shift Expressions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparison-expressions" class="md-nav__link">
    Comparison Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat-expression" class="md-nav__link">
    Concat Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-expressions" class="md-nav__link">
    Block Expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#match-expression" class="md-nav__link">
    Match Expression
  </a>
  
    <nav class="md-nav" aria-label="Match Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#redundant-patterns" class="md-nav__link">
    Redundant Patterns
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#let-expression" class="md-nav__link">
    let Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if-expression" class="md-nav__link">
    If Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterable-expression" class="md-nav__link">
    Iterable Expression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for-expression" class="md-nav__link">
    for Expression
  </a>
  
    <nav class="md-nav" aria-label="for Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    Blueprint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numerical-conversions" class="md-nav__link">
    Numerical Conversions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-conversions" class="md-nav__link">
    Array Conversions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit-slice-expressions" class="md-nav__link">
    Bit Slice Expressions
  </a>
  
    <nav class="md-nav" aria-label="Bit Slice Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#width-slice" class="md-nav__link">
    Width Slice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit-slice-examples" class="md-nav__link">
    Bit Slice Examples
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-understanding-parametricity-constraints-and-unification" class="md-nav__link">
    Advanced Understanding: Parametricity, Constraints, and Unification
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operator-precedence" class="md-nav__link">
    Operator Precedence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#builtins" class="md-nav__link">
    Builtins
  </a>
  
    <nav class="md-nav" aria-label="Builtins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#add_with_carry" class="md-nav__link">
    add_with_carry
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smulp-and-umulp" class="md-nav__link">
    smulp and umulp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clz-ctz" class="md-nav__link">
    clz, ctz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#one_hot" class="md-nav__link">
    one_hot
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signex" class="md-nav__link">
    signex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    slice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rev" class="md-nav__link">
    rev
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_slice_update" class="md-nav__link">
    bit_slice_update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitwise-reduction-builtins-and_reduce-or_reduce-xor_reduce" class="md-nav__link">
    Bitwise reduction builtins: and_reduce, or_reduce, xor_reduce
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert_eq-assert_lt" class="md-nav__link">
    assert_eq, assert_lt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trace_fmt" class="md-nav__link">
    trace_fmt!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fail" class="md-nav__link">
    fail!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cover" class="md-nav__link">
    cover!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gate" class="md-nav__link">
    gate!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-and-debugging" class="md-nav__link">
    Testing and Debugging
  </a>
  
    <nav class="md-nav" aria-label="Testing and Debugging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    Unit Tests
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quickcheck" class="md-nav__link">
    QuickCheck
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  



<h1 id="dslx-reference">DSLX Reference</h1>
<h3 id="overview">Overview</h3>
<p>DSLX is a domain specific, dataflow-oriented functional language used to build
hardware that can also run effectively as host software. Within the XLS project,
DSLX is also referred to as "the DSL". The DSL targets the XLS compiler (via
conversion to XLS IR) to enable flows for FPGAs and ASICs.</p>
<p>DSLX mimics Rust, while being an immutable expression-based dataflow DSL with
hardware-oriented features; e.g. arbitrary bitwidths, entirely fixed size
objects, fully analyzeable call graph, etc. To avoid arbitrary new
syntax/semantics choices, the DSL mimics Rust where it is reasonably possible;
for example, integer conversions all follow the same semantics as Rust.</p>
<p>Note: There are <em>some</em> unnecessary differences today from Rust syntax due to
early experimentation, but they are quickly being removed to converge on Rust
syntax.</p>
<p>Note that other frontends to XLS core functionality will become available in the
future; e.g. <a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc">xlscc</a>, for users
familiar with the C++-and-pragma style of HLS computation. XLS team develops the
DSL as part of the XLS project because we believe it can offer significant
advantages over the C++-with-pragmas approach.</p>
<p>Dataflow DSLs are a good fit for describing hardware, compared to languages
whose design assumes
<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">von Neumann style computation</a>
(global mutable state, sequential mutation by a sequential thread of control).
Using a Domain Specific Language (DSL) provides a more hardware-oriented
representation of a given computation that matches XLS compiler (IR) constructs
closely. The DSL also allows an exploration of HLS without being encumbered by
C++ language or compiler limitations such as non-portable pragmas, magic macros,
or semantically important syntactic conventions. The language is still
experimental and likely to change, but it is already useful for experimentation
and exploration.</p>
<p>This document provides a reference for DSLX, mostly by example. Before perusing
it in detail, we recommend you first read the
<a href="../tutorials/">DSLX tutorials</a>
to understand the broad strokes of the language.</p>
<p>In this document we use the function to compute a CRC32 checksum to describe
language features. The full code is in
<a href="https://github.com/google/xls/tree/main/xls/examples/dslx_intro/crc32_one_byte.x"><code>examples/dslx_intro/crc32_one_byte.x</code></a>.</p>
<h3 id="comments">Comments</h3>
<p>Just as in languages like Rust/C++, comments start with <code>//</code> and last through
the end of the line.</p>
<h3 id="identifiers">Identifiers</h3>
<p>All identifiers, eg., for function names, parameters, and values, follow the
typical naming rules of other languages. The identifiers can start with a
character or an underscore, and can then contain more characters, underscores,
or numbers. Valid examples are:</p>
<div class="highlight"><pre><span></span><code>a                 // valid
CamelCase         // valid
like_under_scores // valid
__also_ok         // valid
_Ok123_321        // valid
_                 // valid

2ab               // not valid
&amp;ade              // not valid
</code></pre></div>
<p>However, we suggest the following <strong>DSLX style rules</strong>, which mirror the
<a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust naming conventions</a>.</p>
<ul>
<li>Functions are <code>written_like_this</code></li>
</ul>
<ul>
<li>User-defined data types are <code>NamesLikeThis</code></li>
</ul>
<ul>
<li>Constant bindings are <code>NAMES_LIKE_THIS</code></li>
</ul>
<ul>
<li><code>_</code> is the "black hole" identifier -- a name that you can bind to but should
    never read from, akin to Rust's wildcard pattern match or Python's "unused
    identifier" convention. It should never be referred to in an expression
    except as a "sink".</li>
</ul>
<p>NOTE Since mutable locals are not supported, there is also
<a href="https://github.com/google/xls/issues/212">support for "tick identifiers"</a>,
where a ' character may appear anywhere after the first character of an
identifier to indicate "prime"; e.g. <code>let state' = update(state);</code>. By
convention ticks usually come at the end of an identifier. Since this is not
part of Rust's syntax, it is considered experimental at this time.</p>
<h2 id="functions">Functions</h2>
<p>Function definitions begin with the keyword <code>fn</code>, followed by the function name,
a parameter list to the function in parenthesis, followed by an <code>-&gt;</code> and the
return type of the function. After this, curly braces denote the begin and end
of the function body.</p>
<p>The list of parameters can be empty.</p>
<p>A single input file can contain many functions.</p>
<p>Simple examples:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">ret3</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">   </span><span class="kt">u32</span>:<span class="mi">3</span><span class="w">   </span><span class="c1">// This function always returns 3.</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">add1</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">1</span><span class="w">  </span><span class="c1">// Returns x + 1, but you knew that!</span>
<span class="p">}</span>
</code></pre></div>
<p>Functions return the result of their last computed expression as their return
value. There are no explicit return statements. By implication, functions return
exactly one expression; they can't return multiple expressions (but this may
change in the future as we migrate towards some Rust semantics).</p>
<p>Tuples should be returned if a function needs to return multiple values.</p>
<h3 id="parameters">Parameters</h3>
<p>Parameters are written as pairs <code>name</code> followed by a colon <code>:</code> followed by the
<code>type</code> of that parameter. Each parameter needs to declare its own type.</p>
<p>Examples:</p>
<div class="highlight"><pre><span></span><code>// a simple parameter x of type u32
   x: u32

// t is a tuple with 2 elements.
//   the 1st element is of type u32
//   the 2nd element is a tuple with 3 elements
//       the 1st element is of type u8
//       the 2nd element is another tuple with 1 element of type u16
//       the 3rd element is of type u8
   t: (u32, (u8, (u16,), u8))
</code></pre></div>
<h3 id="parametric-functions">Parametric Functions</h3>
<p>DSLX functions can be parameterized in terms of the types of its arguments and
in terms of types derived from other parametric values. For instance:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">double</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">self_append</span><span class="o">&lt;</span><span class="n">A</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">double</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="n">B</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="o">++</span><span class="n">x</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">self_append</span><span class="p">(</span><span class="n">u5</span>:<span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>In <code>self_append(bits[5]:1)</code>, we see that <code>A = 5</code> based off of formal argument
instantiation. Using that value, we can evaluate <code>B = double(A=5)</code>. This derived
expression is analogous to C++'s constexpr – a simple expression that can be
evaluated at that point in compilation.</p>
<p>See
<a href="#advanced-understanding-parametricity-constraints-and-unification">advanced understanding</a>
for more information on parametricity.</p>
<h4 id="explicit-parametric-instantiation">Explicit parametric instantiation</h4>
<p>In some cases, parametric values cannot be inferred from function arguments,
such as in the
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/explicit_parametric_simple.x"><code>explicit_parametric_simple.x</code></a>
test:</p>
<div class="highlight"><pre><span></span><code>fn add_one&lt;E:u32, F:u32, G:u32 = E+F&gt;(lhs: bits[E]) -&gt; bits[G] { ... }
</code></pre></div>
<p>For this call to instantiable, both <code>E</code> and <code>F</code> must be specified. Since <code>F</code>
can't be inferred from an argument, we must rely on <em>explicit parametrics</em>:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">add_one</span><span class="o">&lt;</span><span class="kt">u32</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="kt">u32</span>:<span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>This invocation will bind <code>1</code> to <code>E</code>, <code>5</code> to <code>F</code>, and <code>6</code> to <code>G</code>. Note the curly
braces around the expression-defined parametric: simple literals and constant
references do not need braces (but they <em>can</em> have them), but any other
expression requires them.</p>
<h5 id="expression-ambiguity">Expression ambiguity</h5>
<p>Without curly braces, explicit parametric expressions could be ambiguous;
consider the following, slightly changed from the previous example:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">add_one</span><span class="o">&lt;</span><span class="kt">u32</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>Is the statement above computing <code>add_one&lt;1, (2 &gt; 3)&gt;(1)</code>, or is it computing
<code>(add_one&lt;1, 2&gt;(3)) &gt; 1)</code>? Without additional (and subtle and perhaps surprising)
contextual precedence rules, this would be ambiguous and could lead to a parse
error or, even worse, unexpected behavior.</p>
<p>Fortunately, we can look to Rust for inspiration. Rust's const generics RPF
introduced the <code>{ }</code> syntax for disambiguating just this case in generic
specifications. With this, any expressions present in a parametric specification
must be contained within curly braces, as in the original example.</p>
<p>At present, if the braces are omitted, some unpredictable error will occur. Work
to improve this is tracked in
<a href="https://github.com/google/xls/issues/321">XLS GitHub issue #321</a>.</p>
<h3 id="function-calls">Function Calls</h3>
<p>Function calls are expressions and look and feel just like one would expect from
other languages. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">callee</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span><span class="w"> </span><span class="n">y</span>: <span class="nc">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">caller</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">callee</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>If more than one value should be returned by a function, a tuple type should be
returned.</p>
<h2 id="types">Types</h2>
<h3 id="bit-type">Bit Type</h3>
<p>The most fundamental type in DSLX is a variable length bit type denoted as
<code>bits[n]</code>, where <code>n</code> is a constant. For example:</p>
<div class="highlight"><pre><span></span><code>bits[0]   // possible, but, don&#39;t do that

bits[1]   // a single bit
uN[1]     // explicitly noting single bit is unsigned
u1        // convenient shorthand for bits[1]

bits[8]   // an 8-bit datatype, yes, a byte
u8        // convenient shorthand for bits[8]
bits[32]  // a 32-bit datatype
u32       // convenient shorthand for bits[32]
bits[256] // a 256-bit datatype
</code></pre></div>
<p>DSLX introduces aliases for commonly used types, such as <code>u8</code> for an 8-wide bit
type, or <code>u32</code> for a 32-bit wide bit type. These are defined up to <code>u64</code>.</p>
<p>All <code>u*</code>, <code>uN[*]</code>, and <code>bits[*]</code> types are interpreted as unsigned integers.
Signed integers are specified via <code>s*</code> and <code>sN[*]</code>. Similarly to unsigned
numbers, the <code>s*</code> shorthands are defined up to <code>s64</code>. For example:</p>
<div class="highlight"><pre><span></span><code>sN[0]
s0

sN[1]
s1

sN[64]
s64

sN[256]
</code></pre></div>
<p>Signed numbers differ in their behavior from unsigned numbers primarily via
operations like comparisons, (variable width) multiplications, and divisions.</p>
<h4 id="character-constants">Character Constants</h4>
<p>Characters are a special case of bits types: they are implicitly-type as u8.
Characters can be used just as traditional bits:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">add_to_null</span><span class="p">(</span><span class="n">input</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">null</span>:<span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">null</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">add_to_null</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>DSLX character constants support the
<a href="https://doc.rust-lang.org/reference/tokens.html">full Rust set of escape sequences</a> with the exception of unicode.</p>
<h3 id="enum-types">Enum Types</h3>
<p>DSLX supports enumerations as a way of defining a group of related, scoped,
named constants that do not pollute the module namespace. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Opcode</span><span class="w"> </span>: <span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FIRE_THE_MISSILES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">BE_TIRED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">TAKE_A_NAP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">get_my_favorite_opcode</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Opcode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Opcode</span>::<span class="n">FIRE_THE_MISSILES</span>
<span class="p">}</span>
</code></pre></div>
<p>Note the use of the double-colon to reference the enum value. This code
specifies that the enum behaves like a <code>u3</code>: its storage and extension (via
casting) behavior are defined to be those of a <code>u3</code>. Attempts to define an enum
value outside of the representable <code>u3</code> range will produce a compile time error.</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Opcode</span><span class="w"> </span>: <span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="c1">// Causes compile time error!</span>
<span class="p">}</span>
</code></pre></div>
<p>Enums can be compared for equality/inequality, but they do not permit arithmetic
operations, they must be cast to numerical types in order to perform arithmetic:</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Opcode</span>: <span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NOP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">ADD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">same_opcode</span><span class="p">(</span><span class="n">x</span>: <span class="nc">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">Opcode</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w">  </span><span class="c1">// ok</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">next_in_sequence</span><span class="p">(</span><span class="n">x</span>: <span class="nc">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">Opcode</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">  </span><span class="c1">// x+1 == y // does not work, arithmetic!</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u3</span>:<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="p">)</span><span class="w">  </span><span class="c1">// ok, casted first</span>
<span class="p">}</span>
</code></pre></div>
<p>As mentioned above, casting of enum-values works with the same casting/extension
rules that apply to the underlying enum type definition. For example, this cast
will sign extend because the source type for the enum is signed. (See
<a href="#numerical-conversions">numerical conversions</a> for the full description of
extension/truncation behavior.)</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">MySignedEnum</span><span class="w"> </span>: <span class="nc">s3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">LOW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">HIGH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">extend_to_32b</span><span class="p">(</span><span class="n">x</span>: <span class="nc">MySignedEnum</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w">  </span><span class="c1">// Sign-extends because the source type is signed.</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_extend_to_32b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">extend_to_32b</span><span class="p">(</span><span class="n">MySignedEnum</span>::<span class="n">LOW</span><span class="p">),</span><span class="w"> </span><span class="kt">u32</span>:<span class="mh">0xffffffff</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Casting <em>to</em> an enum is also permitted. However, in most cases errors from
invalid casting can only be found at runtime, e.g., in the DSL interpreter or
flagging a fatal error from hardware. Because of that, it is recommended to
avoid such casts as much as possible.</p>
<h3 id="tuple-type">Tuple Type</h3>
<p>A tuple is a fixed-size ordered set, containing elements of heterogeneous types.
Tuples elements can be any type, e.g. bits, arrays, structs, tuples. Tuples may
be empty (an empty tuple is also known as the unit type), or contain one or more
types.</p>
<p>Examples of tuple values:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The unit type, carries no information.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span>

<span class="c1">// A tuple containing two bits-typed elements.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">u4</span>:<span class="mb">0b1101</span><span class="p">);</span>
</code></pre></div>
<p>Example of a tuple type:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The type of a tuple with 2 elements.</span>
<span class="c1">//   the 1st element is of type u32</span>
<span class="c1">//   the 2nd element is a tuple with 3 elements</span>
<span class="c1">//       the 1st element is of type u8</span>
<span class="c1">//       the 2nd element is another tuple with 1 element of type u16</span>
<span class="c1">//       the 3rd element is of type u8</span>
<span class="k">type</span> <span class="nc">MyTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,),</span><span class="w"> </span><span class="kt">u8</span><span class="p">));</span>
</code></pre></div>
<p>To access individual tuple elements use simple indices, starting at 0. For
example, to access the second element of a tuple (index 1):</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_tuple_access</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Such indices can only be numeric literals; parametric symbols are not allowed.</p>
<p>Tuples can be "destructured", similarly to how pattern matching works in <code>match</code>
expressions, which provides a convenient syntax to name elements of a tuple for
subsequent use. See <code>a</code> and <code>b</code> in the following:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_tuple_destructure</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Just as values can be discarded in a <code>let</code> by using the "black hole identifier"
<code>_</code>, don't-care values can also be discarded when destructuring a tuple:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_black_hole</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="struct-types">Struct Types</h3>
<p>Structures are similar to tuples, but provide two additional capabilities: we
name the slots (i.e. struct fields have names while tuple elements only have
positions), and we introduce a new type.</p>
<p>The following syntax is used to define a struct:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span>
<span class="p">}</span>
</code></pre></div>
<p>Once a struct is defined it can be constructed by naming the fields in any
order:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_struct_equality</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">64</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>There is a simple syntax when creating a struct whose field names match the
names of in-scope values:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_struct_equality</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">64</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Struct fields can also be accessed with "dot" syntax:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">f</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">64</span><span class="w"> </span><span class="p">})</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">106</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that structs cannot be mutated "in place", the user must construct new
values by extracting the fields of the original struct mixed together with new
field values, as in the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">z</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">update_y</span><span class="p">(</span><span class="n">p</span>: <span class="nc">Point3</span><span class="p">,</span><span class="w"> </span><span class="n">new_y</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="nc">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">new_y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span>: <span class="nc">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">z</span>: <span class="kt">u32</span>:<span class="mi">256</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">update_y</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">128</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">z</span>: <span class="kt">u32</span>:<span class="mi">256</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">want</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="struct-update-syntax">Struct Update Syntax</h4>
<p>The DSL has syntax for conveniently producing a new value with a subset of
fields updated to reduce verbosity. The "struct update" syntax is:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">z</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">update_y</span><span class="p">(</span><span class="n">p</span>: <span class="nc">Point3</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">update_x_and_y</span><span class="p">(</span><span class="n">p</span>: <span class="nc">Point3</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="parametric-structs">Parametric Structs</h4>
<p>DSLX also supports parametric structs. For more information on how
type-parametricity works, see the <a href="#parametric-functions">parametric functions</a>
section.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">double</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="w"> </span><span class="p">}</span>

<span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">N</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">double</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">],</span>
<span class="w">  </span><span class="n">y</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">M</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">make_point</span><span class="o">&lt;</span><span class="n">A</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">],</span><span class="w"> </span><span class="n">y</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">B</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_struct_construction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_point</span><span class="p">(</span><span class="kt">u16</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u16</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="understanding-nominal-typing">Understanding Nominal Typing</h4>
<p>As mentioned above, a struct definition introduces a new type. Structs are
nominally typed, as opposed to structurally typed (note that tuples are
structurally typed). This means that structs with different names have different
types, regardless of whether those structs have the same structure (i.e. even
when all the fields of two structures are identical, those structures are a
different type when they have a different name).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Coordinate</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_ok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">64</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">106</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_type_checker_error</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">Coordinate</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span>:<span class="mi">64</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">106</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="array-type">Array Type</h3>
<p>Arrays can be constructed via bracket notation. All values that make up the
array must have the same type. Arrays can be indexed with indexing notation
(<code>a[i]</code>) to retrieve a single element.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">a</span>: <span class="kt">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">i</span>: <span class="nc">u1</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">64</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Make an array with &quot;bracket notation&quot;.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">my_array</span>: <span class="kt">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span>:<span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span>:<span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>Because arrays with repeated trailing elements are common, the DSL supports
ellipsis (<code>...</code>) at the end of an array to fill the remainder of the array with
the last noted element. Because the compiler must know how many elements to
fill, in order to use the ellipsis the type must be annotated explicitly as
shown.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">make_array</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.]</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_make_array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">],</span><span class="w"> </span><span class="n">make_array</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">64</span><span class="p">],</span><span class="w"> </span><span class="n">make_array</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">64</span><span class="p">));</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>TODO(meheff): Explain arrays and the intricacies of our bits type interpretation
and how it affects arrays of bits etc.</p>
<h4 id="character-string-constants">Character String Constants</h4>
<p>Character strings are a special case of array types, being implicitly-sized
arrays of u8 elements. String constants can be used just as traditional arrays:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">add_one</span><span class="o">&lt;</span><span class="n">N</span>: <span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span>: <span class="kt">u8</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">u8</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="n">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">}(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="s">&quot;bcdef&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">add_one</span><span class="p">(</span><span class="s">&quot;abcde&quot;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>DSLX string constants support the
<a href="https://doc.rust-lang.org/reference/tokens.html">full Rust set of escape sequences</a> -
note that unicode escapes get encoded to their UTF-8 byte sequence. In other
words, the sequence <code>\u{10CB2F}</code> will result in an array with hexadecimal values
<code>F4 8C AC AF</code>.</p>
<p>Moreover, string can be composed of <a href="#character-constants">characters</a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">string_composed_characters</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u8</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[</span><span class="sc">&#39;X&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;L&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;S&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;r&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;k&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;s&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;!&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="s">&quot;XLS rocks!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">string_composed_characters</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="type-aliases">Type Aliases</h3>
<p>DLSX supports the definition of type aliases.</p>
<p>Type aliases can be used to provide a more human-readable name for an existing
type. The new name is on the left, the existing name on the right:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="nc">Weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span><span class="p">;</span>
</code></pre></div>
<p>We can create an alias for an imported type:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Note: this imports an external file in the codebase.</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span>

<span class="k">type</span> <span class="nc">MyEnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod_imported</span>::<span class="n">MyEnum</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MyEnum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyEnum</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="n">MyEnum</span>::<span class="n">FOO</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">64</span><span class="p">),</span><span class="w"> </span><span class="n">MyEnum</span>::<span class="n">BAR</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>Type aliases can also provide a descriptive name for a tuple type (which is
otherwise anonymous). For example, to define a tuple type that represents a
float number with a sign bit, an 8-bit mantissa, and a 23-bit mantissa, one
would write:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="nc">F32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">u23</span><span class="p">);</span>
</code></pre></div>
<p>After this definition, the <code>F32</code> may be used as a type annotation
interchangeably with <code>(u1, u8, u23)</code>.</p>
<p>Note, however, that structs are generally preferred for this purpose, as they
are more readable and users do not need to rely on tuple elements having a
stable order in the future (i.e., they are resilient to refactoring).</p>
<h3 id="type-casting">Type Casting</h3>
<p>Bit types can be cast from one bit-width to another with the <code>as</code> keyword. Types
can be widened (increasing bit-width), narrowed (decreasing bit-width) and/or
changed between signed and unsigned. Some examples are found below. See
<a href="#numerical-conversions">Numerical Conversions</a> for a description of the
semantics.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_narrow_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">twelve</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u4</span>:<span class="mb">0b1100</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">twelve</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_widen_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">three</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u4</span><span class="p">,</span><span class="w"> </span><span class="n">u4</span>:<span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_narrow_signed_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">negative_seven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s4</span>:<span class="mb">0b1001</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">negative_seven</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_widen_signed_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">negative_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span>:<span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">negative_one</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span>:<span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_widen_to_unsigned</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">negative_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span>:<span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">negative_one</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span>:<span class="mb">0b111</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_widen_to_signed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">three</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span>:<span class="mb">0b011</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="type-checking-and-inference">Type Checking and Inference</h3>
<p>DSLX performs type checking and produces an error if types in an expression
don't match up.</p>
<p><code>let</code> expressions also perform type inference, which is quite convenient. For
example, instead of writing:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ch</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
</code></pre></div>
<p>one can write the following, as long as the types can be properly inferred:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
</code></pre></div>
<p>Note that type annotations can still be added and be used for program
understanding, as they they will be checked by DSLX.</p>
<h3 id="type-inference-details">Type Inference Details</h3>
<h4 id="type-inference-background">Type Inference Background</h4>
<p>All expressions in the language's expression grammar have a deductive type
inference rule. The types must be known for inputs to an
operator/function<sup id="fnref:usebeforedef"><a class="footnote-ref" href="#fn:usebeforedef">1</a></sup> and every expression has a way to determine its
type from its operand expressions.</p>
<p>DSLX uses deductive type inference to check the types present in the program.
Deductive type inference is a set of (typically straight-forward) deduction
rules: Hindley-Milner style deductive type inference determines the result type
of a function with a rule that only observes the input types to that function.
(Note that operators like '+' are just slightly special functions in that they
have pre-defined special-syntax-rule names.)</p>
<h4 id="bindings-and-environment">Bindings and Environment</h4>
<p>In DSLX code, the "environment" where names are bound (sometimes also referred
to as a symbol table) is called the
<a href="https://github.com/google/xls/tree/main/xls/dslx/bindings.h"><code>Bindings</code></a> -- it maps
identifiers to the AST node that defines the name (<code>{string: AstNode}</code>), which
can be combined with a mapping from AST node to its deduced type (<code>{AstNode:
ConcreteType}</code>) to resolve the type of an identifier in the program. <code>Let</code> is
one of the key nodes that populates these <code>Bindings</code>, but anything that creates
a bound name does as well (e.g. parameters, for loop induction variables, etc.).</p>
<h4 id="operator-example">Operator Example</h4>
<p>For example, consider the binary (meaning takes two operands) / infix (meaning
it syntactically is placed in the center of its operands) '+' operator. The
simple deductive type inference rule for '+' is:</p>
<p><code>(T, T) -&gt; T</code></p>
<p>Meaning that the left hand side operand to the '+' operator is of some type
(call it T), the right hand side operand to the '+' operator must be of that
same type, T, and the result of that operator is then (deduced) to be of the
same type as its operands, T.</p>
<p>Let's instantiate this rule in a function:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">add_wrapper</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">y</span>: <span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</code></pre></div>
<p>This function wraps the '+' operator. It presents two arguments to the '+'
operator and then checks that the annotated return type on <code>add_wrapper</code> matches
the deduced type for the body of that function; that is, we ask the following
question of the '+' operator (since the type of the operands must be known at
the point the add is performed):</p>
<p><code>(bits[2], bits[2]) -&gt; ?</code></p>
<p>To resolve the '?' the following procedure is being used:</p>
<ul>
<li>Pattern match the rule given above <code>(T, T) -&gt; T</code> to determine the type T:
    the left hand side operand is <code>bits[2]</code>, called T.</li>
<li>Check that the right hand side is also that same T, which it is: another
    <code>bits[2]</code>.</li>
<li>Deduce that the result type is that same type T: <code>bits[2]</code>.</li>
<li>That becomes the return type of the body of the function. Check that it is
    the same type as the annotated return type for the function, and it is!</li>
</ul>
<p>The function is annotated to return <code>bits[2]</code>, and the deduced type of the body
is also <code>bits[2]</code>. Qed.</p>
<h4 id="type-errors">Type errors</h4>
<p>A <strong>type error</strong> would occur in the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">add_wrapper</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">y</span>: <span class="nc">bits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</code></pre></div>
<p>Applying the type deduction rule for '+' finds an inconsistency. The left hand
side operand has type <code>bits[2]</code>, called T, but the right hand side is <code>bits[3]</code>,
which is not the same as T. Because the deductive type inference rule does not
say what to do when the operand types are different, it results in a type error
which is flagged at this point in the program.</p>
<h4 id="let-bindings-names-and-the-environment">Let Bindings, Names, and the Environment</h4>
<p>In the DSL, <code>let</code> is an expression. It may not seem obvious at a glance, but it
is! As a primer see the <a href="#type-inference-background">type inference background</a>
and how <a href="#bindings-and-environment">names are resolved in an environment</a>.</p>
<p>"let" expressions are of the (Rust-inspired) form:</p>
<p><code>let $name: $annotated_type = $expr; $subexpr</code></p>
<p><code>$name</code> gets "bound" to a value of type <code>$annotated_type</code>. The <code>let</code> typecheck
rule must <strong>both</strong> check that <code>$expr</code> is of type <code>$annotated_type</code>, as well as
determine the type of <code>$subexpr</code>, which is the type of the overall "let
expression".</p>
<p>In this example, the result of the <code>let</code> expression is the return value --
<code>$subexpr</code> (<code>x+x</code>) can use the <code>$name</code> (<code>x</code>) which was "bound":</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">y</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span>
<span class="w">  </span><span class="n">x</span><span class="o">+</span><span class="n">x</span>
<span class="p">}</span>
</code></pre></div>
<p>If we invoke <code>main(u32:2)</code> we will the evaluate <code>let</code> expression -- it creates a
binding of <code>x</code> to the value <code>u64:2</code>, and then evaluates the expression <code>x+x</code> in
that environment, so the result of the <code>let</code> expression's <code>$subexpr</code> is <code>u64:4</code>.</p>
<h2 id="statements">Statements</h2>
<h3 id="imports">Imports</h3>
<p>DSLX modules can import other modules via the <code>import</code> keyword. Circular imports
are not permitted (the dependencies among DSLX modules must form a DAG, as in
languages like Go).</p>
<p>The import statement takes the following form (note the lack of semicolon):</p>
<div class="highlight"><pre><span></span><code>import path.to.my.imported_module
</code></pre></div>
<p>With that statement, the module will be accessible as (the trailing identifier
after the last dot) <code>imported_module</code>; e.g. the program can refer to
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code>.</p>
<p>NOTE Imports are relative to the Bazel "depot root" -- for external use of the
tools a <code>DSLX_PATH</code> will be exposed, akin to a <code>PYTHONPATH</code>, for users to
indicate paths where were should attempt module discovery.</p>
<p>NOTE Importing <strong>does not</strong> introduce any names into the current file other than
the one referred to by the import statement. That is, if <code>imported_module</code> had a
constant defined in it <code>FOO</code>, this is referred to via <code>imported_module::FOO</code>,
<code>FOO</code> does not "magically" get put in the current scope. This is analogous to
how wildcard imports are discouraged in other languages (e.g. <code>from import *</code> in
Python) on account of leading to "namespace pollution" and needing to specify
what happens when names conflict.</p>
<p>If you want to change the name of the imported module (for reference inside of
the importing file) you can use the <code>as</code> keyword:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">im</span>
</code></pre></div>
<p>Just using the above construct,
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code> is <em>not</em> valid, only
<code>im::IMPORTED_MODULE_PUBLIC_CONSTANT</code>. However, both statements can be used on
different lines:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span>
<span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">im</span>
</code></pre></div>
<p>In this case, either <code>im::IMPORTED_MODULE_PUBLIC_CONSTANT</code> or
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code> can be used to refer to the
same thing.</p>
<p>Here is an example using the same function via two different aliases for the
same module:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Note: this imports an external file in the codebase under two different</span>
<span class="c1">// names.</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">mi</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span>: <span class="nc">u3</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mod_imported</span>::<span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mi</span>::<span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b001</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="public-module-members">Public module members</h3>
<p>Module members are private by default and not accessible from any importing
module. To make a member public/visible to importing modules, the <code>pub</code> keyword
must be added as a prefix; e.g.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span><span class="w">      </span><span class="c1">// Not accessible to importing modules.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">64</span><span class="p">;</span><span class="w">  </span><span class="c1">// Accessible to importing modules.</span>
</code></pre></div>
<p>This applies to other things defined at module scope as well: functions, enums,
type aliases, etc.</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">mi</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span>: <span class="nc">u3</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mod_imported</span>::<span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mi</span>::<span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b001</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="const">Const</h3>
<p>The <code>const</code> keyword is used to define module-level constant values. Named
constants should be usable anywhere a literal value can be used:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">match_const</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_match_const_not_binding</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">match_const</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">match_const</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">match_const</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">));</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">h</span><span class="p">(</span><span class="n">t</span>: <span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)))</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">FOO</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">7</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_match_nested</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">))));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="kt">u8</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">))));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="kt">u8</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">))));</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="expressions">Expressions</h2>
<h3 id="literals">Literals</h3>
<p>DSLX supports construction of literals using the syntax <code>Type:Value</code>. For
example <code>u16:1</code> is a 16-wide bit array with its least significant bit set to
one. Similarly <code>s8:12</code> is an 8-wide bit array with its least significant four
bits set to <code>1100</code>.</p>
<p>DSLX supports initializing using binary, hex or decimal syntax. So</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_literal_initialization</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span>:<span class="mb">0b00001100</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span>:<span class="mh">0x0c</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>When constructing literals DSLX will trigger an error if the constant will not
fit in a bit array of the annotated sized, so for example trying to construct
the literal <code>u8:256</code> will trigger an error of the form:</p>
<p><code>TypeInferenceError: uN[8] Value '256' does not fit in the bitwidth of a uN[8]
(8)</code></p>
<p>But what about <code>s8:128</code> ? This is a valid literal, even though a signed 8-bit
integer cannot represent it. The following code offers a clue.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_signed_literal_initialization</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span>:<span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span>:<span class="o">-</span><span class="mi">128</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span>:<span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span>:<span class="mb">0b10000000</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>What is happening here is that, 128 is being used as a bit pattern rather than
as the number 128 to initialize the literal. It is only when the bit pattern
cannot fit in the width of the literal that an error is triggered.</p>
<p><strong>Note that behaviour is different from Rust, where it will trigger an error,
and the fact that DSLX considers this valid may change in the
<a href="https://github.com/google/xls/issues/471">future</a>.</strong></p>
<h3 id="unary-expressions">Unary Expressions</h3>
<p>DSLX supports three types of unary expressions:</p>
<ul>
<li>bit-wise not (the <code>!</code> operator)</li>
<li>negate (the <code>-</code> operator, computes the two's complement negation)</li>
</ul>
<h3 id="binary-expressions">Binary Expressions</h3>
<p>DSLX supports a familiar set of binary expressions. There are two categories of
binary expressions. A category where both operands to the expression must be of
the same bit type (i.e., not arrays or tuples), and a category where the
operands can be of arbitrary bit types (i.e. shift expressions).</p>
<ul>
<li>shift-right (<code>&gt;&gt;</code>)</li>
<li>shift-left (<code>&lt;&lt;</code>)</li>
<li>bit-wise or (<code>|</code>)</li>
<li>bit-wise and (<code>&amp;</code>)</li>
<li>add (<code>+</code>)</li>
<li>subtract (<code>-</code>)</li>
<li>xor (<code>^</code>)</li>
<li>multiply (<code>*</code>)</li>
<li>logical or (<code>||</code>)</li>
<li>logical and (<code>&amp;&amp;</code>)</li>
</ul>
<h4 id="shift-expressions">Shift Expressions</h4>
<p>Shift expressions include: shift-right (logical) and shift-left. These are
binary operations that don't require the same type on the left and right hand
side. The right hand side must be unsigned, but it does not need to be the same
type or width as the left hand side, i.e. the type signature for these
operations is: <code>(xN[M], uN[N]) -&gt; xN[M]</code>. If the right hand side is a literal
value it does not need to be type annotated. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">shr_two</span><span class="p">(</span><span class="n">x</span>: <span class="nc">s32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">s32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that, as in Rust, the semantics of the shift-right (<code>&gt;&gt;</code>) operation depends
on the signedness of the left hand side. For a signed-type left hand side, the
shift-right (<code>&gt;&gt;</code>) operation performs a shift-right arithmetic and, for a
unsigned-type left hand side, the shift-right (<code>&gt;&gt;</code>) operation performs a
shift-right (logical).</p>
<h3 id="comparison-expressions">Comparison Expressions</h3>
<p>For comparison expressions the types of both operands must match. However these
operations return a result of type <code>bits[1]</code>, aka <code>bool</code>.</p>
<ul>
<li>equal (<code>==</code>)</li>
<li>not-equal (<code>!=</code>)</li>
<li>greater-equal (<code>&gt;=</code>)</li>
<li>greater (<code>&gt;</code>)</li>
<li>less-equal (<code>&lt;=</code>)</li>
<li>less (<code>&lt;</code>)</li>
</ul>
<h3 id="concat-expression">Concat Expression</h3>
<p>Bitwise concatenation is performed with the <code>++</code> operator. The value on the left
hand side becomes the most significant bits, the value on the right hand side
becomes the least significant bits. These may be chained together as shown
below:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_bits_concat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mb">0b11000000</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b11</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u6</span>:<span class="mb">0b000000</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mb">0b00000111</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b00</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u6</span>:<span class="mb">0b000111</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u6</span>:<span class="mb">0b100111</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span>:<span class="mi">1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b00</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u3</span>:<span class="mb">0b111</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u6</span>:<span class="mb">0b001000</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span>:<span class="mi">0</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b01</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u3</span>:<span class="mb">0b000</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mh">0xdeadbeef</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span>:<span class="mh">0xdead</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="kt">u16</span>:<span class="mh">0xbeef</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="block-expressions">Block Expressions</h3>
<p>Block expressions enable subordinate scopes to be defined, e.g.:</p>
<div class="highlight"><pre><span></span><code>let a = {
  let b = u32:1;
  b + u32:3
};
</code></pre></div>
<p>The value of a block expression is that of its last contained expression, or (),
if a final expression is omitted:</p>
<div class="highlight"><pre><span></span><code>let a = { let b = u32:1; };
</code></pre></div>
<p>In the above case, <code>a</code> is equal to <code>()</code>.</p>
<p>Since DSLX does not currently have the concept of lifetimes, and since names can
be rebound (i.e., there's no concept of mutability, allowing <code>let a = u32:0; let
a = u32:1;</code>), blocks are primarily for readability at this time, (side from
their use as the "body" of functions and loops).</p>
<h3 id="match-expression">Match Expression</h3>
<p>Match expressions permit "pattern matching" on data, like a souped-up switch
statement. It can both test for values (like a conditional guard) and bind
values to identifiers for subsequent use. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span>: <span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="kt">u32</span>:<span class="mi">77</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>If the first member of the tuple is the value is <code>42</code>, we pass the second tuple
member back as-is from the function. Otherwise, we add <code>77</code> to the value and
return that. The <code>_</code> symbolizes "I don't care about this value".</p>
<p>Just like literal constants, pattern matching can also match via named
constants; For example, consider this variation on the above:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">MY_FAVORITE_NUMBER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span>: <span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">MY_FAVORITE_NUMBER</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="kt">u32</span>:<span class="mi">77</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This also works with nested tuples; for example:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">MY_FAVORITE_NUMBER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">42</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span>: <span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)))</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">MY_FAVORITE_NUMBER</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">7</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Here we use a "catch all" wildcard pattern in the last match arm to ensure the
match expression always matches the input somehow.</p>
<h4 id="redundant-patterns">Redundant Patterns</h4>
<p><code>match</code> will flag an error if a <em>syntactically identical</em> pattern is typed
twice; e.g.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// Identical pattern!</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Only the first pattern will ever match, so it is fully redundant (and therefore
likely a user error they'd like to be informed of). Note that <em>equivalent</em> but
not <em>syntactically identical</em> patterns will not be flagged in this way.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">BAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// Compares `==` to `FOO`.</span>
<span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">BAR</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// _Equivalent_ pattern, but not syntactically identical.</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span>:<span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="let-expression"><code>let</code> Expression</h3>
<p>let expressions work the same way as let expressions in other functional
languages (such as the ML family languages). let expressions provide a nested,
lexically-scoped, list of binding definitions. The scope of the binding is the
expression on the right hand side of the declaration. For example:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">;</span>
<span class="n">b</span>
</code></pre></div>
<p>would bind (and return as a value) the value <code>6</code> which corresponds to <code>b</code> when
evaluated. In effect there is little difference to other languages like C/C++ or
Python, where the same result would be achieved with code similar to this:</p>
<div class="highlight"><pre><span></span><code><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">return</span> <span class="n">b</span>
</code></pre></div>
<p>However, <code>let</code> expressions are lexically scoped. In above example, the value <code>3</code>
is bound to <code>a</code> only during the combined let expression sequence. There is no
other type of scoping in DSLX.</p>
<h3 id="if-expression">If Expression</h3>
<p>DSLX offers an <code>if</code> expression, which is very similar to the Rust <code>if</code>
expression. Blueprint:</p>
<div class="highlight"><pre><span></span><code>if condition { consequent } else { alternate }
</code></pre></div>
<p>This corresponds to the C/C++ ternary <code>?:</code> operator:</p>
<div class="highlight"><pre><span></span><code>condition ? consequent : alternate
</code></pre></div>
<p>Note: both the <code>if</code> and <code>else</code> are <em>required</em> to be present, as with the <code>?:</code>
operator, unlike a C++ <code>if</code> statement. This is because it is an <em>expression</em>
that <em>produces</em> a result value, not a <em>statement</em> that causes a mutating effect.</p>
<p>Furthermore, you can have multiple branches via <code>else if</code>:</p>
<div class="highlight"><pre><span></span><code>if condition0 { consequent0 } else if condition1 { consequent1 } else { alternate }
</code></pre></div>
<p>which corresponds to the C/C++:</p>
<div class="highlight"><pre><span></span><code>condition0 ? consequent0 : (contition1 ? consequent1 : alternate)
</code></pre></div>
<p>Note: a <code>match</code> expression can often be a better choice than having a long
<code>if/else if/.../else</code> chain.</p>
<p>For example, in the FP adder module (modules/fp32_add_2.x), there is code like
the following:</p>
<div class="highlight"><pre><span></span><code>[...]
let result_fraction = if wide_exponent &lt; u9:255 { result_fraction } else { u23:0 };
let result_exponent = if wide_exponent &lt; u9:255 { wide_exponent as u8 } else { u8:255 };
</code></pre></div>
<h3 id="iterable-expression">Iterable Expression</h3>
<p>Iterable expressions are used in counted for loops. DSLX currently supports two
types of iterable expressions, <code>range</code> and <code>enumerate</code>.</p>
<p>The range expression <code>m..n</code> represents a range of values from m to n-1.
This example will run from 0 to 4 (exclusive):</p>
<div class="highlight"><pre><span></span><code>for (i, accum): (u32, u32) in u32:0..u32:4 {
</code></pre></div>
<p>There also exists a <code>range()</code> builtin function that performs the same operation.</p>
<p><code>enumerate</code> iterates over the elements of an array type and produces pairs of
<code>(index, value)</code>, similar to enumeration constructs in languages like Python or
Go.</p>
<p>In the example below, the loop will iterate 8 times, following the array
dimension of <code>x</code>. Each iteration produces a tuple with the current index (<code>i</code>
ranging from 0 to 7) and the value at the index (<code>e = x[i]</code>).</p>
<div class="highlight"><pre><span></span><code>fn prefix_scan_eq(x: u32[8]) -&gt; bits[8,3] {
  let (_, _, result) =
    for ((i, e), (prior, count, result)): ((u32, u32), (u32, u3, bits[8,3]))
        in enumerate(x) {...
</code></pre></div>
<h3 id="for-expression">for Expression</h3>
<p>DSLX currently supports synthesis of "counted" for loops (loops that have a
clear upper bound on their number of iterations). These loops are capable of
being generated as unrolled pipeline stages: when generating a pipeline, the XLS
compiler will unroll and specialize the iterations.</p>
<p>NOTE In the future support for loops with an unbounded number of iterations may
be permitted, but will only be possible to synthesize as a time-multiplexed
implementation, since pipelines cannot be unrolled indefinitely.</p>
<h4 id="blueprint">Blueprint</h4>
<div class="highlight"><pre><span></span><code>for (index, accumulator): (type-of-index, type-of-accumulator) in iterable {
   body-expression
} (initial-accumulator-value)
</code></pre></div>
<p>The type annotation in the above "blueprint" is optional, but often helpful to
include for increased clarity.</p>
<p>Because DSLX is a pure dataflow description, a for loop is an expression that
produces a value. As a result, you grab the output of a for loop just like any
other expression:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">final_accum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="kt">u32</span>:<span class="mi">8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">new_accum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">accum</span><span class="p">);</span>
<span class="w">  </span><span class="n">new_accum</span>
<span class="p">}(</span><span class="n">init_accum</span><span class="p">);</span>
</code></pre></div>
<p>Conceptually the for loop "evolves" the accumulator as it iterates, and
ultimately pops it out as the result of its evaluation.</p>
<h4 id="examples">Examples</h4>
<p>Add up all values from 0 to 4 (exclusive). Note that we pass the accumulator's
initial value in as a parameter to this expression.</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">)</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="kt">u32</span>:<span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span>
<span class="p">}(</span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>To add up values from 7 to 11 (exclusive), one would write:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">7</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">)</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="kt">u32</span>:<span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span>
<span class="p">}(</span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>"Loop invariant" values (values that do not change as the loop runs) can be used
in the loop body, for example, note the use of <code>outer_thing</code> below:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">outer_thing</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">42</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">)</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="kt">u32</span>:<span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">outer_thing</span>
<span class="p">}(</span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>Both the index and accumulator can be of any valid type, in particular, the
accumulator can be a tuple type, which is useful for evolving a bunch of values.
For example, this for loop "evolves" two arrays:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">ys</span><span class="p">))</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="kt">u32</span>:<span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">..</span><span class="p">.</span>
<span class="p">}((</span><span class="n">init_xs</span><span class="p">,</span><span class="w"> </span><span class="n">init_ys</span><span class="p">))</span>
</code></pre></div>
<p>Note in the above example arrays are dataflow values just like anything else. To
conditionally update an array every other iteration:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="nc">u4</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="o">..</span><span class="kt">u32</span>:<span class="mi">8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Update every other cell with the square of the index.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">}</span>
<span class="p">}(</span><span class="n">u4</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>:<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.]);</span>
</code></pre></div>
<h3 id="numerical-conversions">Numerical Conversions</h3>
<p>DSLX adopts the
<a href="https://doc.rust-lang.org/1.30.0/book/first-edition/casting-between-types.html">Rust rules</a>
for semantics of numeric casts:</p>
<ul>
<li>Casting from larger bit-widths to smaller bit-widths will truncate (to the
    LSbs).
    *   This means that truncating signed values does not preserve the previous
        value of the sign bit.</li>
<li>Casting from a smaller bit-width to a larger bit-width will zero-extend if
    the source is unsigned, sign-extend if the source is signed.</li>
<li>Casting from a bit-width to its own bit-width, between signed/unsigned, is a
    no-op.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_numerical_conversions</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s8</span>:<span class="o">-</span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span>:<span class="mh">0xfe</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Sign extension (source type is signed).</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s32</span>:<span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mh">0xfffffffe</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s16</span>:<span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s16</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u16</span>:<span class="mh">0xfffe</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Zero extension (source type is unsigned).</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s32</span>:<span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Nop (bitwidth is unchanged).</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span>:<span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s8</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span>:<span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s8</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span>:<span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span>:<span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s8</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="array-conversions">Array Conversions</h3>
<p>Casting to an array takes bits from the MSb to the LSb; that is, the group of
bits including the MSb ends up as element 0, the next group ends up as element
1, and so on.</p>
<p>Casting from an array to bits performs the inverse operation: element 0 becomes
the MSbs of the resulting value.</p>
<p>All casts between arrays and bits must have the same total bit count.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">cast_to_array</span><span class="p">(</span><span class="n">x</span>: <span class="nc">u6</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">cast_from_array</span><span class="p">(</span><span class="n">a</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">u6</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u6</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">concat_arrays</span><span class="p">(</span><span class="n">a</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">u2</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">b</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_cast_to_array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a_value</span>: <span class="nc">u6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span>:<span class="mb">0b011011</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_to_array</span><span class="p">(</span><span class="n">a_value</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a_array</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Note: converting back from array to bits gives the original value.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="n">cast_from_array</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b_value</span>: <span class="nc">u6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span>:<span class="mb">0b111001</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b_array</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_to_array</span><span class="p">(</span><span class="n">b_value</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">b_array</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">b_value</span><span class="p">,</span><span class="w"> </span><span class="n">cast_from_array</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Concatenation of bits is analogous to concatenation of their converted</span>
<span class="w">  </span><span class="c1">// arrays. That is:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">//  convert(concat(a, b)) == concat(convert(a), convert(b))</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">concat_value</span>: <span class="nc">u12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_value</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">b_value</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">concat_array</span>: <span class="nc">u2</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concat_value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">concat_array</span><span class="p">,</span><span class="w"> </span><span class="n">concat_arrays</span><span class="p">(</span><span class="n">a_array</span><span class="p">,</span><span class="w"> </span><span class="n">b_array</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Show a few classic &quot;endianness&quot; example using 8-bit array values.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mh">0xdeadbeef</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>:<span class="p">[</span><span class="mh">0xde</span><span class="p">,</span><span class="w"> </span><span class="mh">0xad</span><span class="p">,</span><span class="w"> </span><span class="mh">0xbe</span><span class="p">,</span><span class="w"> </span><span class="mh">0xef</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u16</span>:<span class="mh">0xbeef</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>:<span class="p">[</span><span class="mh">0xbe</span><span class="p">,</span><span class="w"> </span><span class="mh">0xef</span><span class="p">]);</span>

<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="bit-slice-expressions">Bit Slice Expressions</h3>
<p>DSLX supports Python-style bit slicing over <em>unsigned</em> bits types. Note that
bits are numbered 0..N starting "from the right (as you would write it on
paper)" -- least significant bit, AKA LSb -- for example, for the value
<code>u7:0b100_0111</code>:</p>
<div class="highlight"><pre><span></span><code>    Bit    6 5 4 3 2 1 0
  Value    1 0 0 0 1 1 1
</code></pre></div>
<p>A slice expression <code>[N:M]</code> means to get from bit <code>N</code> (inclusive) to bit <code>M</code>
exclusive. The start and limit in the slice expression must be signed integral
values.</p>
<p>Aside: This can be confusing, because the <code>N</code> stands to the left of <code>M</code> in the
expression, but bit <code>N</code> would be to the 'right' of <code>M</code> in the classical bit
numbering. Additionally, this is not the case in the classical array
visualization, where element 0 is usually drawn on the left.</p>
<p>For example, the expression <code>[0:2]</code> would yield:</p>
<div class="highlight"><pre><span></span><code>    Bit    6 5 4 3 2 1 0
  Value    1 0 0 0 1 1 1
                     ^ ^  included
                   ^      excluded

  Result:  0b11
</code></pre></div>
<p>Note that, as of now, the indices for this <code>[N:M]</code> form must be literal numbers
(so the compiler can determine the width of the result). To perform a slice with
a non-literal-number start position, see the <code>+:</code> form described below.</p>
<p>The slicing operation also support the python style slices with offsets from
start or end. To visualize, one can think of <code>x[ : -1]</code> as the equivalent of
<code>x[from the start : bitwidth - 1]</code>. Correspondingly, <code>x[-1 : ]</code> can be
visualized as <code>[ bitwidth - 1 : to the end]</code>.</p>
<p>For example, to get all bits, <em>except</em> the MSb (from the beginning, until the
top element minus 1):</p>
<div class="highlight"><pre><span></span><code><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>
<p>Or to get the two most significant bits:</p>
<div class="highlight"><pre><span></span><code><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span>:<span class="p">]</span>
</code></pre></div>
<p>This results in the nice property that a the original complete value can be
sliced into complementary slices such as <code>:-2</code> (all but the two most significant
bits) and <code>-2:</code> (the two most significant bits):</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">slice_into_two_pieces</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u5</span>:<span class="mb">0b11000</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="w"> </span><span class="n">hi</span><span class="p">)</span>: <span class="p">(</span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span>:<span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span>:<span class="mb">0b000</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="width-slice">Width Slice</h4>
<p>There is also a "width slice" form <code>x[start +: bits[N]]</code> - starting from a
specified bit, slice out the next <code>N</code> bits. This is equivalent to:
<code>bits[N]:(x &gt;&gt; start)</code>. The type can be specified as either signed or unsigned;
e.g. <code>[start +: s8]</code> will produce an 8-bit signed value starting at <code>start</code>,
whereas <code>[start +: u4]</code> will produce a 4-bit unsigned number starting at
<code>start</code>.</p>
<p><a href="https://github.com/google/xls/tree/main/xls/dslx/tests/bit_slice_syntax.x">Here are many more examples</a>:</p>
<h4 id="bit-slice-examples">Bit Slice Examples</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// Identity function helper.</span>
<span class="k">fn</span> <span class="nf">id</span><span class="o">&lt;</span><span class="n">N</span>: <span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_bit_slice_syntax</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span>:<span class="mb">0b100111</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Slice out two bits.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span>:<span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span>:<span class="mi">3</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span>:<span class="mi">4</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b00</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span>:<span class="mi">5</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice out three bits.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span>:<span class="mi">3</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b011</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span>:<span class="mi">4</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span>:<span class="mi">5</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span>:<span class="mi">6</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice out from the end.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span>:<span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span>:<span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span>:<span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span>:<span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span>:<span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span>:<span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u4</span>:<span class="mb">0b1001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span>:<span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u4</span>:<span class="mb">0b1001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span>:<span class="mi">6</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice both relative to the end (MSb).</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span>:<span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span>:<span class="o">-</span><span class="mi">4</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice out from the beginning (LSb).</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u5</span>:<span class="mb">0b00111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u4</span>:<span class="mb">0b0111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span>:<span class="o">-</span><span class="mi">5</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slicing past the end just means we hit the end (as in Python).</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span>:<span class="mi">7</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span>:<span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span>:<span class="o">-</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span>:<span class="o">-</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">6</span>:<span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">6</span>:<span class="mi">7</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span>:<span class="o">-</span><span class="mi">5</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice of a slice.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span>:<span class="mi">4</span><span class="p">][</span><span class="mi">1</span>:<span class="mi">3</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice of an invocation.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">2</span>:<span class="mi">4</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Explicit-width slices.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span>:<span class="nc">u2</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s3</span>:<span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span>:<span class="nc">s3</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="o">+</span>:<span class="nc">u3</span><span class="p">]);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="advanced-understanding-parametricity-constraints-and-unification">Advanced Understanding: Parametricity, Constraints, and Unification</h3>
<p>An infamous wrinkle is introduced for parametric functions: consider the
following function:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// (Note: DSLX does not currently support the `T: type` construct shown here,</span>
<span class="c1">// it is for example purposes only.)</span>
<span class="k">fn</span> <span class="nf">add_wrapper</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">type</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="nc">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</code></pre></div>
<p>Based on the inference rule, we know that '+' can only type check when the
operand types are the same. This means we can conclude that type <code>T</code> is the same
as type <code>U</code>. Once we determine this, we need to make sure anywhere <code>U</code> is used
it is consistent with the fact it is the same as <code>T</code>. In a sense the + operator
is "adding a constraint" that <code>T</code> is equivalent to <code>U</code>, and trying to check that
fact is valid is under the purview of type inference. The fact that the
constraint is added that <code>T</code> and <code>U</code> are the same type is referred to as
"unification", as what was previously two entities with potentially different
constraints now has a single set of constraints that comes from the union of its
operand types.</p>
<p>DSLX's typechecker will go through the body of parametric functions per
invocation. As such, the typechecker will always have the invocation's
parametric values for use in asserting type consistency against "constraints"
such as derived parametric expressions, body vs. annotated return type equality,
and expression inference rules.</p>
<h3 id="operator-precedence">Operator Precedence</h3>
<p>DSLX's operator precedence matches Rust's. Listed below are DSLX's operators in
descending precedence order. Binary operators at the same level share the same
associativity and will be grouped accordingly.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unary <code>-</code> <code>!</code></td>
<td>n/a</td>
</tr>
<tr>
<td><code>as</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>\|</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>Left to right</td>
</tr>
</tbody>
</table>
<h2 id="builtins">Builtins</h2>
<p>This section describes the built-in functions provided for use in the DSL that
do not need to be explicitly imported.</p>
<p>A note on "Parallel Primitives": the DSL is expected to grow additional support
for use of high-level parallel primitives over time, adding operators for
order-insensitive reductions, scans, groupings, and similar. By making these
operations known to the compiler in their high level form, we potentially enable
optimizations and analyses on their higher level ("lifted") form. As of now,
<code>map</code> is the sole parallel-primitive-oriented built-in.</p>
<h3 id="add_with_carry"><code>add_with_carry</code></h3>
<p>Operation that produces the result of the add, as well as the carry bit as an
output. The binary add operators works similar to software programming
languages, preserving the length of the input operands, so this builtin can
assist when easy access to the carry out value is desired. Has the following
signature:</p>
<div class="highlight"><pre><span></span><code>fn add_with_carry&lt;N&gt;(x: uN[N], y: uN[N]) -&gt; (u1, uN[N])
</code></pre></div>
<h3 id="smulp-and-umulp"><code>smulp</code> and <code>umulp</code></h3>
<p><code>smulp</code> and <code>umulp</code> perform signed and unsigned partial multiplications. These
operations return a two-element tuple with the property that the sum of the two
elements is equal to the product of the original inputs. Performing a partial
multiplication allows for a pipeline stage in the middle of a multiply. These
operations have the following signatures:</p>
<div class="highlight"><pre><span></span><code>fn smulp&lt;N&gt;(lhs: sN[N], rhs: sN[N]) -&gt; (sN[N], sN[N])
fn umulp&lt;N&gt;(lhs: uN[N], rhs: uN[N]) -&gt; (uN[N], uN[N])
</code></pre></div>
<h3 id="map"><code>map</code></h3>
<p><code>map</code>, similarly to other languages, executes a transformation function on all
the elements of an original array to produce the resulting "mapped' array.
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/map_of_stdlib_parametric.x">For example</a>:
taking the absolute value of each element in an input array:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">std</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span>: <span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">abs</span><span class="p">);</span>
<span class="w">  </span><span class="n">y</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">main_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">got</span>: <span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>:<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">got</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that map is special, in that we can pass it a callee <em>as if</em> it were a
value. As a function that "takes" a function as an argument, <code>map</code> is a special
builtin -- in language implementor parlance it is a <em>higher order function</em>.</p>
<p>Implementation note: Functions are not first class values in the DSL, so the
name of the function must be referred to directly.</p>
<p>Note: Novel higher order functions (e.g. if a user wanted to write their own
<code>map</code>) cannot currently be written in user-level DSL code.</p>
<h3 id="clz-ctz"><code>clz</code>, <code>ctz</code></h3>
<p>DSLX provides the common "count leading zeroes" and "count trailing zeroes"
functions:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>:<span class="mh">0x0FFFFFF8</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clz</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctz</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span>
</code></pre></div>
<h3 id="one_hot"><code>one_hot</code></h3>
<p>Converts a value to one-hot form. Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn one_hot&lt;N, NP1=N+1&gt;(x: uN[N], lsb_is_prio: bool) -&gt; uN[NP1]
</code></pre></div>
<p>When <code>lsb_is_prio</code> is true, the least significant bit that is set becomes the
one-hot bit in the result. When it is false, the most significant bit that is
set becomes the one-hot bit in the result.</p>
<p>When all bits in the input are unset, the additional bit present in the output
value (MSb) becomes set.</p>
<p>Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/one_hot.x"><code>dslx/tests/one_hot.x</code></a>.</p>
<p>See also the
<a href="../ir_semantics/#one_hot">IR semantics for the <code>one_hot</code> op</a>.</p>
<h3 id="signex">signex</h3>
<p>Casting has well-defined extension rules, but in some cases it is necessary to
be explicit about sign-extensions, if just for code readability. For this, there
is the <code>signex</code> builtin.</p>
<p>To invoke the <code>signex</code> builtin, provide it with the operand to sign extend
(lhs), as well as the target type to extend to: these operands may be either
signed or unsigned. Note that the <em>value</em> of the right hand side is ignored,
only its type is used to determine the result type of the sign extension.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_signex</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span>:<span class="mh">0xff</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="nc">s32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">s32</span>:<span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">u</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">signex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that both <code>s</code> and <code>u</code> contain the same bits in the above example.</p>
<h3 id="slice">slice</h3>
<p>Array-slice builtin operation. Note that the "want" argument is <em>not</em> used as a
value, but is just used to reflect the desired slice type. (Prior to constexprs
being passed to builtin functions, this was the canonical way to reflect a
constexpr in the type system.) Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn slice&lt;T: type, N, M, S&gt;(xs: T[N], start: uN[M], want: T[S]) -&gt; T[S]
</code></pre></div>
<h3 id="rev">rev</h3>
<p><code>rev</code> is used to reverse the bits in an unsigned bits value. The LSb in the
input becomes the MSb in the result, the 2nd LSb becomes the 2nd MSb in the
result, and so on.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// (Dummy) wrapper around reverse.</span>
<span class="k">fn</span> <span class="nf">wrapper</span><span class="o">&lt;</span><span class="n">N</span>: <span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rev</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Target for IR conversion that works on u3s.</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span>: <span class="nc">u3</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Reverse examples.</span>
<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_reverse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b001</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span>:<span class="mb">0b100</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b01</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b00</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b00</span><span class="p">));</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="bit_slice_update"><code>bit_slice_update</code></h3>
<p><code>bit_slice_update(subject, start, value)</code> returns a copy of the bits-typed value
<code>subject</code> where the contiguous bits starting at index <code>start</code> (where 0 is the
least-significant bit) are replaced with <code>value</code>. The bit-width of the returned
value is the same as the bit-width of <code>subject</code>. Any updated bit indices which
are out of bounds (if <code>start + bit-width(value) &gt;= bit-width(subject)</code>) are
ignored. Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/bit_slice_update.x"><code>dslx/tests/bit_slice_update.x</code></a>.</p>
<h3 id="bitwise-reduction-builtins-and_reduce-or_reduce-xor_reduce">Bitwise reduction builtins: and_reduce, or_reduce, xor_reduce</h3>
<p>These are unary reduction operations applied to a bits-typed value:</p>
<ul>
<li><code>and_reduce</code>: evaluates to bool:1 if all bits of the input are set, and 0
    otherwise.</li>
<li><code>or_reduce</code>: evaluates to bool:1 if any bit of the input is set, and 0
    otherwise.</li>
<li><code>xor_reduce</code>: evaluates to bool:1 if there is an odd number of bits set in
    the input, and 0 otherwise.</li>
</ul>
<p>These functions return the identity element of the respective operation for
trivial (0 bit wide) inputs:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_trivial_reduce</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">and_reduce</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">or_reduce</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">xor_reduce</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>:<span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="update">update</h3>
<p><code>update(array, index, new_value)</code> returns a copy of <code>array</code> where <code>array[index]</code>
has been replaced with <code>new_value</code>, and all other elements are unchanged. Note
that this is <em>not</em> an in-place update of the array, it is an "evolution" of
<code>array</code>. It is the compiler's responsibility to optimize by using mutation
instead of copying, when it's safe to do. The compiler makes a best effort to do
this, but can't guarantee the optimization is always made.</p>
<h3 id="assert_eq-assert_lt">assert_eq, assert_lt</h3>
<p>In a unit test pseudo function all valid DSLX code is allowed. To evaluate test
results DSLX provides the <code>assert_eq</code> primitive (we'll add more of those in the
future). Here is an example of a <code>divceil</code> implementation with its corresponding
tests:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">divceil</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="kt">u32</span>:<span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">1</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_divceil</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="n">_</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that in this example, the final <code>let _ = ... in _</code> construct could be
omitted.</p>
<p><code>assert_eq</code> cannot be synthesized into equivalent Verilog. Because of that it is
recommended to use it within <code>test</code> constructs (interpretation) only.</p>
<h3 id="trace_fmt">trace_fmt!</h3>
<p>DSLX supports printf-style debugging via the <code>trace_fmt!</code> builtin, which allows
dumping of current values to stdout. For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Note: to see `trace_fmt!` output you need to be seeing `INFO` level logging,</span>
<span class="c1">// enabled by adding the &#39;--alsologtostderr&#39; flag to the command line (among</span>
<span class="c1">// other means). For example:</span>
<span class="c1">// bazel run -c opt //xls/dslx:interpreter_main  /path/to/dslx/file.x -- --alsologtostderr</span>

<span class="k">fn</span> <span class="nf">shifty</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">u3</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trace_fmt</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;x: {:x} y: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Note: y looks different as a negative number when the high bit is set.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trace_fmt</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;y as s8: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_shifty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">shifty</span><span class="p">(</span><span class="kt">u8</span>:<span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span>:<span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="kt">u8</span>:<span class="mh">0x20</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">shifty</span><span class="p">(</span><span class="kt">u8</span>:<span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span>:<span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="kt">u8</span>:<span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>would produce the following output, with each trace being annotated with its
corresponding source position:</p>
<div class="highlight"><pre><span></span><code>[...]
[ RUN UNITTEST  ] test_shifty
I0510 14:31:17.516227 1247677 bytecode_interpreter.cc:994] x: 42 y: 4
I0510 14:31:17.516227 1247677 bytecode_interpreter.cc:994] y as s8: 4
I0510 14:31:17.516227 1247677 bytecode_interpreter.cc:994] x: 42 y: 7
I0510 14:31:17.516227 1247677 bytecode_interpreter.cc:994] y as s8: -1
[            OK ]
[...]
</code></pre></div>
<p>Note: <code>trace!</code> currently exists as a builtin but is in the process of being
removed, as it provided the user with only a "global flag" way of specifying the
desired format for output values -- <code>trace_fmt!</code> is more powerful.</p>
<h3 id="fail">fail!</h3>
<p>NOTE: this section describes work-in-progress functionality, currently <code>fail!</code>
will only trigger in DSL interpretation (it is discarded in IR conversion).
Support for converting <code>fail!</code> to XLS <code>assert</code> IR is tracked in
<a href="https://github.com/google/xls/issues/232">#232</a> -- support for indicating the
assertion was triggered in the JIT is tracked in
<a href="https://github.com/google/xls/issues/308">#308</a></p>
<p>The <code>fail!</code> builtin indicates dataflow that should not be occurring in practice.
Its general signature is:</p>
<div class="highlight"><pre><span></span><code>fail!(label, fallback_value)
</code></pre></div>
<p>The <code>fail!</code> builtin can be thought of as a "fatal assertion macro". It is used
to <strong>annotate dataflow that should not occur in practice</strong> and, if triggered,
should raise a fatal error in simulation (e.g. via a JIT-execution failure
status or a Verilog assertion when running in RTL simulation).</p>
<p>Note, however, that XLS will permit users to avoid inserting
fatal-error-signaling hardware that correspond to this <code>fail!</code> -- assuming it
will not be triggered in practice minimizes its cost in synthesized form. In
this situation, <strong>when it is "erased", it acts as the identity function</strong>,
propagating the <code>fallback_value</code>. This allows XLS to keep well defined semantics
even when fatal assertion hardware is not present.</p>
<p>Example: if only these two enum values shown should be possible (say, as a
documented <a href="https://en.wikipedia.org/wiki/Precondition">precondition</a> for
<code>main</code>):</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">EnumType</span>: <span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FIRST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">SECOND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">x</span>: <span class="nc">EnumType</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EnumType</span>::<span class="n">FIRST</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">EnumType</span>::<span class="n">SECOND</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fail</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;unknown_EnumType&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>:<span class="mi">0</span><span class="p">),</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>fail!("unknown_EnumType", u32:0)</code> above indicates that a) that match arm
<em>should</em> not be reached (and if it is in the JIT or RTL simulation it will cause
an error status or assertion failure respectively), but b) provides a fallback
value to use (of the appropriate type) in case it were to happen in synthesized
gates which did not insert fatal-error-indicating hardware.</p>
<p>The associated label (the first argument) must be a valid Verilog identifier and
is used for identifying the failure when lowered to SystemVerilog. At higher
levels in the stack, it's unused.</p>
<h3 id="cover">cover!</h3>
<p>NOTE: Currently, <code>cover!</code> has no effect in RTL simulators supported in XLS open
source (i.e. iverilog). See
<a href="https://github.com/google/xls/issues/436">google/xls#436</a>.</p>
<p>The <code>cover!</code> builtin tracks how often some condition is satisfied. It desugars
into SystemVerilog cover points. Its signature is:</p>
<div class="highlight"><pre><span></span><code>cover!(&lt;name&gt;, &lt;condition&gt;);
</code></pre></div>
<p>Where <code>name</code> is a function-unique literal string identifying the coverpoint and
<code>condition</code> is a boolean element. When <code>condition</code> is true, a counter with the
given name is incremented that can be inspected upon program termination.
Coverpoints can be used to give an indication of code "coverage", i.e. to see
what paths of a design are exercised in practice. The name of the coverpoint
must begin with either a letter or underscore, and its remainder must consist of
letters, digits, underscores, or dollar signs.</p>
<h3 id="gate">gate!</h3>
<p>The <code>gate!</code> builtin is used for operand gating, of the form:</p>
<div class="highlight"><pre><span></span><code>let gated_value = gate!(&lt;pass_value&gt;, &lt;value&gt;);
</code></pre></div>
<p>This will generally use a special Verilog macro to avoid the underlying
synthesis tool doing boolean optimization, and will turn <code>gated_value</code> to <code>0</code>
when the predicate <code>pass_value</code> is <code>false</code>. This can be used in attempts to
manually avoid toggles based on the gating predicate.</p>
<p>It is expected that XLS will grow facilities to inserting gating ops
automatically, but manual user insertion is a practical step in this direction.
Additionally, it is expected that if, in the resulting Verilog, gating occurs on
a value that originates from a flip flop, the operand gating may be promoted to
register-based load-enable gating.</p>
<h2 id="testing-and-debugging">Testing and Debugging</h2>
<p>DSLX allows specifying tests right in the implementation file via the <code>test</code> and
<code>quickcheck</code> directives.</p>
<p>Having key test code in the implementation file serves two purposes. It helps to
ensure the code behaves as expected. Additionally it serves as 'executable'
documentation, similar in spirit to Python doc strings.</p>
<h3 id="unit-tests">Unit Tests</h3>
<p>Unit tests are specified by the <code>test</code> directive, as seen below:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span> <span class="nf">test_reverse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u1</span>:<span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b01</span><span class="p">));</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b00</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span>:<span class="mb">0b00</span><span class="p">));</span>
<span class="w">  </span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>The DSLX interpreter will execute all functions that are proceeded by a <code>test</code>
directive. These functions should be non-parametric, take no arguments, and
should return a unit-type.</p>
<p>Unless otherwise specified in the implementation's build configs, functions
called by unit tests are also converted to XLS IR and run through the
toolchain's LLVM JIT. The resulting values from the DSLX interpreter and the
LLVM JIT are compared against each other to assert equality. This is to ensure
DSLX implementations are IR-convertable and that IR translation is correct.</p>
<h3 id="quickcheck">QuickCheck</h3>
<p>QuickCheck is a <a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">testing framework concept</a> founded on
property-based testing. Instead of specifying expected and test values,
QuickCheck asks for properties of the implementation that should hold true
against any input of the specified type(s). In DSLX, we use the <code>quickcheck</code>
directive to designate functions to be run via the toolchain's QuickCheck
framework. Here is an example that complements the unit testing of DSLX's <code>rev</code>
implementation from above:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Reversing a value twice gets you the original value.</span>

<span class="cp">#[quickcheck]</span>
<span class="k">fn</span> <span class="nf">prop_double_reverse</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">rev</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>The DSLX interpreter will also execute all functions that are proceeded by a
<code>quickcheck</code> directive. These functions should be non-parametric and return a
<code>bool</code>. The framework will provide randomized input based on the types of the
arguments to the function (e.g. above, the framework will provided randomized
<code>u32</code>'s as <code>x</code>).</p>
<p>By default, the framework will run the function against 1000 sets of randomized
inputs. This default may be changed by specifying the <code>test_count</code> key in the
<code>quickcheck</code> directive before a particular test:</p>
<div class="highlight"><pre><span></span><code>#[quickcheck(test_count=50000)]
</code></pre></div>
<p>The framework also allows programmers to specify a seed to use in generating the
random inputs, as opposed to letting the framework pick one. The seed chosen for
production can be found in the execution log.</p>
<p>For determinism, the DSLX interpreter should be run with the <code>seed</code> flag:
<code>./interpreter_main --seed=1234 &lt;DSLX source file&gt;</code></p>
<div class="footnote">
<hr />
<ol>
<li id="fn:usebeforedef">
<p>Otherwise there'd be a use-before-definition error.&#160;<a class="footnote-backref" href="#fnref:usebeforedef" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.e5c33ebb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.51d95adb.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>