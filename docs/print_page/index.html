
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://google.github.io/xls/print_page/">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.27">
    
    
      
        <title>Print Site - XLS: Accelerated HW Synthesis</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6543a935.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../css/print-site-enum-headings1.css">
    
      <link rel="stylesheet" href="../css/print-site-enum-headings2.css">
    
      <link rel="stylesheet" href="../css/print-site-enum-headings3.css">
    
      <link rel="stylesheet" href="../css/print-site-enum-headings4.css">
    
      <link rel="stylesheet" href="../css/print-site-enum-headings5.css">
    
      <link rel="stylesheet" href="../css/print-site-enum-headings6.css">
    
      <link rel="stylesheet" href="../css/print-site.css">
    
      <link rel="stylesheet" href="../css/print-site-material.css">
    
    <script>__md_scope=new URL("/xls/",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  
        <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function () {
            remove_material_navigation();remove_mkdocs_theme_navigation();generate_toc();
        })
        </script>
        </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="XLS: Accelerated HW Synthesis" class="md-header__button md-logo" aria-label="XLS: Accelerated HW Synthesis" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            XLS: Accelerated HW Synthesis
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Print Site
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/google/xls/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="XLS: Accelerated HW Synthesis" class="md-nav__button md-logo" aria-label="XLS: Accelerated HW Synthesis" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    XLS: Accelerated HW Synthesis
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/google/xls/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../talks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Talks
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tutorials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    DSLX
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            DSLX
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/hello_xls/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Hello, XLS!
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/float_to_int/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Basic logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/intro_to_parametrics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Intro to parameterics
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/crc32/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    For expressions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/prefix_scan/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Enumerate and match
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/what_is_a_proc/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    What is a Proc?
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/how_to_use_procs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    How to use Procs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    \[contrib\] XLS[cc]
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            \[contrib\] XLS[cc]
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_overview/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_integers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Integers
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_channels/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Channels
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_memory/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Memory
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_state/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    State
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/xlscc_pipelined_loops/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pipelined Loops
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    IR
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            IR
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ir_overview/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ir_semantics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Semantics
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../optimizations/optimizations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Optimizations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_4" >
        
          
          <label class="md-nav__link" for="__nav_5_4" id="__nav_5_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Scheduling
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_4">
            <span class="md-nav__icon md-icon"></span>
            Scheduling
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../scheduling/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../delay_estimation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Delay Estimation
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ir_visualization/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Visualizer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_6" >
        
          
          <label class="md-nav__link" for="__nav_5_6" id="__nav_5_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Native JIT
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_6">
            <span class="md-nav__icon md-icon"></span>
            Native JIT
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ir_jit/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../data_layout/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Data Layout
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../solvers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Formal
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../elaboration/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Elaboration
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    DSLX
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            DSLX
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_reference/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reference
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_std/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Standard Library
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../floating_point/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Floating Point
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fuzzer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Fuzzer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_bytecode_interpreter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Interpreter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_ffi/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FFI
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_language_server/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Language Server
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dslx_type_system/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type System
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Code Generation
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Code Generation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../codegen_options/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Codegen Options
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ir_lowering/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    IR Lowering
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../vast/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    VAST
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tools
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../build_system/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Build System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../bazel_rules_macros/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bazel Rules And Macros
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tools_quick_start/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quick Start
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tools/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Listing
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../interpreters/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Interpreters
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Development
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            Development
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../xls_style/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Style Guide
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../adding_ir_operation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Adding a new IR operation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ideas_and_projects/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ideas and Projects
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fpga_characterization/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FPGA characterization (experimental)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_6" >
        
          
          <label class="md-nav__link" for="__nav_9_6" id="__nav_9_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Design Docs
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_6">
            <span class="md-nav__icon md-icon"></span>
            Design Docs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../design_docs/legalize_multiple_channel_ops_per_channel/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Legalize Multiple Channel Ops Per Channel
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../design_docs/proc_scoped_channels/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Proc-scoped channels
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../releasing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Releasing
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          <label class="md-nav__link" for="__nav_10" id="__nav_10_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    NoC
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            NoC
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_readme/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_2" >
        
          
          <label class="md-nav__link" for="__nav_10_2" id="__nav_10_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Topologies
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_2">
            <span class="md-nav__icon md-icon"></span>
            Topologies
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_topologies/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_dimension_order_topology/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Dimension Order
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_tree_topology/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tree
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_butterfly_topology/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    k-ary n-fly Butterfly
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_fully_connected_topology/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Fully Connected
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_star_topology/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Star
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../noc/xls_noc_glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Glossary
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#" class="md-nav__link">
    <span class="md-ellipsis">
      1. Overview
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#talks" class="md-nav__link">
    <span class="md-ellipsis">
      2. Talks
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-tutorials" class="md-nav__link">
    <span class="md-ellipsis">
      I. Tutorials
    </span>
  </a>
  
    <nav class="md-nav" aria-label="I. Tutorials">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tutorials" class="md-nav__link">
    <span class="md-ellipsis">
      3. Overview
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#faq" class="md-nav__link">
    <span class="md-ellipsis">
      4. FAQ
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-ir" class="md-nav__link">
    <span class="md-ellipsis">
      II. IR
    </span>
  </a>
  
    <nav class="md-nav" aria-label="II. IR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ir_overview" class="md-nav__link">
    <span class="md-ellipsis">
      5. Overview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ir_semantics" class="md-nav__link">
    <span class="md-ellipsis">
      6. Semantics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizations-optimizations" class="md-nav__link">
    <span class="md-ellipsis">
      7. Optimizations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ir_visualization" class="md-nav__link">
    <span class="md-ellipsis">
      8. Visualizer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solvers" class="md-nav__link">
    <span class="md-ellipsis">
      9. Formal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elaboration" class="md-nav__link">
    <span class="md-ellipsis">
      10. Elaboration
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-dslx" class="md-nav__link">
    <span class="md-ellipsis">
      III. DSLX
    </span>
  </a>
  
    <nav class="md-nav" aria-label="III. DSLX">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dslx_reference" class="md-nav__link">
    <span class="md-ellipsis">
      11. Reference
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslx_std" class="md-nav__link">
    <span class="md-ellipsis">
      12. Standard Library
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floating_point" class="md-nav__link">
    <span class="md-ellipsis">
      13. Floating Point
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fuzzer" class="md-nav__link">
    <span class="md-ellipsis">
      14. Fuzzer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslx_bytecode_interpreter" class="md-nav__link">
    <span class="md-ellipsis">
      15. Interpreter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslx_ffi" class="md-nav__link">
    <span class="md-ellipsis">
      16. FFI
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslx_language_server" class="md-nav__link">
    <span class="md-ellipsis">
      17. Language Server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslx_type_system" class="md-nav__link">
    <span class="md-ellipsis">
      18. Type System
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-code-generation" class="md-nav__link">
    <span class="md-ellipsis">
      IV. Code Generation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IV. Code Generation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#codegen_options" class="md-nav__link">
    <span class="md-ellipsis">
      19. Codegen Options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ir_lowering" class="md-nav__link">
    <span class="md-ellipsis">
      20. IR Lowering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vast" class="md-nav__link">
    <span class="md-ellipsis">
      21. VAST
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-tools" class="md-nav__link">
    <span class="md-ellipsis">
      V. Tools
    </span>
  </a>
  
    <nav class="md-nav" aria-label="V. Tools">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_system" class="md-nav__link">
    <span class="md-ellipsis">
      22. Build System
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bazel_rules_macros" class="md-nav__link">
    <span class="md-ellipsis">
      23. Bazel Rules And Macros
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tools_quick_start" class="md-nav__link">
    <span class="md-ellipsis">
      24. Quick Start
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tools" class="md-nav__link">
    <span class="md-ellipsis">
      25. Listing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interpreters" class="md-nav__link">
    <span class="md-ellipsis">
      26. Interpreters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-development" class="md-nav__link">
    <span class="md-ellipsis">
      VI. Development
    </span>
  </a>
  
    <nav class="md-nav" aria-label="VI. Development">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#contributing" class="md-nav__link">
    <span class="md-ellipsis">
      27. Contributing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xls_style" class="md-nav__link">
    <span class="md-ellipsis">
      28. Style Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adding_ir_operation" class="md-nav__link">
    <span class="md-ellipsis">
      29. Adding a new IR operation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ideas_and_projects" class="md-nav__link">
    <span class="md-ellipsis">
      30. Ideas and Projects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fpga_characterization" class="md-nav__link">
    <span class="md-ellipsis">
      31. FPGA characterization (experimental)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#releasing" class="md-nav__link">
    <span class="md-ellipsis">
      32. Releasing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-noc" class="md-nav__link">
    <span class="md-ellipsis">
      VII. NoC
    </span>
  </a>
  
    <nav class="md-nav" aria-label="VII. NoC">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#noc-xls_noc_readme" class="md-nav__link">
    <span class="md-ellipsis">
      33. Overview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#noc-xls_noc_glossary" class="md-nav__link">
    <span class="md-ellipsis">
      34. Glossary
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<div id="print-site-page" class="print-site-enumerate-headings print-site-enumerate-figures">
        <section class="print-page">
            <div id="print-page-toc" data-toc-depth="3">
                <nav role='navigation' class='print-page-toc-nav'>
                <h1 class='print-page-toc-title'>Table of Contents</h1>
                </nav>
            </div>
        </section>
        <section class="print-page" id="index"><div align='center'>
<img src='https://google.github.io/xls/images/xls_logo.svg' alt='XLS Logo'>
</div>

<h1 id="index-xls-accelerated-hw-synthesis"><strong>XLS</strong>: Accelerated HW Synthesis</h1>
<!-- GitHub banner -->

<h2 id="index-what-is-xls">What is XLS?</h2>
<p>XLS implements a High Level Synthesis toolchain that produces synthesizable
designs (Verilog and SystemVerilog) from flexible, high-level descriptions of
functionality. It is Apache 2 licensed.</p>
<p>XLS (Accelerated HW Synthesis) aims to be the Software Development Kit (SDK) for
the End of Moore's Law (EoML) era. In this "age of specialization", software and
hardware engineers must do more co-design across their domain boundaries --
collaborate on shared artifacts, understand each other's cost models, and share
tooling/methodology. XLS attempts to leverage automation, software engineers,
and machine cycles to accelerate this overall process.</p>
<p>XLS enables the rapid development of <em>hardware IP</em> that also runs as efficient
<em>host software</em> via "software style" methodology. An XLS design runs at native
speeds for use in host software or a simulator, but that design can also
generate hardware block output -- the XLS tools' correctness ensures (and
provides tools to help formally verify) that they are functionally identical.</p>
<p>XLS supports both (optionally pipelined) functions with pure-wire I/O interfaces
and
<a href="https://google.github.io/xls/tutorials/what_is_a_proc/"><em>concurrent processes</em></a>
(or <code>proc</code>s). Procs are stateful, allowing induction over time, and include more
general communication interfaces.</p>
<h2 id="index-state-of-the-project">State of the Project</h2>
<p>XLS is experimental, undergoing rapid development, and not an officially
supported Google product. Expect bugs and sharp edges. Please help by trying it
out, running through <a href="https://google.github.io/xls/tutorials/">some tutorials</a>,
<a href="https://github.com/google/xls/issues">reporting bugs</a>.</p>
<p>We are early stage and this has some practical effects:</p>
<ul>
<li>We welcome your issues and PRs.
    * Please try to lead with an issue. Engage us in conversation if you wish to
      upstream changes. Sending a PR without back and forth with us in an issue
      may be a longer road to success. If you believe your PR is ready and has
      not received a response within two business days, please ping the issue
      with what you think are next steps.</li>
<li>At the current point in its evolution, we regularly improve DSLX without
      considering backward compatibility.
    * If you are building a corpus of hardware with XLS, please be thoughtful
      about your process for bringing in new versions of the compiler.</li>
</ul>
<h2 id="index-colab-notebooks">Colab Notebooks</h2>
<p>For a more setup-free and environment-independent way of trying out XLS, see our
colab notebooks:</p>
<ul>
<li><a href="https://bit.ly/learn-xls">bit.ly/learn-xls</a>: a "learn XLS in Y minutes"
  style walkthrough in DSLX, our Rust-inspired domain specific language (DSL).</li>
<li>
<p><a href="https://bit.ly/xls-playground">bit.ly/xls-playground</a>: an XLS evaluation
  environment that can run the following interactively:</p>
<ul>
<li>XLS tests</li>
<li>XLS→IR conversion</li>
<li>IR→Verilog codegen</li>
<li>Verilog synthesis via Yosys (using open PDKs ASAP7 and SKY130)</li>
<li>Place-and-Route (P&amp;R) via OpenROAD</li>
<li>Power/Performance/Area (PPA) metric collection</li>
</ul>
</li>
</ul>
<h2 id="index-install-latest-release">Install Latest Release</h2>
<p>The following downloads the latest github repo release binaries for an x64 Linux machine:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Determine the url of the latest release tarball.</span>
<span class="nv">LATEST_XLS_RELEASE_TARBALL_URL</span><span class="o">=</span><span class="k">$(</span>curl<span class="w"> </span>-s<span class="w"> </span>-L<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>-H<span class="w"> </span><span class="s2">&quot;Accept: application/vnd.github+json&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>-H<span class="w"> </span><span class="s2">&quot;X-GitHub-Api-Version: 2022-11-28&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>https://api.github.com/repos/google/xls/releases<span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>grep<span class="w"> </span>-m<span class="w"> </span><span class="m">1</span><span class="w"> </span>-o<span class="w"> </span><span class="s1">&#39;https://.*/releases/download/.*\.tar\.gz&#39;</span><span class="k">)</span>

<span class="c1"># Download the tarball and unpack it, observe the version numbers for each of the included tools.</span>
curl<span class="w"> </span>-O<span class="w"> </span>-L<span class="w"> </span><span class="si">${</span><span class="nv">LATEST_XLS_RELEASE_TARBALL_URL</span><span class="si">}</span>
tar<span class="w"> </span>-xzvvf<span class="w"> </span>xls-*.tar.gz
<span class="nb">cd</span><span class="w"> </span>xls-*/
./interpreter_main<span class="w"> </span>--version
./ir_converter_main<span class="w"> </span>--version
./opt_main<span class="w"> </span>--version
./codegen_main<span class="w"> </span>--version
./proto_to_dslx_main<span class="w"> </span>--version
</code></pre></div>
<h2 id="index-building-from-source">Building From Source</h2>
<p>Aside from the binary releases (available for x64 Linux as described above), and
the available colab notebooks, XLS must be built from source using the Bazel
build system.</p>
<p>The following instructions are for the Ubuntu 22.04 (Jammy Jellyfish) Linux
distribution.</p>
<p>On an average 8-core VM:</p>
<ul>
<li>A full initial build <strong>without the C++ front-end (e.g. "DSLX only") may take
    about 2 hours</strong>,</li>
<li><strong>Including the C++ front-end may take up to 6 hours.</strong></li>
</ul>
<p>Please see the two corresponding command lines below -- we start by assuming
<a href="https://bazel.build/install/ubuntu">Bazel has been installed</a>:</p>
<div class="highlight"><pre><span></span><code><span class="go">~$ git clone https://github.com/google/xls.git</span>
<span class="go">~$ cd xls</span>

<span class="go">~/xls$ # Follow the bazel install instructions:</span>
<span class="go">~/xls$ # https://bazel.build/install/ubuntu</span>
<span class="go">~/xls$ # If you do use bazelisk, be aware that documentation here generally uses `bazel`,</span>
<span class="go">~/xls$ # so you may want to alias bazelisk to bazel.</span>
<span class="go">~/xls$ # Afterwards we observe:</span>
<span class="go">~/xls$ bazel --version</span>
<span class="go">bazel 6.4.0</span>

<span class="go">~/xls$ # Note we&#39;re going to tell Ubuntu that `/usr/bin/env python` is actually python3</span>
<span class="go">~/xls$ # here, since that has not been the case by default on past Ubuntus.</span>
<span class="go">~/xls$ # This is important. Without this step, you may experience cryptic error messages:</span>
<span class="go">~/xls$ sudo apt install python3-distutils python3-dev libtinfo5 python-is-python3</span>

<span class="go">~/xls$ # Now build/test in optimized build mode.</span>
<span class="go">~/xls$ # If you don&#39;t plan on using the C++ front-end, which is not strictly</span>
<span class="go">~/xls$ # needed (i.e. DSLX front-end only), use this command line:</span>
<span class="go">~/xls$ bazel test -c opt -- //xls/... -//xls/contrib/xlscc/...</span>

<span class="go">~/xls$ # To build everything, including the C++ front-end:</span>
<span class="go">~/xls$ bazel test -c opt -- //xls/...</span>
</code></pre></div>
<p>Reference build/test environment setups are also provided via <code>Dockerfile</code>s, if
you have difficulty setting up the (limited set of) dependencies shown above in
your environment:</p>
<div class="highlight"><pre><span></span><code><span class="go">~$ git clone https://github.com/google/xls.git</span>
<span class="go">~$ cd xls</span>
<span class="go">~/xls$ docker build . -f Dockerfile-ubuntu-22.04  # Performs optimized build-and-test.</span>
</code></pre></div>
<h3 id="index-adding-additional-build-caching">Adding Additional Build Caching</h3>
<p>Many programmers are used to using programs like <code>ccache</code> to improve caching for
a build, but Bazel actually ships with very-high quality caching layers.
In particular, incremental builds are more safe.</p>
<p>However, there are circumstances where Bazel might decide to recompile files
where the results could have been cached locally - or where it might be safe to
reuse certain intermediate results, even after a <code>bazel clean</code>. To improve this,
you can tell Bazel to use a shared "disk cache", storing files persistently
elsewhere on disk; just create a directory somewhere (e.g.,
<code>~/.bazel_disk_cache/</code>), and then run:</p>
<div class="highlight"><pre><span></span><code><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;build --disk_cache=</span><span class="k">$(</span>realpath<span class="w"> </span>~/.bazel_disk_cache<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>~/.bazelrc
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;test --disk_cache=</span><span class="k">$(</span>realpath<span class="w"> </span>~/.bazel_disk_cache<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>~/.bazelrc
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Bazel does not automate garbage collection of this directory, so it
will grow over time without bounds. You will need to clean it up periodically,
either manually or with an automated script.</p>
</div>
<p>Alternatively, you can add a <a href="https://bazel.build/remote/caching">remote cache</a>
that takes care of garbage collection for you. This can be hosted on a personal
server or even on the local machine. We've personally had good results with
localhost instances of <a href="https://github.com/buchgr/bazel-remote/">bazel-remote</a>.</p>
<h2 id="index-stack-diagram-and-project-layout">Stack Diagram and Project Layout</h2>
<p>Navigating a new code base can be daunting; the following description provides a
high-level view of the important directories and their intended organization /
purpose, and correspond to the components in this XLS stack diagram:</p>
<div align='center'>
<img src='https://google.github.io/xls/images/xls_stack_diagram.png' alt='XLS Stack Diagram'>
</div>

<ul>
<li><a href="https://github.com/google/xls/tree/main/dependency_support"><code>dependency_support</code></a>:
  Configuration files that load, build, and expose Bazel targets for <em>external</em>
  dependencies of XLS.</li>
<li><a href="https://github.com/google/xls/tree/main/docs"><code>docs</code></a>: Generated documentation
  served via GitHub pages:
  <a href="https://google.github.io/xls/">https://google.github.io/xls/</a></li>
<li><a href="https://github.com/google/xls/tree/main/docs_src"><code>docs_src</code></a>: Markdown file
  sources, rendered to <code>docs</code> via
  <a href="https://google.github.io/xls/contributing/#rendering-documentation">mkdocs</a>.</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls"><code>xls</code></a>: Project-named
  subdirectory within the repository, in common Bazel-project style.</p>
<ul>
<li><a href="https://github.com/google/xls/tree/main/xls/BUILD"><code>build</code></a>: Build macros
  that create XLS artifacts; e.g. convert DSL to IR, create test targets for
  DSL code, etc.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/codegen"><code>codegen</code></a>: Verilog
  AST (VAST) support to generate Verilog/SystemVerilog operations and FSMs.
  VAST is built up by components we call <em>generators</em> (e.g.
  PipelineGenerator, SequentialGenerator for FSMs) in the translation from XLS
  IR.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/common"><code>common</code></a>: "base"
  functionality that layers on top of standard library usage. Generally we use
  <a href="https://abseil.io">Abseil</a> versions of base constructs wherever possible.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc"><code>contrib/xlscc</code></a>:
  Experimental C++ syntax support that targets XLS IR (alternative path to
  DSLX) developed by a sister team at Google, sharing the same open source /
  testing flow as the rest of the XLS project. May be of particular interest
  for teams with existing C++ HLS code bases.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/data_structures"><code>data_structures</code></a>:
  Generic data structures used in XLS that augment standard libraries; e.g.
  BDDs, union find, min cut, etc.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/delay_model"><code>delay_model</code></a>:
  Functionality to characterize, describe, and interpolate data delay for
  XLS IR operations on a target backend process. Already-characterized
  descriptions are placed in <code>xls/delay_model/models</code> and can be referred to via
  command line flags.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/dslx"><code>dslx</code></a>: A DSL (called
  "DSLX") that mimics Rust, while being an immutable expression-language
  dataflow DSL with hardware-oriented features; e.g.  arbitrary bitwidths,
  entirely fixed size objects, fully analyzeable call graph. XLS team has found
  dataflow DSLs are a good fit to describe hardware as compared to languages
  designed assume von Neumann style computation.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/fuzzer"><code>fuzzer</code></a>: A
  whole-stack multiprocess fuzzer that generates programs at the DSL level and
  cross-compares different execution engines (DSL interpreter, IR interpreter,
  IR JIT, code-generated-Verilog simulator). Designed so that it can easily be
  run on different nodes in a cluster simultaneously and accumulate shared
  findings.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/examples"><code>examples</code></a>: Example
  computations that are tested and executable through the XLS stack.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/experimental"><code>experimental</code></a>:
  Artifacts captured from experimental explorations.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/interpreter"><code>interpreter</code></a>:
  Interpreter for XLS IR - useful for debugging and exploration. For cases
  needing throughput, consider using the JIT (below).</li>
<li><a href="https://github.com/google/xls/tree/main/xls/ir"><code>ir</code></a>:
  XLS IR definition, text parser/formatter, and facilities for abstract
  evaluation.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/jit"><code>jit</code></a>:
  LLVM-based JIT for XLS IR. Enables native-speed execution of DSLX and XLS IR
  programs.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/modules"><code>modules</code></a>:
  Hardware building block DSLX "libraries" (outside the DSLX standard library)
  that may be easily reused or instantiated in a broader design.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/netlist"><code>netlist</code></a>: Libraries
  that parse/analyze/interpret netlist-level descriptions, as are
  generally given in simple structural Verilog with an associated cell library.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/passes"><code>passes</code></a>: Passes that
  run on the XLS IR as part of optimization, before scheduling / code
  generation.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/scheduling"><code>scheduling</code></a>:
  Scheduling algorithms, determine when operations execute (e.g. which
  pipeline stage) in a clocked design.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/simulation"><code>simulation</code></a>:
  Code that wraps Verilog simulators and generates Verilog testbenches for XLS
  computations. <a href="https://github.com/steveicarus/iverilog">iverilog</a> is
  currently used to simulate as it supports non-synthesizable testbench
  constructs.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/solvers"><code>solvers</code></a>:
  Converters from XLS IR into SMT solver input, such that formal proofs can be
  run on XLS computations; e.g. Logical Equalence Checks between XLS IR and a
  netlist description. <a href="https://github.com/Z3Prover/z3">Z3</a> is used as the
  solver engine.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/synthesis"><code>synthesis</code></a>:
  Interface that wraps backend synthesis flows, such that tools can be
  retargeted e.g. between ASIC and FPGA flows.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/tests"><code>tests</code></a>:
  Integration tests that span various top-level components of the XLS project.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/tools"><code>tools</code></a>:
  <a href="https://google.github.io/xls/tools/">Many tools</a> that work with the XLS
  system and its libraries in a decomposed way via command line interfaces.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/uncore_rtl"><code>uncore_rtl</code></a>:
  Helper RTL that interfaces XLS-generated blocks with device top-level for e.g.
  FPGA experiments.</li>
<li><a href="https://github.com/google/xls/tree/main/xls/visualization"><code>visualization</code></a>:
  Visualization tools to inspect the XLS compiler/system interactively. See
  <a href="https://google.github.io/xls/ir_visualization/">IR visualization</a>.</li>
</ul>
</li>
</ul>
<h2 id="index-community">Community</h2>
<p>Discussions about XLS - development, debugging, usage, etc:</p>
<ul>
<li>Ideally happen in the <a href="https://github.com/google/xls/discussions">XLS repo GitHub
  discussions</a></li>
<li>But, if you feel email is a better venue for the discussion, there is also an
  <a href="https://groups.google.com/g/xls-dev">xls-dev mailing list</a> -- please prefer
  GitHub discussions if possible as they are searchable and can be
  easily cross-referenced and converted to the issue tracker</li>
</ul>
<h2 id="index-contributors">Contributors</h2>
<p>The following are
<a href="https://github.com/google/xls/graphs/contributors">contributors</a> to the XLS
project, see our
<a href="https://google.github.io/xls/contributing/">contributing documentation</a> and
<a href="https://github.com/google/xls/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">good first
issues</a>
if you're interested in contributing, or reach out via <a href="https://github.com/google/xls/discussions">GitHub
discussions</a>!</p>
<ul>
<li><a href="https://github.com/albert-magyar">Albert Magyar</a></li>
<li><a href="https://github.com/allight">Alex Light</a></li>
<li><a href="https://github.com/aminiok1">Amin Kalantar</a></li>
<li><a href="https://github.com/cbalint13">Balint Christian</a></li>
<li><a href="https://github.com/Blaok">Blaok</a></li>
<li><a href="https://github.com/brajiang">Brandon Jiang</a></li>
<li><a href="https://github.com/briansrls">Brian Searls</a></li>
<li><a href="https://github.com/cchao">Chen-hao Chang</a></li>
<li><a href="https://github.com/cjdrake">Chris Drake</a></li>
<li><a href="https://github.com/cdleary">Chris Leary</a></li>
<li><a href="https://github.com/crmymh">Conor McCullough</a></li>
<li><a href="https://github.com/dkillebrew-g">Dan Killebrew</a></li>
<li><a href="https://github.com/dmlockhart">Derek Lockhart</a></li>
<li><a href="https://github.com/ericastor">Eric Astor</a></li>
<li><a href="https://github.com/QuantamHD">Ethan Mahintorabi</a></li>
<li><a href="https://github.com/felixzhuologist">Felix Zhu</a></li>
<li><a href="https://github.com/grotival">Georges Rotival</a></li>
<li><a href="https://github.com/hanchenye">Hanchen Ye</a></li>
<li><a href="https://github.com/hmontero1205">Hans Montero</a></li>
<li><a href="https://github.com/hzeller">Henner Zeller</a></li>
<li><a href="https://github.com/malchev">Iliyan Malchev</a></li>
<li><a href="https://github.com/proppy">Johan Euphrosine</a></li>
<li><a href="https://github.com/jbaileyhandle">Jonathan Bailey</a></li>
<li><a href="https://github.com/JoshVarga">Josh Varga</a></li>
<li><a href="https://github.com/julianviera99">Julian Viera</a></li>
<li><a href="https://github.com/kevineharlley">Kevin Harlley</a></li>
<li><a href="https://github.com/lromor">Leonardo Romor</a></li>
<li><a href="https://github.com/manav-kohli">Manav Kohli</a></li>
<li><a href="https://github.com/meheff">Mark Heffernan</a></li>
<li><a href="https://github.com/grebe">Paul Rigge</a></li>
<li><a href="https://github.com/per-gron">Per Grön</a></li>
<li><a href="https://github.com/nanavati">Ravi Nanavati</a></li>
<li><a href="https://github.com/rchen152">Rebecca Chen (Pytype)</a></li>
<li><a href="https://github.com/taktoa">Remy Goldschmidt</a></li>
<li><a href="https://github.com/rhundt">Robert Hundt</a></li>
<li><a href="https://github.com/RobSpringer">Rob Springer</a></li>
<li><a href="https://github.com/sandwichmaker">Sameer Agarwal</a></li>
<li><a href="https://github.com/spurserh">Sean Purser-Haskell</a></li>
<li><a href="https://github.com/hongted">Ted Hong</a></li>
<li><a href="https://github.com/ted-xie">Ted Xie</a></li>
<li><a href="https://github.com/tcal-x">Tim Callahan</a></li>
<li><a href="https://github.com/vincent-mirian-google">Vincent Mirian</a></li>
</ul></section><section class="print-page" id="talks"><h1 id="talks-xls-talks">XLS Talks</h1>
<ul>
<li>
<p>2024-03-11:
  <a href="https://www.youtube.com/watch?v=TOJ8QWuEec8&amp;list=PLfrN7RIcMe6g2LBRJLTHTdhyj5s8ag0Rg&amp;index=27">XLS @ UCSC Agile HW Design (CSE228A Winter 2024)</a></p>
<p>In this talk we:</p>
<ul>
<li>Create some XLS-generated hardware &amp; tests interactively in a colab
  environment! All of XLS is Apache2 Licensed OSS!</li>
<li>Cover from basic to more advanced examples using our Rust-inspired
  (expression-oriented, immutable, communicating-process) dataflow DSL</li>
<li>Discuss the possibility space of ways to express and generate hardware,
  and where XLS falls in that space</li>
<li>Touch on how we've learned lessons from the past travails of HLS</li>
<li>And show a whole bunch of other goodies...</li>
</ul>
</li>
</ul>
<ul>
<li>2022-03-01: <a href="https://bit.ly/xls-latte">XLS @ LATTE'22</a>: note that this is a
  keynote talk and so spans a bunch of projects, vs being XLS-specific.</li>
</ul>
<ul>
<li>2021-10-13: <a href="https://bit.ly/xls-cross-21">XLS @ CROSS'21</a></li>
</ul>
<ul>
<li>2020-10-15: <a href="https://bit.ly/xls-cross">XLS @ CROSS'20</a></li>
</ul></section>
                        <h1 class='nav-section-title' id='section-tutorials'>
                            Tutorials <a class='headerlink' href='#section-tutorials' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="tutorials"><h1 id="tutorials-xls-tutorials">XLS Tutorials</h1>
<p>The XLS team has written several tutorials to help explain language features and
design techniques. Here they are, grouped by topic:</p>
<h2 id="tutorials-dslx">DSLX</h2>
<ul>
<li><a href="#tutorials-hello_xls">Hello, XLS!</a> : A brief introduction to writing and evaluating
    your first design in DSLX.</li>
<li><a href="#tutorials-float_to_int">Float-to-int conversion</a> : A guide to writing "real" logic
    in DSLX, demonstrated by creating an IEEE-754 binary32, i.e., C <code>float</code> to
    <code>int32_t</code> converter.</li>
<li><a href="#tutorials-intro_to_parametrics">Intro to parametrics</a> : A demonstration on how
    functions and types can be parameterized to allow a single implementation to
    apply to many different data layouts.</li>
<li><a href="#tutorials-crc32"><code>for</code> expressions</a> : Explains how to understand and write looping
    constructs in DSLX.</li>
<li><a href="#tutorials-prefix_scan"><code>enumerate</code> and <code>match</code> expressions</a> : Explains how to use
    <code>enumerate()</code> expressions to control loop iteration and how to use the
    <code>match</code> pattern-matching expression for selecting between alternatives.</li>
<li><a href="#tutorials-what_is_a_proc">What is a proc?</a>: A step-by-step introduction to procs,
    XLS's answer to how to write modules with state and explicit communication
    interfaces.</li>
<li><a href="#tutorials-how_to_use_procs">How to use procs</a> (communicating sequential
    processes): Provides a basic introduction to writing stateful and
    communicating modules, i.e., procs.</li>
</ul></section>
                        <h2 class='nav-section-title' id='section-dslx'>
                            DSLX <a class='headerlink' href='#section-dslx' title='Permanent link'>↵</a>
                        </h2>
                        <section class="print-page" id="tutorials-hello_xls"><h1 id="tutorials-hello_xls-tutorial-hello-xls">Tutorial: Hello, XLS!</h1>
<p>So, you're interested in learning more about XLS and DSLX! Super! This tutorial
is aimed at the very basics of getting started with XLS: getting your execution
environment set up and running the most trivial of DSLX examples: printing the
standard "Hello, world!" message to the terminal.</p>
<p>Yes, even though XLS is a hardware synthesis language, it still needs basic
printing and string support, if only for debugging!</p>
<h2 id="tutorials-hello_xls-1-installation-and-building">1. Installation and building</h2>
<p>First things first: if you haven't yet done so, download the XLS sources from
Github:</p>
<div class="highlight"><pre><span></span><code>git clone https://github.com/google/xls.git xls
</code></pre></div>
<p>Next, build the project tree. XLS includes several dependencies that can take a
while to build, so the first build may take a while; subsequent builds will be
much shorter.</p>
<blockquote>
<p><strong>NOTE</strong>: If you don't have Bazel installed, install it: check the Bazel
website for instructions. The other prerequisites are a C++20-compliant
compiler toolchain and a Python3 interpreter; check with your distribution for
installation instructions for both.</p>
</blockquote>
<p>Start the XLS build by running:</p>
<div class="highlight"><pre><span></span><code>bazel build -c opt xls/...
</code></pre></div>
<p>Then go get a cup of coffee. LLVM and Z3 are big projects, and will take a while
to compile (but only the first time). Binary releases are coming soon: they'll
avoid the need for long local compiles.</p>
<h2 id="tutorials-hello_xls-2-create-your-module">2. Create your module</h2>
<p>With your toolchain built, let's get to coding! Open up an editor and create a
file called <code>hello_xls.x</code> in your XLS checkout root directory. Populate it with
the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">hello_xls</span><span class="p">(</span><span class="n">hello_string</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">trace</span><span class="o">!</span><span class="p">(</span><span class="n">hello_string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Let's go over this, line-by-line:</p>
<ol>
<li>This first line declares a fn (<code>fn</code>) named "<code>hello_xls</code>". This function
    accepts an array of eleven characters (u8) called <code>hello_string</code>, and
    returns no value (the return type would be specified after the argument
    list's closing parenthesis and before the function-opening curly brace, if
    the function returned a value).</li>
<li>This second line invokes the built-in <code>trace!</code> directive, passing it the
    function's input string, and throws away the result.</li>
</ol>
<h2 id="tutorials-hello_xls-3-say-hello-xls">3. Say hello, XLS!</h2>
<p>Let's run (and test) our code!</p>
<p>First thing, though, we should make sure our module parses and passes
type checking. The fastest way to do that is via the DSLX
"<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">repl</a>",
conveniently called <a href="https://github.com/google/xls/tree/main/xls/tools/repl.cc"><code>repl</code></a>.
You can run it against the above example with the command:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/tools/repl hello_xls.x
</code></pre></div>
<p>This tool first examines the specified module for language correctness, and will
print an <code>INVALID_ARGUMENT</code> error if it fails to parse or typecheck. In that
case, fix the errors and type <code>:reload</code> to try again. <code>repl</code> supports other
features (IR, Verilog, and LLVM code examination), but those are outside the
scope of this tutorial.</p>
<p>Once you have a parsing DSLX file, the best way to "smoke test" a module is via
the
<a href="https://github.com/google/xls/tree/main/xls/dslx/interpreter_main.cc">DSLX interpreter</a>.
First, though, we need a test case for it to execute. Add the following to the
end of your <code>hello_xls.x</code> file:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">hello_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello_xls</span><span class="p">(</span><span class="s">&quot;Hello, XLS!&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Again, going line-by-line:</p>
<ol>
<li>This directive tells the interpreter that the next function is a test
    function, meaning that it shouldn't be passed down the synthesis chain and
    that it should be executed by the interpreter.</li>
<li>This line declares the [test] function <code>hello_test</code>, which takes no args and
    returns no value.</li>
<li>The only line in this function invokes the <code>hello_xls</code> function and passes
    it a chipper greeting.</li>
</ol>
<p>With both the function and its corresponding test/driver in place, let's fire it
up! Open a terminal and execute the following in the XLS checkout root
directory:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/dslx/interpreter_main hello_xls.x
</code></pre></div>
<p>You should see the following output:</p>
<div class="highlight"><pre><span></span><code>[ RUN UNITTEST  ] hello_test
trace of hello_string @ hello.x:4:17-4:31: [72, 101, 108, 108, 111, 44, 32, 88, 76, 83, 33]
[            OK ]
[===============] 1 test(s) ran; 0 failed; 0 skipped.
</code></pre></div>
<p>Perfect! While this may not be what you initially expected, examine the output
elements carefully: they correspond to the ASCII codes of the characters in
"Hello, XLS!" When designing and debugging hardware, signals are more often
numbers than strings, which is why they're represented as numbers here.</p>
<p>Congrats! You've written your first piece of hardware in DSLX! It might be more
satisfying, though, if your hardware <em>actually did anything</em>. For that, see the
next tutorial,
<a href="#tutorials-float_to_int">float-to-int conversion</a>.</p></section><section class="print-page" id="tutorials-float_to_int"><h1 id="tutorials-float_to_int-tutorial-basic-logic">Tutorial: basic logic</h1>
<p>This tutorial demonstrates how to use XLS to create a simple combinational
module, in this case one that performs floating-point-to-integer conversion.</p>
<p>The first task is to define the full semantics of the module. We wish for the
module to accept a
<a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754 floating-point number</a> and to
output the integer representing the same. All fractional elements will be
discarded. Overflow, NaN, and infinite values will be clamped to the maximum or
minimum representable integer value with the sign of the input number.</p>
<div class="toc">
<ul>
<li><a href="#tutorials-float_to_int-tutorial-basic-logic">Tutorial: basic logic</a><ul>
<li><a href="#tutorials-float_to_int-1-bootstrapping">1. Bootstrapping</a></li>
<li><a href="#tutorials-float_to_int-2-simple-logic">2. Simple logic</a></li>
<li><a href="#tutorials-float_to_int-3-conclusion">3. Conclusion</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="tutorials-float_to_int-1-bootstrapping">1. Bootstrapping</h2>
<p>When creating a module, one first needs to define the signature and skeleton of
the entry function. If you recall, a IEEE binary32 (the C <code>float</code> type) has 1
sign bit, 8 [biased] exponent bits, and 23 fractional bits. These values can be
packed into a tuple, and so, the signature of our function can be defined as:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int</span><span class="p">(</span>
<span class="w">    </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">u23</span><span class="p">))</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">s32</span><span class="p">:</span><span class="mh">0xbeef</span>
<span class="p">}</span>
</code></pre></div>
<p>DSLX syntax is intended to follow Rust syntax as much as possible, so this may
look familiar if you're a Rustacean. In any case, let's walk through this code,
line-by-line:</p>
<ol>
<li>This line declares a public function (<code>pub fn</code>), named <code>float_to_int</code>. Since
    this function is "public", it can be referenced from other modules (i.e.,
    files) if
    <a href="#dslx_reference-imports">imported</a>
    therein.</li>
<li>Function parameter declarations! This function only takes one parameter,
    <code>x</code>, whose type follows its name. In this case, it's a <em><code>tuple</code></em>: a grouping
    of potentially disparate elements into a single quantity. A tuple is
    specified by listing a set of types in parentheses, as here. Our tuple has a
    1-bit element for the sign, an 8-bit element for the biased exponent, and a
    23-bit element for the fractional part. In what is the complete opposite of
    a coincidence, these fields match those of an IEEE float32 number. If a
    function takes more than one argument, they'll be comma-separated.
    -   <code>u1</code>, <code>u8</code>, and <code>u23</code> are all shortcuts for the type <code>uN[1]</code>, <code>uN[8]</code>,
        and <code>uN[23]</code>. The <code>uN[X]</code> construct declares an X-bit wide unsigned
        type. There is also <code>sN[X]</code>, which declares an X-bit wide <em>signed</em> type.
    -   Other type shortcuts exist such as <code>bits[X]</code> (alias for <code>uN[X]</code>), <code>bool</code>
        (alias for <code>uN[1]</code>), and <code>u[1-64]</code> and <code>s[1-64]</code>, being aliases for
        <code>uN[1]</code> through <code>uN[64]</code> and <code>sN[1]</code> through <code>sN[64]</code>.</li>
<li>Function return type. This function returns a signed 32-bit type, matching
    the intentions of float-to-int conversion (since floats are signed).</li>
<li>Finally, the last line: the final statement in a function is its return
    value. Here, we're unconditionally returning a signed 32-bit number with the
    value <code>48879</code>. This is only temporary to make the function syntactically
    valid - we're still learning the basics! Gimme a second!</li>
</ol>
<p>As an aside, it's a good idea to keep a bookmark to the
<a href="#dslx_reference">DSLX language reference</a>
handy. It has the full details on language features and syntax and even we XLS
devs frequently reference it.</p>
<p>Anyway...the tuple representation of our input is a bit cumbersome, so let's
define our floating-point number as a struct instead:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">float32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bexp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">  </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">u23</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">float32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">s32</span><span class="p">:</span><span class="mh">0xbeef</span>
<span class="p">}</span>
</code></pre></div>
<p>Finally, let's write a quick test to make sure things work. Add the following
code to your file.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 0xbeef in float32.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">test_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">:</span><span class="mh">0x0</span><span class="p">,</span>
<span class="w">    </span><span class="n">bexp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mh">0x8e</span><span class="p">,</span>
<span class="w">    </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">u23</span><span class="p">:</span><span class="mh">0x3eef00</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s32</span><span class="p">:</span><span class="mh">0xbeef</span><span class="p">,</span><span class="w"> </span><span class="n">float_to_int</span><span class="p">(</span><span class="n">test_input</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>Now run the test through the DSLX interpreter:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/dslx/interpreter_main float_to_int.x
</code></pre></div>
<p>You should see something like the following:</p>
<div class="highlight"><pre><span></span><code>[ RUN UNITTEST  ] float_to_int_test
[            OK ]
[===============] 1 test(s) ran; 0 failed; 0 skipped.
</code></pre></div>
<p>If so, then congrats! You've written - and tested - your first DSLX module! Next
up: let's make it do something more interesting.</p>
<h2 id="tutorials-float_to_int-2-simple-logic">2. Simple logic</h2>
<p>After getting the trivial module up and running, the next step is to add real
logic to the implementation. Recall that a floating-point number's fractional
part has an implicit leading <code>1</code>, so a floating-point number is representable as
an integer if its exponent is &lt; 30, that is to say, if its value is between
[-2^31, 2^31).</p>
<p>To get that exponent, we need to <em>unbias</em> it. In its binary representation, a
valid floating-point number's exponent is a value from 0 to 254, being an
8-bit value (an exponent of 255 indicates either NaN or an infinity).
The range of a floating-point number's exponent is from -128 to 127, though, so
we need to subtract 127 from that value to get the actual exponent. Let's write
a function to do just that:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">unbias_exponent</span><span class="p">(</span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s9</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s9</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s9</span><span class="p">:</span><span class="mi">127</span>
<span class="p">}</span>
</code></pre></div>
<p>Notice that we need to expand the exponent to add on the sign bit before the
subtraction!</p>
<blockquote>
<p><strong>Note</strong>: The repeated <code>s9</code> type specifications are a bit redundant. They're
needed because we've not yet fully built out DSLX' type inference
capabilities, but this is an area targeted for improvement.</p>
</blockquote>
<p>Now that we can get the proper exponent, we can code up the rest of the simple
in-bound cases. To do that, we need to prepend that leading <code>1</code> and shift the
fractional part into its proper location in the final integer. Here's what that
looks like when we add that to our original function:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">float32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bexp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">  </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">u23</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">unbias_exponent</span><span class="p">(</span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s9</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s9</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s9</span><span class="p">:</span><span class="mi">127</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">float32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbias_exponent</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">bexp</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Add the implicit leading one.</span>
<span class="w">  </span><span class="c1">// Note that we need to add one bit to the fraction to hold it.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u33</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u33</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Shift the result to the right if the exponent is less than 23.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// Shift the result to the left if the exponent is greater than 23.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">((</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">sign</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">-</span><span class="n">result</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">result</span>
<span class="p">}</span>
</code></pre></div>
<p>If we run this function with our original test case, it still works! Of course,
one should run additional test cases to see what happens with other inputs,
particularly because this implementation will fail for some important values.</p>
<p>Try adding tests on your own to find these cases - and to fix them! If you're
stumped, hints (and answers) are hidden below:</p>
<details>
<summary>Missing case 1</summary>
What if the input is 0.0? What should the result be?

To fix this, add a specific check for a zero exponent and fractional part.
</details>

<details>
<summary>Missing case 2</summary>
Are NaNs or infinite numbers handled correctly?

To fix, add a special check for NaN or infinities at function end. Consider
making `is_inf` and `is_nan` functions!
</details>

<h2 id="tutorials-float_to_int-3-conclusion">3. Conclusion</h2>
<p>I hope that these examples help you get a better grasp on DSLX and writing
modules in them. While our float-to-int function correctly handles
<code>float</code>-to-<code>int32_t</code> conversions, what if we wanted to convert <code>double</code> to
<code>int64_t</code>? Or even <code>float</code> to <code>int64_t</code>? <em>Even worse</em>, will we have to write
separate floating-point operators for every floating-point type we (or our
users) wish to support?</p>
<p>Fortunately, the answer is no! The next tutorial covers type parameterization,
and demonstrates how we can write a single int-to-float routine that covers all
our possible conversions. See you there!</p></section><section class="print-page" id="tutorials-intro_to_parametrics"><h1 id="tutorials-intro_to_parametrics-tutorial-parametric-types-and-functions">Tutorial: parametric types and functions</h1>
<p>This tutorial demonstrates how types and functions can be parameterized to
enable them to work on data of different formats and layouts, e.g., for a
function <code>foo</code> to work on both u16 and u32 data types, and anywhere in between.</p>
<p>It's recommended that you're familiar with the concepts in the previous
tutorial,
"<a href="#tutorials-float_to_int">float-to-int conversion"</a>
before following this tutorial.</p>
<h2 id="tutorials-intro_to_parametrics-simple-parametrics">Simple parametrics</h2>
<p>Consider the simple example of the <code>umax</code> function
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/std.x">in the DSLX standard library</a>:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">umax</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Most of this function looks like other DSLX functions you may have seen, except
for the new-style parameter, <code>N</code>. The declaration of <code>N</code> inside angle brackets
denotes that <code>N</code> is a <em>parametric value</em> whose value is a build-time invariant
that will be specified by the caller. In other words, changing regular function
parameters pumps different values through the circuit, while changing parametric
values changes the circuit itself.</p>
<p>Here, <code>N</code> is used to define the widths of the input and output types. It's plain
to see, then, that specifying <code>N = 16</code> would calculate the maximum of two 16-bit
numbers, whereas <code>N = 273</code> would calculate the maximum of two 273-bit numbers.
That being said, the smaller the circuit, the faster, smaller, and lower-power
it will be, so <code>N</code> should be as small as possible (but no smaller!).</p>
<p>There are two ways invoke a parametric function: the first is to explicitly
specify all parametric values, and the second is to rely on the language to
infer them:</p>
<p>Explicit specification:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">std</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">umax</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Here, the user has directly told the language what the values of all parametrics
are.</p>
<p>Parametric inference:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">std</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">umax</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Here, though, the language is able to determine that <code>N</code> is 64, since that
matches the types of the arguments to <code>umax</code>, and since both arg types agree.
There may be times where inference isn't possible - for example, when there
exist parametrics that aren't referenced in the argument list:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">my_parametric_sum</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a_mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="n">a_mod</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_mod</span>
<span class="p">}</span>
</code></pre></div>
<p>To invoke this function, explicit specification is required.</p>
<h2 id="tutorials-intro_to_parametrics-derived-parametrics">Derived parametrics</h2>
<p>It's common, when using parametric types, to need types <em>similar, but not
identical to</em> the parametric type. Consider calculating the unbiased
floating-point exponent (from the previous tutorial): while the <em>biased</em>
exponent was 8 bits wide, the calculated <em>unbiased</em> exponent was 9 bits wide due
to the additional sign bit. In this situation, if <code>EXP_SZ</code> was 8, then it'd be
handy to also have a <code>SIGNED_EXP_SZ</code> symbol that was equal to 9. This can be
done as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">unbias_exponent</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">SIGNED_EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EXP_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]:</span><span class="o">???</span>
<span class="p">}</span>
</code></pre></div>
<p>Oh no! Specifying parametrics in this way has revealed a problem! If we
parameterize types, then in some situations, we'll need to also parameterize
<em>values</em>!</p>
<p>Of course, we'd not be writing this tutorial if that wasn't possible. DSLX
supports "constexpr"-style evaluation, whereby constant expressions can be
evaluated at interpretation or compilation time. In this case, we just need an
expression that can calculate the correct bias adjustment: <code>(sN[SIGNED_EXP_SZ]:1
&lt;&lt; (EXP_SZ - u32:1)) - sN[SIGNED_EXP_SZ]:1</code></p>
<p>This is a bit unwieldy in practice, so we can wrap it in a function:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">bias_scaler</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">WIDE_N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">WIDE_N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="n">sN</span><span class="p">[</span><span class="n">WIDE_N</span><span class="p">]:</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">WIDE_N</span><span class="p">]:</span><span class="mi">1</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">unbias_exponent</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">SIGNED_EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">EXP_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bias_scaler</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="tutorials-intro_to_parametrics-parameterized-float-to-int">Parameterized float-to-int</h2>
<p>Finally, consider the 32-bit float-to-int program from the previous tutorial.
That program was restricted to converting from one specific type to another. If,
however, we wanted to convert from, say a <code>double</code> to an <code>int32_t</code>, we'd have to
write a new function, even though the basic logic would be the same.</p>
<p>Instead, armed with parametrics, we can write a single function to handle <em>all</em>
such conversions - even to floating-point formats we haven't considered!</p>
<p>The first step in such a parameterization is to have a working single-typed
example, which we take from the previous codelab:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">float32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bexp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">  </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">u23</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">unbias_exponent</span><span class="p">(</span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s9</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s9</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s9</span><span class="p">:</span><span class="mi">127</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">float32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbias_exponent</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">bexp</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Add the implicit leading one.</span>
<span class="w">  </span><span class="c1">// Note that we need to add one bit to the fraction to hold it.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u33</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u33</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Shift the result to the right if the exponent is less than 23.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// Shift the result to the left if the exponent is greater than 23.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">((</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">sign</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">-</span><span class="n">result</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">result</span>
<span class="p">}</span>
</code></pre></div>
<p>Next is to identify all types needing parameterization, here being the intended
size of the result and the layout of the floating-point type itself; all other
types flow from that base definition:</p>
<ul>
<li><code>exp</code>: <code>float32::bexp</code> size + 1 sign bit</li>
<li><code>fraction</code>: <code>float32::fraction</code> size + 1 implicit leading bit</li>
</ul>
<p>Thus, the struct declaration and function signature will be:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">float</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bexp</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">],</span>
<span class="w">  </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">FRACTION_SZ</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">RESULT_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">float</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">RESULT_SZ</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>From there, the rest of the function can be populated by replacing the types in
the original implementation with the parameterized ones in the signature:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">float</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bexp</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">],</span>
<span class="w">  </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">FRACTION_SZ</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">bias_scaler</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">WIDE_N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">WIDE_N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="n">sN</span><span class="p">[</span><span class="n">WIDE_N</span><span class="p">]:</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">WIDE_N</span><span class="p">]:</span><span class="mi">1</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">unbias_exponent</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">SIGNED_EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">EXP_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">SIGNED_EXP_SZ</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bias_scaler</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">float_to_int</span><span class="o">&lt;</span>
<span class="w">    </span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">RESULT_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">WIDE_EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">EXP_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
<span class="w">    </span><span class="n">WIDE_FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">FRACTION_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">float</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">RESULT_SZ</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbias_exponent</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">bexp</span><span class="p">);</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">WIDE_FRACTION_SZ</span><span class="p">]:</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="w"> </span><span class="o">|</span>
<span class="w">      </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">WIDE_FRACTION_SZ</span><span class="p">]);</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">FRACTION_SZ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">((</span><span class="n">exp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">RESULT_SZ</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">sign</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">-</span><span class="n">result</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">result</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that <code>unbias_exponent()</code> didn't need type specification, since the type
could be inferred from the argument! (Also note that this implementation doesn't
contain the fixes from the missing cases from the previous tutorial. Exercise to
the reader: apply those fixes here, too!)</p>
<p>This technique underlies all of XLS' floating-point libraries. Common operations
are defined in common files, such as
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/apfloat.x">apfloat.x</a> (general
utilities). Specializations of the above are then available in, e.g.,
<a href="https://github.com/google/xls/tree/main/xls/stdlib/float32.x">float32.x</a> to hide internal
implementation details from end users.</p>
<p>With this technique, you can write single implementations of functionality that
can be applicable across all sorts of hardware configurations for minimal
additional cost. Try it out! Create an <code>0xbeef</code>-bit wide floating-point adder!</p></section><section class="print-page" id="tutorials-crc32"><h1 id="tutorials-crc32-tutorial-for-expressions">Tutorial: <code>for</code> expressions</h1>
<p>In this document we explain in detail the implementation of routine to compute a
CRC32 checksum on a single 8-bit input. We don't discuss the algorithm here,
only the language features necessary to implement the algorithm.</p>
<p>Refer to the
<a href="https://github.com/google/xls/tree/main/xls/examples/dslx_intro/crc32_one_byte.x">full implementation</a>
while following this document.</p>
<h3 id="tutorials-crc32-function-prototype">Function Prototype</h3>
<p>The signature and first line of this function should look familiar enough now,
but the <code>for</code> construct is new: DSLX provides a means of iterating <strong>a fixed
number of times</strong> within a function.</p>
<p>A DSLX <code>for</code> loop has the following structure:</p>
<ol>
<li>The loop signature: this consists of three elements:
    1.  An <code>(index, &lt;accumulator vars&gt;)</code> tuple. The index holds the current
        iteration number, and the accumulator vars are user-specified data
        carried into the current iteration.
    2.  The type specification for the index/accumulators tuple. Note that the
        index type can be controlled by the user (i.e., doesn't have to be u32,
        but it should be able to hold all possible loop index values).
    3.  An
        <a href="#dslx_reference">iterable</a>,
        either the <code>range()</code> or <code>enumerate()</code> expressions, either of which
        dictates the number of iterations of the loop to complete.</li>
<li>The loop body: this has the same general form as a DSLX function.
    Particularly noteworthy is that the loop body ends by stating the "return"
    value. In a <code>for</code> loop, this "return" value is either used as the input to
    the next iteration of the loop (for non-terminal iterations) or as the
    result of the entire expression (for the terminal iteration).</li>
</ol>
<p>For this specific for loop, the index variable is unused, so we assign it to
<code>_</code>. This indicates to the DSLX frontend that "the variable is unused but that's
ok"; a trailing name after the underscore is also allowed to provide additional
context. The accumulator consists of a single variable <code>crc</code>. Both index and
accumulator are of type <code>u32</code>. The iterable range expression specifies that the
loop should execute 8 times.</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="c1">// 8 rounds of updates.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">crc</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>At the end of the loop, the calculated value is being assigned to the
accumulator <code>crc</code> - the last expression in the loop body is assigned to the
accumulator:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mask</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">crc</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="n">polynomial</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
</code></pre></div>
<p>Finally, the accumulator's initial value is being passed to the <code>for</code> expression
as a parameter. This can be confusing, especially when compared to other
languages, where the init value typically is provided at or near the top of a
loop.</p>
<div class="highlight"><pre><span></span><code><span class="p">}(</span><span class="n">crc</span><span class="p">)</span>
</code></pre></div>
<p>Since the <code>for</code> loop is the last expression in the function, it's also the
function's return value, but in other contexts, it could be assigned to a
variable and used elsewhere. In general, the result of a <code>for</code> expression can be
used in the same manner as any other expression's result.</p></section><section class="print-page" id="tutorials-prefix_scan"><h1 id="tutorials-prefix_scan-dslx-tutorial-enumerate-and-match-expressions">DSLX Tutorial: <code>enumerate</code> and <code>match</code> expressions</h1>
<p>In this document we explain in detail the implementation of a 8 byte prefix scan
computation. In order to understand the implementation, it is useful to
understand the intended functionality first.</p>
<p>For a given input of 8 bytes, the scan iterates from left to right over the
input and produces an output of the same size. Each element in the output
contains the count of duplicate values seen so far in the input. The counter
resets to 0 if a new value is found.</p>
<p>For example, suppose we have this input:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.]</span>
</code></pre></div>
<p>This creates an 8-element
<a href="#dslx_reference-array-type">array</a> of <code>u32</code>
integers; the <code>...</code> at the end of the array is a shorthand to indicate
"fill in the rest of the elements with the last value specified".</p>
<p>The prefix scan code should produce this output:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span>
</code></pre></div>
<p>At index 0 it has not yet found any value, so it assigns a counter value of <code>0</code>.</p>
<p>At index 1 it finds the second occurrence of the value '0' (which is the 1st
duplicate) and therefore adds a 1 to the counter from index 0.</p>
<p>At index 2 it finds the third occurrence of the value '0' (which is the 2nd
duplicate) and therefore adds a 1 to the counter from index 1. And so on.</p>
<p>Correspondingly, for this input:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span>
</code></pre></div>
<p>it should produce:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span>
</code></pre></div>
<p>The full listing is in
<a href="https://github.com/google/xls/tree/main/xls/examples/dslx_intro/prefix_scan_equality.x">examples/dslx_intro/prefix_scan_equality.x</a>.</p>
<h3 id="tutorials-prefix_scan-function-prefix_scan_eq">Function <code>prefix_scan_eq</code></h3>
<p>The implementation displays a few interesting language features.</p>
<p>The function prototype is straight-forward. Input is an array of 8 values of type
<code>u32</code>. Output is an array of size 8 holding 3-bit values (the maximum resulting
count can only be 7, which fits in 3 bits).</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">prefix_scan_eq</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>The first let expression produces a tuple of 3 values. It only cares about the
last value <code>result</code>, so it stubs out the other two elements via the 'unused'
placeholder <code>_</code>.</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
</code></pre></div>
<p>Why a 3-Tuple? Because the subsequent loop on the right hand side of this
assignment has a tuple of three values as the accumulator. The return type of
the loop is the type of the accumulator, so the above let needs to be of the
same type.</p>
<h4 id="tutorials-prefix_scan-enumerated-loop">Enumerated Loop</h4>
<p>Using tuples as the accumulator is a convenient way to model multiple
loop-carried values:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">elem</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">prior</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)):</span><span class="w"> </span><span class="p">((</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
<span class="w">          </span><span class="k">in</span><span class="w"> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>The iterable of this loop is <code>enumerate(x)</code>. On each iteration, this construct
delivers a tuple consisting of current index and current element. This is
represented as the tuple <code>(i, elem)</code> in the <code>for</code> construct.</p>
<p>The loop next specifies the accumulator, which is a 3-tuple consisting of the
values named <code>prior</code>, <code>count</code>, and <code>result</code>.</p>
<p>The types of the iterable and accumulator are specified next. The iterable is a
tuple consisting of two <code>u32</code> values. The accumulator is more interesting, it is
a tuple consisting of a <code>u32</code> value (<code>prior</code>), a <code>u3</code> value (<code>count</code>), and an
array type <code>u3[8]</code>, which is an array holding 8 elements of bit-width 3. This is
the type of <code>result</code> in the accumulator.</p>
<p>Looping back to the prior <code>let</code> statement, it ignores the <code>prior</code> and <code>count</code>
members of the tuple and will only store the <code>result</code> part.</p>
<h4 id="tutorials-prefix_scan-a-match-expression">A Match Expression</h4>
<p>The next expression is an interesting <code>match</code> expression. The let expression
binds the tuple <code>(to_place, new_count): (u3, u3)</code> to the result of the following
match expression:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">to_place</span><span class="p">,</span><span class="w"> </span><span class="n">new_count</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">prior</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">elem</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p><code>to_place</code> will hold the value that is to be written at a given index.
<code>new_count</code> will contain the updated counter value.</p>
<p>The <code>match</code> expression evaluates two conditions in parallel:</p>
<ul>
<li>is <code>i</code> == 0?</li>
<li>is the <code>prior</code> element the same as the current <code>elem</code></li>
</ul>
<p>Two tests mean there are four possible cases, which are all handled in the
following four cases:</p>
<div class="highlight"><pre><span></span><code><span class="w">      </span><span class="c1">// i == 0 (no matter whether prior == elem or not):</span>
<span class="w">      </span><span class="c1">//    we set position 0 to 0 and update the new_counter to 1</span>
<span class="w">      </span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span>
<span class="w">      </span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span>

<span class="w">      </span><span class="c1">// if i != 0 - if the current element is the same as pior,</span>
<span class="w">      </span><span class="c1">//    set to_place to the value of the current count</span>
<span class="w">      </span><span class="c1">//    update new_counter with the increased counter value</span>
<span class="w">      </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span>

<span class="w">      </span><span class="c1">// if i != 0 - if current element is different from prior,</span>
<span class="w">      </span><span class="c1">//     set to_place back to 0</span>
<span class="w">      </span><span class="c1">//     set new_counter back to 1</span>
<span class="w">      </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>
</code></pre></div>
<p>To update the result, we set index <code>i</code> in the <code>result</code> array to the value
<code>to_place</code> via the built-in <code>update</code> function, which produces a new value
<code>new_result</code>):</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">new_result</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">to_place</span><span class="p">);</span>
</code></pre></div>
<p>Finally the updated accumulator value is constructed, it is the last expression
in the loop:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="n">new_count</span><span class="p">,</span><span class="w"> </span><span class="n">new_result</span><span class="p">)</span>
</code></pre></div>
<p>Following the loop body, as an argument to the loop, we initialize the
accumulator in the following way.</p>
<ul>
<li>set element <code>prior</code> to -1, in order to not match any other value.</li>
<li>set element <code>count</code> to 0.</li>
<li>set element <code>result</code> to 8 0's of size <code>u3</code>.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">}((</span><span class="kt">u32</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.]));</span>
</code></pre></div>
<p>And, finally, the function simply returns <code>result</code>:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">result</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="tutorials-prefix_scan-testing">Testing</h3>
<p>To test the two cases we've described above, we add the following two test cases
right to this implementation file:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_prefix_scan_eq_all_zero</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prefix_scan_eq</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_prefix_scan_eq_doubles</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prefix_scan_eq</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div>
<p>To run tests against the file present in the repository:</p>
<div class="highlight"><pre><span></span><code><span class="go">xls$ bazel run -c opt //xls/dslx:interpreter_main -- \</span>
<span class="gp">       $</span>PWD/xls/examples/dslx_intro/prefix_scan_equality.x<span class="w"> </span><span class="se">\</span>
<span class="w">       </span>--compare<span class="o">=</span>none
<span class="go">[ RUN UNITTEST  ] prefix_scan_eq_all_zero_test</span>
<span class="go">[            OK ]</span>
<span class="go">[ RUN UNITTEST  ] prefix_scan_eq_doubles_test</span>
<span class="go">[            OK ]</span>
<span class="go">[===============] 2 test(s) ran; 0 failed; 0 skipped.</span>
</code></pre></div>
<p>(Note that <code>--compare=none</code> is currently required because <code>enumerate</code> ranges are
not currently convertable to IR, otherwise running the DSLX interpreter would do
implicit comparison to IR interpreter -- see
<a href="https://github.com/google/xls/issues/164">google/xls#164</a>.)</p></section><section class="print-page" id="tutorials-what_is_a_proc"><h1 id="tutorials-what_is_a_proc-dslx-tutorial-what-is-a-proc">DSLX Tutorial: What is a Proc?</h1>
<p>Up to this point, our tutorials have described stateless, non-communicating,
combinational modules. To add state or communication with other actors, we need
to venture into the exciting land of procs!</p>
<p><strong>Procs</strong>, short for "communicating sequential processes", are the means by
which DSLX models sequential and stateful modules. DSLX's semantics are based on
<a href="https://en.wikipedia.org/wiki/Kahn_process_networks">Kahn process networks</a>, or
KPNs. A pure KPN is made up of independent computing units communicating with
each other in timing-insensitive ways; whenever possible, we try to make it easy
to express your desired behavior in this style.<sup id="tutorials-what_is_a_proc-fnref:impure-kpn"><a class="footnote-ref" href="#tutorials-what_is_a_proc-fn:impure-kpn">1</a></sup> In XLS, our
independent computing units are called processes, or <em>procs</em>. Each proc has a
fixed set of I/O interfaces (aka <em>channels</em>, usually FIFO queues), a fixed
amount of memory (aka <em>state</em>), and the ability to carry out a bounded amount of
computation on their state &amp; inputs whenever they activate.</p>
<p>We can think of each proc as <em>activating</em> as often as it can; e.g., in hardware,
up to once per clock cycle. Each activation proceeds as the information &amp;
resources for it to run become available. For example, suppose the proc is
designed to:</p>
<ul>
<li>read a number from each of channels A and B,</li>
<li>add the numbers together, and</li>
<li>write the result to channel C.</li>
</ul>
<p>The first activation will wait until it can read the first numbers from each of
channels A and B, then write their sum as the first value on channel C. The
second activation will read the second number from each of channels A and B,
then write their sum as the second value on channel C... and so on.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>XLS guarantees that, for each I/O operation X, the first activation's
action (X<sub>0</sub>) will happen before the second activation's action
(X<sub>1</sub>), and so on. Therefore, the first activation will read the first
numbers on channels A and B, and write the first number on channel C. However,
if a proc includes multiple I/O operations - even on the same channel - and
these operations need to happen in a specific order (whether in the same
activation or between activations), there is no ordering guarantee by default.
Instead, you can express that using <strong>tokens</strong>, as we'll discuss later.</p>
</div>
<h2 id="tutorials-what_is_a_proc-channels">Channels</h2>
<p>In general, <strong>channels</strong> provide possible I/O operations each activation can
carry out. A proc can receive from an input channel or send on an output channel
any number of times per activation (though for now, only once per
channel<sup id="tutorials-what_is_a_proc-fnref:strictness"><a class="footnote-ref" href="#tutorials-what_is_a_proc-fn:strictness">2</a></sup>). There are multiple types of channels, which can make
things rather more complicated; for now, we'll discuss the standard
<strong>streaming</strong> channel type.</p>
<p>By default, receives are considered to be <strong>blocking</strong> operations; if no data is
available on the channel, the activation will <strong>stall</strong><sup id="fnref:stalling"><a class="footnote-ref" href="#tutorials-what_is_a_proc-fn:stalling">3</a></sup> until the
data becomes available. (This is part of how the defaults ensure that the
results are timing-insensitive, making it easier for you to use XLS to produce
more optimized hardware.) Once the data is available, the receiving proc will
take the value from the channel, removing it if the channel is a FIFO queue, and
proceed.</p>
<p>Sends, by contrast, are considered to be <strong>non-blocking</strong> operations; by
default, XLS models channels as if they used infinite-depth queues, so sends can
always complete.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In reality, when compiled to RTL, hardware FIFOs have finite depth. By
default, XLS allows for <strong>backpressure</strong> on finite-depth channels. If the
channel is not able to receive new data when the send should trigger, the
activation will stall until the channel is ready. This always produces correct
behavior in the absence of deadlocks, but can introduce deadlocks in RTL that
did not exist at higher levels.</p>
</div>
<p>Using these, we can implement our first example, which reads from two channels
and writes the sum to a third:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">C</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The initial value of the proc&#39;s state (empty in this case).</span>
<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// The interface used by anything that spawns this proc, which will need to</span>
<span class="w">  </span><span class="c1">// configure its inputs &amp; outputs.</span>
<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// The description of how this proc actually acts when running.</span>
<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">st</span><span class="p">:</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok_A</span><span class="p">,</span><span class="w"> </span><span class="n">data_A</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok_B</span><span class="p">,</span><span class="w"> </span><span class="n">data_B</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data_B</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">tok_A</span><span class="p">,</span><span class="w"> </span><span class="n">tok_B</span><span class="p">);</span>
<span class="w">    </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>You might be surprised at the extra values being passed to and returned from our
<code>recv</code> and <code>send</code> operations. These are <em>tokens</em>, which we will discuss in more
detail below; they are used to establish ordering between operations where data
dependencies aren't sufficient.<sup id="tutorials-what_is_a_proc-fnref:required-tokens"><a class="footnote-ref" href="#tutorials-what_is_a_proc-fn:required-tokens">4</a></sup></p>
<p>More generally, sends and receives can also be conditional; we can decide
whether or not to carry out each operation based on a computed predicate. For
example, we can write a proc that:</p>
<ul>
<li>reads a value <em>x</em> from channel A, and</li>
<li>if that input is zero:
    *   reads a value <em>y</em> from channel B, and
    *   writes <em>y</em> to channel C.</li>
<li>otherwise:
    *   writes <em>x</em> to channel C.</li>
</ul>
<p>Therefore, each activation reads one value from channel A, reads either one or
zero values from channel B, and writes one value to channel C. We can implement
this as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">fallback</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">C</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">st</span><span class="p">:</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">data_A</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">data_B</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv_if</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">data_A</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">data_A</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">data_B</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">data_A</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You might be surprised that we didn't simply put the <code>data_B</code> conditional
receive inside the correct branch of our <code>if</code> expression. DSLX does not
currently allow receives to happen in conditional expressions, so we need to
control them separately.</p>
</div>
<h3 id="tutorials-what_is_a_proc-state">State</h3>
<p>Each proc can also have its own <strong>state elements</strong>, each of which is a piece of
data of any allowed type. Each state element has an initial value, which is the
value seen by the first activation; beyond that, activation <em>N</em> sets the state
elements to values that can be read by activation <em>N</em>+1. This can include
setting them back to whatever value activation <em>N</em>-1 assigned to them,
effectively leaving them unchanged. It's worth noting that activation <em>N</em>+1 is
allowed to start before the state from activation <em>N</em> has fully resolved; it can
stall if it needs to read from the state, waiting until it can confirm that the
previous activation has set the state element that it needs.</p>
<p>For example, we can design a proc to implement a saturating accumulator, which
reads a value, adds the result to an accumulator (storing the maximum value if
the result would overflow), and returns the updated accumulator value:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">saturating_accumulator</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ch_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="n">ch_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">ch_in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">accumulated</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">ch_in</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u33</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">accumulated</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u33</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">new_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">all_ones</span><span class="o">!&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u33</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">all_ones</span><span class="o">!&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// The last expression is the value the next activation will receive as its</span>
<span class="w">    </span><span class="c1">// state.</span>
<span class="w">    </span><span class="n">new_val</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="tutorials-what_is_a_proc-state-and-throughput">State and Throughput</h4>
<p>If we try to generate pipelined hardware for this proc (as discussed in the
pipelining documentation) and cannot fit the saturating addition in a single
stage, then XLS will notice that it can take more than one cycle for each
activation to determine the next state after reading the current state. This
means this example will not be able to achieve <strong>full throughput</strong>; i.e., it
might be possible for activations to stall <em>internally</em>, waiting on the state
from the previous activation, even though all input channels are full and no
output channel is providing backpressure. By default, XLS assumes you're
expecting full throughput, and will emit an error explaining this failure in
terms of the <strong>worst-case throughput</strong> for the proc (the number of cycles that
can elapse between two activations with no externally-caused
stalls)<sup id="tutorials-what_is_a_proc-fnref:inverse-throughput"><a class="footnote-ref" href="#tutorials-what_is_a_proc-fn:inverse-throughput">5</a></sup>; the error message will also include what
worst-case throughput <em>is</em> possible with your design as written, and how to let
XLS know if this is acceptable for your use case.</p>
<div class="highlight"><pre><span></span><code>Error:<span class="w"> </span>INVALID_ARGUMENT:<span class="w"> </span>Impossible<span class="w"> </span>to<span class="w"> </span>schedule<span class="w"> </span>proc<span class="w"> </span>&lt;NAME&gt;<span class="w"> </span>as<span class="w"> </span>specified<span class="p">;</span><span class="w"> </span>cannot<span class="w"> </span>achieve<span class="w"> </span>full<span class="w"> </span>throughput.<span class="w"> </span>Try<span class="w"> </span><span class="sb">`</span>--worst_case_throughput<span class="o">=</span><span class="m">5</span><span class="sb">`</span>
</code></pre></div>
<p>On the other hand, we could also design a proc that compares the newest input
value to the previous value, clamps the difference to the range [-5, 5], and
sends the clamped difference:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">clamped_diff</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ch_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s32</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="n">ch_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">ch_in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">prev</span><span class="p">:</span><span class="w"> </span><span class="nc">s32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">ch_in</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s33</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s33</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">clamped_diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">s33</span><span class="p">:</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">s32</span><span class="p">:</span><span class="mi">5</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s33</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">s32</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">diff</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">clamped_diff</span><span class="p">);</span>
<span class="w">    </span><span class="n">val</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Even if we can't fit both the subtraction and the clamping into a single
pipeline stage, XLS can still pipeline this example to achieve full throughput;
the new state value can be determined immediately on reading the value, so the
next activation can read that state before the first activation is done
computing its result.</p>
<h3 id="tutorials-what_is_a_proc-tokens">Tokens</h3>
<p>For computation operations, XLS can tell which operations depend on which
others, and <strong>schedule</strong> them in hardware respecting these dependencies.
Sometimes, though, a dependency might be external to the proc. For example,
suppose our proc needs to send a message on channel A, then wait for a response
on channel B. If we wait for the response before we send the message, our
hardware will end up deadlocked.</p>
<p>To make sure XLS knows that the message needs to be sent first, we use a
<strong>token</strong>; this lets us express the dependency between these operations even
though the <code>send</code> does not produce any actual data that the <code>recv</code> can use.
Every operation where ordering effects can be important (generally because
they're visible at the interface), including I/O operations, returns a token and
can accept a token. For instance, to express the dependency we wrote above, we
can write:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">request_tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">response_tok</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">request_tok</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="c1">// ...</span>
</code></pre></div>
<p>Since the <code>recv</code> depends on the token produced by the <code>send</code>, we know that the
receive operation should not be allowed to go off until the send operation has
completed.</p>
<p>Of course, it's possible for an operation to need to happen after <em>more</em> than
one predecessor. For a simple example, maybe our request needs to be sent in
multiple parts. For this case, we have the <code>join(tok...)</code> function, which takes
any number of tokens and returns a single token that depends on all of them. (In
fact, we've been using that already - we wrote <code>join()</code> in our previous examples
whenever we needed a token that depended on nothing!) In context, this might
look like:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">request_part_1_tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">request_part_1</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">request_part_2_tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">request_part_2</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">request_part_3_tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">request_part_3</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">full_request_tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">request_part_1_tok</span><span class="p">,</span><span class="w"> </span><span class="n">request_part_2_tok</span><span class="p">,</span><span class="w"> </span><span class="n">request_part_3_tok</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">response_tok</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">full_request_tok</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="c1">// ...</span>
</code></pre></div>
<p>In this example, our <code>send()</code>s can happen in any order, but we know that the
<code>recv()</code> will not block until after all the <code>send()</code>s have finished.</p>
<h4 id="tutorials-what_is_a_proc-cross-activation-tokens">Cross-Activation Tokens</h4>
<p>There are also contexts where we need to specify ordering constraints
<strong>between</strong> activations. As usual, when we want to communicate some context to
the next activation, we can use a state element; in this case, we can pass a
token as a state element.</p>
<p>For example, suppose we need to write a serialization interface that takes in a
complex struct and produces a sequence of four 32-bit values. If the input
channel receives inputs <code>A</code> and <code>B</code>, we need to make sure to produce <code>[A1, A2,
A3, A4, B1, B2, B3, B4]</code> on the output channel. We can pass a token within each
activation to make sure that the sends are properly sequenced, but we also need
to pass it to the <em>next</em> activation to make sure it doesn't start serializing
<code>B</code> until <code>A</code> is finished. (i.e., we want to prevent orders like <code>[A1, A2, B1,
...]</code>.) Using tokens in our state, we can write:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This example will not work as written until DSLX supports multiple I/O
operations per channel per activation.</p>
</div>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">serialize</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ch_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">complex_struct</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">join</span><span class="p">()</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="n">ch_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">complex_struct</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">ch_in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">:</span><span class="w"> </span><span class="nc">token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">input_tok</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">ch_in</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// ... (calculate val1)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">val1</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// ... (calculate val2)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// ... (calculate val3)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">val3</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// ... (calculate val4)</span>
<span class="w">    </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">val4</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="tutorials-what_is_a_proc-timing-sensitive-operations">Timing-Sensitive Operations</h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Using timing-sensitive operations means that your circuit's behavior
can depend on the exact details of scheduling. It is possible to write correct
XLS code under these constraints, but the logic <strong>must</strong> work no matter how
operations are pipelined, and <strong>should</strong> (within reason) be designed to be
correct even if the number of stages in the pipeline varies. Testing/DV is
substantially more difficult for timing-sensitive procs. As such, similar to how
<em>unsafe</em> operations work in Rust, we recommend that you avoid using
timing-sensitive operations except where strictly necessary. It's good practice
to keep them confined to small well-understood procs that implement certain
necessary behaviors.</p>
</div>
<p>Using streaming channels as documented above, there are some circuits that are
simply impossible to implement; for example, you cannot implement an
<strong>arbiter</strong>, a process that listens on multiple channels and forwards the
highest-priority message sending at any given time, while using only blocking
reads. All unimplementable circuits are <strong>timing-sensitive</strong>; their results
depend on <em>when</em> the inputs arrive on each channel, not just on the <em>order of
arrival</em>. This makes it much harder to write a provably correct design; however,
there are still times these circuits are needed!</p>
<p>For these times, XLS does include some timing-sensitive operations.</p>
<p>In particular, XLS has a <strong>non-blocking receive</strong> operation,
<code>recv_non_blocking(tok, ch, default)</code>. This attempts to read from the channel
<code>ch</code>. If the channel's queue is empty at the time of the read, it returns \
<code>(tok, default, false)</code>. Otherwise, it acts like a normal receive,
<span style="text-decoration:underline;">removing</span> the leading element
<code>data</code> from the <code>ch</code> queue and returning <code>(tok, data, true)</code>.</p>
<p>We can use this operation to implement a simple arbiter, combining two channels
(<code>data0_in</code> and <code>data1_in</code>) into one <code>result</code> by letting the higher-priority
data (from <code>data0_in</code>) through whenever it is ready with no delay, and sending
the lower-priority data (from <code>data1_in</code>) only when there's no higher-priority
message to send:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Message</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">value1</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">value2</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span>
<span class="w">  </span><span class="n">value3</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">priority_arbiter</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">data0_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">data1_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="n">Message</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="p">(</span><span class="n">data0_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">data1_in</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="n">Message</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">data0_in</span><span class="p">,</span><span class="w"> </span><span class="n">data1_in</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">:</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">data0_msg</span><span class="p">,</span><span class="w"> </span><span class="n">data0_valid</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv_non_blocking</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">data0_in</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="o">!&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">data1_msg</span><span class="p">,</span><span class="w"> </span><span class="n">data1_valid</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv_if_non_blocking</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">data1_in</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">data0_valid</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="o">!&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">to_send</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data0_valid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data0_msg</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">data1_msg</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">send_if</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">data0_valid</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">data1_valid</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">to_send</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="footnote">
<hr />
<ol>
<li id="tutorials-what_is_a_proc-fn:impure-kpn">
<p>For when it's necessary, we also expose a limited number of ways
to express timing-sensitive computations, which we'll discuss
later.&#160;<a class="footnote-backref" href="#tutorials-what_is_a_proc-fnref:impure-kpn" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="tutorials-what_is_a_proc-fn:strictness">
<p>At the moment, DSLX only supports channels where we can prove
that at most one I/O operation can fire per channel per
activation. Work is in progress to allow the user to opt into
multiple I/O operations per channel per activation, and we expect
this support to land soon. It will be opt-in, however, since this
introduces the extra overhead of an arbiter to sequence the
operations, and also adds potential backpressure since each
channel can still accept at most one datum per clock cycle!&#160;<a class="footnote-backref" href="#tutorials-what_is_a_proc-fnref:strictness" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="tutorials-what_is_a_proc-fn:stalling">
<p>When generating pipelined hardware, no later activation can proceed
past the stalled stage. This may cause activations at earlier
stages to stall as well, since the resources for them to run are
not yet available. Activations at later stages can proceed as
normal. Once the data becomes available, the pipeline will resume
all stalled operations. See the pipelining documentation for more
details.&#160;<a class="footnote-backref" href="#tutorials-what_is_a_proc-fnref:stalling" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="tutorials-what_is_a_proc-fn:required-tokens">
<p>For now, <code>send</code> and <code>recv</code> need to take and return tokens
even when data dependencies are sufficient to express the
ordering requirements. We do have work in progress to create
a syntax where tokens are only used where necessary; watch
this space!&#160;<a class="footnote-backref" href="#tutorials-what_is_a_proc-fnref:required-tokens" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="tutorials-what_is_a_proc-fn:inverse-throughput">
<p>This is technically an <strong>inverse throughput</strong>. The
throughput of a proc is properly defined as the number of
activations that occur per cycle... but rather than
saying that your proc has WCT 1/2, it's more natural to
think in inverse throughput - the number of cycles per
activation - and write WCT 2.&#160;<a class="footnote-backref" href="#tutorials-what_is_a_proc-fnref:inverse-throughput" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><section class="print-page" id="tutorials-how_to_use_procs"><h1 id="tutorials-how_to_use_procs-dslx-tutorial-how-to-use-procs">DSLX Tutorial: How to use procs</h1>
<p>A proc contains:</p>
<ul>
<li>A <em><code>init</code></em> function that initializes the proc state.</li>
<li>A <em><code>config</code></em> function that spawns any other dependent/child procs needed for
    execution.</li>
<li>A recurrent (i.e., infinitely looping) <em><code>next</code></em> function that contains the
    actual logic to be executed by the proc.</li>
</ul>
<p>A critical component of procs is communication: every proc needs a means to
share data with other procs, or else it'd just be spinning dead code. These
means are <em>channels</em>: entities into which data can be sent and from which data
can be received. Each channel has a send and a receive endpoint: data inserted
into a channel by a <code>send</code> op can be pulled out by a <code>recv</code> op.</p>
<h2 id="tutorials-how_to_use_procs-example-proc">Example proc</h2>
<p>Many concepts here are more easily explained via example, so here's a possible
DSLX implementation of
<a href="https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation">FMAC (fused multiply-accumulate)</a>,
which computes <code>C = A * B + C</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">float32</span><span class="p">;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">F32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float32</span><span class="p">::</span><span class="n">F32</span><span class="p">;</span>

<span class="n">proc</span><span class="w"> </span><span class="n">Fmac</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">input_a_consumer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">input_b_consumer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">output_producer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">float32</span><span class="p">::</span><span class="n">zero</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="p">(</span><span class="n">input_a_consumer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="n">input_b_consumer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">,</span>
<span class="w">         </span><span class="n">output_producer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">input_a_consumer</span><span class="p">,</span><span class="w"> </span><span class="n">input_b_consumer</span><span class="p">,</span><span class="w"> </span><span class="n">output_producer</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="nc">F32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok_a</span><span class="p">,</span><span class="w"> </span><span class="n">input_a</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">input_a_consumer</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok_b</span><span class="p">,</span><span class="w"> </span><span class="n">input_b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">input_b_consumer</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float32</span><span class="p">::</span><span class="n">fma</span><span class="p">(</span><span class="n">input_a</span><span class="p">,</span><span class="w"> </span><span class="n">input_b</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">tok_a</span><span class="p">,</span><span class="w"> </span><span class="n">tok_b</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">output_producer</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="n">result</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>(In practice, a FMAC unit would want a reset signal, but we've leaving that out
for simplicity.)</p>
<p>There's a lot to unpack here, so we'll walk through the example.</p>
<p>The first part of interest is the declaration of the proc member values: the
three channels. These are similar to class data members in software. In DSLX,
proc members are constant values, and are set by the output of the <code>config</code>
function. Member values can be referred to inside the <code>next</code> function in the
same way as locally-declared data.</p>
<p>Next up is the <code>init</code> function, defining the initial value for the proc state.</p>
<p>Following is the <code>config</code> function itself. When a proc is "spawned", its given a
sets of values that get passed to the <code>config</code> function (following this example,
we'll show how procs are spawned). Inside a <code>config</code> function, any constant
values can be computed, any necessary procs can be spawned, and finally member
values are set by the return value. Member values are assigned in declaration
order: the first element of the return tuple corresponds to the first-declared
member, and so on.</p>
<p>After that, we encounter <code>next</code>. This function serves as the real "body" of the
Proc. The <code>next</code> function maintains and evolves the proc's recurrent state and
is responsible for communicating with the outside world, as well. In our
example, the first two lines are that communication, receiving the input values
for the computation. The token elements are used to sequence events: since the
receives can happen in parallel, they can share the same token, but since
sending the output must happen after that, their result tokens are "joined"
(think joining two threads of execution in software), and the result is used to
sequence the send. Between the communication routines is the actual computation.</p>
<p>At the end of the proc, we terminate with the <code>result</code> value. This final value
becomes the input state for the next iteration. This is how recurrent state is
managed by procs: a state value is provided to the <code>next</code> function, and the
result of that function is used as the next iteration's state input. Procs have
exactly one state value; to keep multiple elements in state, the state can be a
struct.</p>
<h2 id="tutorials-how_to_use_procs-spawning-procs">Spawning procs</h2>
<p>In any real design, procs will form a network<sup id="fnref:proc_network"><a class="footnote-ref" href="#tutorials-how_to_use_procs-fn:proc_network">1</a></sup>, where one proc
will spawn any number of child procs, which themselves might spawn other procs.
(The "root" proc will be instantiated by some outside component in the outside
RTL environment.) Procs may only be spawned in <code>config</code> functions, as they're
part of statically configuring the hardware network to construct.</p>
<p>As an example, spawning a couple of our procs above would look as follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">proc</span><span class="w"> </span><span class="n">Spawner</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">fmac_1_a_producer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">fmac_1_b_producer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">fmac_1_output_consumer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>
<span class="w">  </span><span class="n">fmac_2_a_producer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">fmac_2_b_producer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">fmac_2_output_consumer</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">config</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fmac_1_a_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_a_c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fmac_1_a&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fmac_1_b_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_b_c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fmac_1_b&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fmac_1_output_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_output_c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fmac_1_output&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">spawn</span><span class="w"> </span><span class="n">Fmac</span><span class="p">(</span><span class="n">fmac_1_a_c</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_b_c</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_output_p</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fmac_2_a_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_a_c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fmac_2_a&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fmac_2_b_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_b_c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fmac_2_b&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fmac_2_output_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_output_c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fmac_2_output&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">spawn</span><span class="w"> </span><span class="n">Fmac</span><span class="p">(</span><span class="n">fmac_2_a_c</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_b_c</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_output_p</span><span class="p">);</span>

<span class="w">    </span><span class="p">(</span><span class="n">fmac_1_a_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_b_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_1_output_c</span><span class="p">,</span>
<span class="w">     </span><span class="n">fmac_2_a_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_b_p</span><span class="p">,</span><span class="w"> </span><span class="n">fmac_2_output_c</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<p>For each child proc, we first declare the necessary channels (each channel
declaration produces a producer and consumer channel, respectively), then we
actually spawn it. The first set of arguments is passed to the child's config
function. A spawn produces no value, hence no <code>let</code> on the left-hand side.</p>
<h2 id="tutorials-how_to_use_procs-advanced-features">Advanced features</h2>
<h3 id="tutorials-how_to_use_procs-channel-arrays-and-loop-based-spawning">Channel arrays and loop-based spawning</h3>
<blockquote>
<p><strong>Note</strong>: This feature is currently WIP and is not yet available.</p>
</blockquote>
<p>Many hardware layouts have regular arrays of components, such as systolic
arrays, vector units, etc. Individually specifying these quickly grows
cumbersome, so users can instead declare arrays of channels and spawn procs
inside <code>for</code> loops. This looks as follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">proc</span><span class="w"> </span><span class="n">Spawner4x4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">input_producers</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">output_consumers</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">config</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">input_producers</span><span class="p">,</span><span class="w"> </span><span class="n">input_consumers</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">](</span><span class="s">&quot;node_input&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">output_producers</span><span class="p">,</span><span class="w"> </span><span class="n">output_consumers</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">](</span><span class="s">&quot;node_output&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">spawn</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">input_consumers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
<span class="w">                   </span><span class="n">output_producers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="w">      </span><span class="p">}(());</span>
<span class="w">    </span><span class="p">}(());</span>

<span class="w">    </span><span class="p">(</span><span class="n">input_producers</span><span class="p">,</span><span class="w"> </span><span class="n">output_consumers</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="tutorials-how_to_use_procs-parametric-procs">Parametric procs</h3>
<p>Just as with other DSLX constructs, Procs can be parameterized. Parametrics must
be specified at the proc level, and not at the component function level (i.e.,
not on <code>config</code> or <code>next</code>). Building off of the previous example, this looks as
follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">proc</span><span class="w"> </span><span class="n">Parametric</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">input_producers</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">]</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">output_consumers</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">]</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">config</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">input_producers</span><span class="p">,</span><span class="w"> </span><span class="n">input_consumers</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">](</span><span class="s">&quot;node_input&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">output_producers</span><span class="p">,</span><span class="w"> </span><span class="n">output_consumers</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="n">F32</span><span class="o">&gt;</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">](</span><span class="s">&quot;node_output&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">spawn</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">input_consumers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
<span class="w">                   </span><span class="n">output_producers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="w">      </span><span class="p">}(());</span>
<span class="w">    </span><span class="p">}(());</span>

<span class="w">    </span><span class="p">(</span><span class="n">input_producers</span><span class="p">,</span><span class="w"> </span><span class="n">output_consumers</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<p>These two features are very powerful together: users can specify a broad variety
of designs simply by adjusting a few parametric values.</p>
<h2 id="tutorials-how_to_use_procs-proc-testing">Proc testing</h2>
<p>The DSLX interpreter supports testing procs via the <em>test_proc</em> construct. A
test proc is very similar to a normal proc with the following changes:</p>
<ul>
<li>A test proc is preceded by the <code>#[test_proc]</code> directive. This directive, as
    one might expect, notifies the interpreter that the following proc is a test
    proc.</li>
<li>A test proc's <code>config</code> function must accept a single argument: a boolean
    input channel for terminating interpretation. When the test is complete, the
    proc should send the test's status (<code>true</code> on success, <code>false</code> on failure)
    on that channel (commonly called the "terminator" channel).</li>
</ul>
<p>A skeletal example:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test_proc]</span>
<span class="n">proc</span><span class="w"> </span><span class="n">Tester</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">terminator</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">config</span><span class="p">(</span><span class="n">terminator</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">spawn</span><span class="w"> </span><span class="n">proc_under_test</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
<span class="w">    </span><span class="p">(</span><span class="n">terminator</span><span class="p">,)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">join</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// send and recv message to the proc under test.</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// terminate the test interpretation.</span>
<span class="w">    </span><span class="n">send</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">terminator</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The <a href="https://github.com/google/xls/tree/main/xls/examples/fp32_fmac.x">FP32 fmac module</a>
has a more complete proc test that may be used for reference.</p>
<h1 id="tutorials-how_to_use_procs-scheduling-constraints">Scheduling constraints</h1>
<p>If you want to interface with something in the outside world that is latency
sensitive (for example, an SRAM -- though we have separate infrastructure for
making SRAMs work that builds on top of this feature), you can create external
channels representing the interface you want to use, e.g.:</p>
<div class="highlight"><pre><span></span><code><span class="n">proc</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">req</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">  </span><span class="n">resp</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>

<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">config</span><span class="p">(</span><span class="n">req</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">resp</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">resp</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">next</span><span class="p">(</span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">request</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">resp</span><span class="p">);</span>
<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>where the fact that <code>req</code> and <code>resp</code> are parameters of <code>config</code>, and <code>main</code> is
the top proc during IR conversion, is what makes them "external".</p>
<p>Then when you codegen this, you can pass in
<code>--io_constraints=foo__req:send:foo__resp:recv:2:2</code> where <code>foo__req</code> is the
mangled name of the channel, which you can see by examining the generated IR
prior to codegen. That constraint means "a send on any channel named <code>req</code> must
occur exactly two cycles before a receive on any channel named <code>resp</code>"; the <code>2</code>
is specified twice because it is possible to give a range of allowed cycle
differences.</p>
<p>For more details on <code>--io_constraints</code>, check out
<a href="https://google.github.io/xls/codegen_options/#pipelining-and-scheduling-options">the docs</a>.
For a complete example, see <code>//xls/examples:constraint_sv</code> and
associated build targets; the target you'd build to get the mangled channel
names is <code>:constraint_ir</code>.</p>
<div class="footnote">
<hr />
<ol>
<li id="tutorials-how_to_use_procs-fn:proc_network">
<p>The proc network itself will form a tree, but channels may make
point-to-point connections between any two procs.&#160;<a class="footnote-backref" href="#tutorials-how_to_use_procs-fnref:proc_network" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><h1 class='nav-section-title-end'>Ended: DSLX</h1>
                        <h2 class='nav-section-title' id='section--contrib-xls-cc-'>
                            \[contrib\] XLS[cc] <a class='headerlink' href='#section--contrib-xls-cc-' title='Permanent link'>↵</a>
                        </h2>
                        <section class="print-page" id="tutorials-xlscc_overview"><h1 id="tutorials-xlscc_overview-xlscontrib-tutorial-xlscc-overview">[xls/contrib] Tutorial: XLS[cc] Overview</h1>
<div class="toc">
<ul>
<li><a href="#tutorials-xlscc_overview-xlscontrib-tutorial-xlscc-overview">[xls/contrib] Tutorial: XLS[cc] Overview</a><ul>
<li><a href="#tutorials-xlscc_overview-create-your-first-c-module">Create your first C++ module.</a></li>
<li><a href="#tutorials-xlscc_overview-translate-into-optimized-xls-ir">Translate into optimized XLS IR.</a></li>
<li><a href="#tutorials-xlscc_overview-perform-code-generation-into-a-combinational-verilog-block">Perform code-generation into a combinational Verilog block.</a></li>
<li><a href="#tutorials-xlscc_overview-create-your-second-c-module-and-generate-an-optimized-ir-file">Create your second C++ module and generate an optimized IR file.</a></li>
<li><a href="#tutorials-xlscc_overview-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</a></li>
<li><a href="#tutorials-xlscc_overview-additional-xlscc-examples">Additional XLS[cc] examples.</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial is aimed at walking you through getting a function written in C++
and then compiling into a working Verilog module.</p>
<p>This assumes that you've already been successful in building XLS. See
<a href="#tutorials-hello_xls">Installing and building</a>
if not.</p>
<h2 id="tutorials-xlscc_overview-create-your-first-c-module">Create your first C++ module.</h2>
<p>XLS[cc] takes as input a single translation unit -- one <code>.cc</code> file. Other files
may be included in that one file, but only the top-level file should be
provided.</p>
<p>Create a file called <code>test.cc</code> with the following contents.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#pragma hls_top</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>Note that <code>#pragma hls_top</code> denotes the top-level function for the module. The
xls func or proc created will follow that function's interface.</p>
<h2 id="tutorials-xlscc_overview-translate-into-optimized-xls-ir">Translate into optimized XLS IR.</h2>
<p>Now that the C++ function has been created, <code>xlscc</code> can be used to translate the
C++ into XLS IR. <code>opt_main</code> is used afterwards to optimize and transform the IR
into a form more easily synthesized into verilog.</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/contrib/xlscc/xlscc test.cc &gt; test.ir
$ ./bazel-bin/xls/tools/opt_main test.ir &gt; test.opt.ir
</code></pre></div>
<p>The resulting <code>test.opt.ir</code> file should look something like the following</p>
<div class="highlight"><pre><span></span><code>package my_package

file_number 1 &quot;./test.cc&quot;

top fn add3(input: bits[32]) -&gt; bits[32] {
  literal.2: bits[32] = literal(value=3, id=2, pos=[(1,2,23)])
  ret add.3: bits[32] = add(input, literal.2, id=3, pos=[(1,2,23)])
}
</code></pre></div>
<h2 id="tutorials-xlscc_overview-perform-code-generation-into-a-combinational-verilog-block">Perform code-generation into a combinational Verilog block.</h2>
<p>With the same IR, you can either generate a combinational block or a clocked
pipelined block with the <code>codegen_main</code> tool. In this section, we'll demonstrate
how to generate a combinational block.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/codegen_main<span class="w"> </span>test.opt.ir<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--generator<span class="o">=</span>combinational<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--delay_model<span class="o">=</span><span class="s2">&quot;unit&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output_verilog_path<span class="o">=</span>test.v<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--module_name<span class="o">=</span>xls_test<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--top<span class="o">=</span>add3
</code></pre></div>
<p>Below is a quick summary of each option:</p>
<ol>
<li><code>--generator=combinational</code> states that <code>codegen_main</code> should generate a
    combinational module.</li>
<li><code>--delay_model="unit"</code> states to use the unit delay model. Additional delay
    models include asap7 and sky130.</li>
<li><code>--output_verilog_path=test.v</code> is where the output verilog should be written
    to.</li>
<li><code>--module_name=xls_test</code> states that the generated verilog module should
    have the name of <code>xls_test</code>.</li>
<li><code>--top=add3</code> states that the function that should be used for codegen is the
    function (<code>fn</code>) named <code>add3</code>.</li>
</ol>
<p>The resulting <code>test.v</code> should have contents similar to the following</p>
<div class="highlight"><pre><span></span><code>module xls_test(
  input wire [31:0] input,
  output wire [31:0] out
);
  wire [31:0] add_6;
  assign add_6 = input + 32&#39;h0000_0003;
  assign out = add_6;
endmodule
</code></pre></div>
<h2 id="tutorials-xlscc_overview-create-your-second-c-module-and-generate-an-optimized-ir-file">Create your second C++ module and generate an optimized IR file.</h2>
<p>XLS[cc] supports two ways of handling looping C++ constructs -- it can unroll
the loop, or convert the loop into sequential logic. In this section, we'll
demonstrate loop unrolling.</p>
<p>Unrolled loops are annotated with <code>#pragma hls_unroll yes</code>. For example, create
a file called <code>test_unroll.cc</code> with the following contents.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#pragma hls_top</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">test_unroll</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="cp">#pragma hls_unroll yes</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Then compile, and optimize the resulting IR</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/contrib/xlscc/xlscc test_unroll.cc &gt; test_unroll.ir
$ ./bazel-bin/xls/tools/opt_main test_unroll.ir &gt; test_unroll.opt.ir
</code></pre></div>
<h2 id="tutorials-xlscc_overview-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</h2>
<p>The previous section should have left you with an IR file called
<code>test_unroll.opt.ir</code> with a function with the signature <code>fn test_unroll(x:
bits[32]) -&gt; bits[32]</code>. The function is likely too large to fit into a single
clock cycle so we'll create a pipelined module.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/codegen_main<span class="w"> </span>test_unroll.opt.ir<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--generator<span class="o">=</span>pipeline<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--delay_model<span class="o">=</span><span class="s2">&quot;asap7&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output_verilog_path<span class="o">=</span>test_unroll.v<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--module_name<span class="o">=</span>xls_test_unroll<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--entry<span class="o">=</span>test_unroll<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset<span class="o">=</span>rst<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_active_low<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_asynchronous<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--pipeline_stages<span class="o">=</span><span class="m">5</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_inputs<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_outputs<span class="o">=</span><span class="nb">true</span>
</code></pre></div>
<p>Below is a quick summary of each option:</p>
<ol>
<li><code>--generator=pipeline</code> - <code>codegen_main</code> should generate a pipelined module.</li>
<li><code>--delay_model="asap7"</code> - use the asap7 delay model.</li>
<li><code>--output_verilog_path=test_unroll.v</code> - where the output verilog should be
    written to.</li>
<li><code>--module_name=xls_test_unroll</code> - the generated verilog module should have
    the name of <code>xls_unroll_test</code>.</li>
<li><code>--entry=test_unroll</code> - the function that should be used for codegen is the
    function (<code>fn</code>) named <code>test_unroll</code>.</li>
<li><code>--reset=rst</code> - there should be a reset signal named <code>rst</code>.</li>
<li><code>--reset_active_low=false</code> - a high reset signal means reset the module.</li>
<li><code>--reset_asynchronous=false</code> - rst is a synchronous reset signal.</li>
<li><code>--pipeline_stages=5</code> - create a 5 stage pipeline.</li>
<li><code>--flop_inputs=true</code> and <code>--flop_outputs=true</code> - input and outputs for the
    block are registered.</li>
</ol>
<h2 id="tutorials-xlscc_overview-additional-xlscc-examples">Additional XLS[cc] examples.</h2>
<p>The above tutorials only touches upon the capabilities of XLS[cc]. XLS[cc] is
based on libclang and supports many C++17 features. Notable <em>unsupported</em>
features include pointers, function pointers, and virtual methods.</p>
<p>For developers, it is possible to check if a specific feature is supported by
checking
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_logic_test.cc">translator_logic_test.cc</a>
and other unit tests in the same directory.</p></section><section class="print-page" id="tutorials-xlscc_integers"><h1 id="tutorials-xlscc_integers-xlscontrib-tutorial-xlscc-arbitrary-width-integers">[xls/contrib] Tutorial: XLS[cc] arbitrary width integers.</h1>
<div class="toc">
<ul>
<li><a href="#tutorials-xlscc_integers-xlscontrib-tutorial-xlscc-arbitrary-width-integers">[xls/contrib] Tutorial: XLS[cc] arbitrary width integers.</a><ul>
<li><a href="#tutorials-xlscc_integers-c-source">C++ Source</a></li>
<li><a href="#tutorials-xlscc_integers-introduction-to-fixed-width-integers">Introduction to fixed-width integers.</a></li>
<li><a href="#tutorials-xlscc_integers-configuring-xlscc-for-fixed-width-integers">Configuring XLS[cc] for fixed-width integers.</a></li>
<li><a href="#tutorials-xlscc_integers-translate-into-optimized-xls-ir">Translate into optimized XLS IR.</a></li>
<li><a href="#tutorials-xlscc_integers-additional-xlscc-examples">Additional XLS[cc] examples.</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial is aimed at walking you through usage of arbitrary width integers
using the XlsInt class.</p>
<p>Note that an <code>ac_datatypes</code> compatibility layer is also provided so that the
same C++ code can be used for both simulation and XLS[cc] synthesis with just a
change in the include paths:
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/synth_only/ac_compat">ac_compat</a>.</p>
<h2 id="tutorials-xlscc_integers-c-source">C++ Source</h2>
<h2 id="tutorials-xlscc_integers-introduction-to-fixed-width-integers">Introduction to fixed-width integers.</h2>
<p>XLS also provides a template class for fixed-width integers. These are declared
using the template class <code>XlsInt&lt;int Width, bool Signed = true&gt;</code>.</p>
<p>To utilize fixed with integer types, include
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/synth_only/xls_int.h">xls_int.h</a>.</p>
<p>Create a <code>test.cc</code> with the following contents for the rest of this tutorial.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;xls_int.h&quot;</span>

<span class="cp">#pragma hls_top</span>
<span class="n">XlsInt</span><span class="o">&lt;</span><span class="mi">55</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">XlsInt</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">XlsInt</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="tutorials-xlscc_integers-configuring-xlscc-for-fixed-width-integers">Configuring XLS[cc] for fixed-width integers.</h2>
<p>XLS[cc] fixed-width integers have a dependency on the <code>ac_datatypes</code> library.
Clone the repository (https://github.com/hlslibs) into a directory named
<code>ac_datatypes</code>.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/hlslibs/ac_types.git<span class="w"> </span>ac_datatypes
</code></pre></div>
<p>Then create the a <code>clang.args</code> file with the following contents to configure the
include paths and pre-define the <code>__SYNTHESIS__</code> name as a macro.</p>
<div class="highlight"><pre><span></span><code>-D__SYNTHESIS__
-I/path/to/your/xls/contrib/xlscc/synth_only
-I/path/containing/ac_datatypes/..
</code></pre></div>
<h2 id="tutorials-xlscc_integers-translate-into-optimized-xls-ir">Translate into optimized XLS IR.</h2>
<p>Now that the C++ function has been created, <code>xlscc</code> can be used to translate the
C++ into XLS IR. <code>opt_main</code> is used afterwards to optimize and transform the IR
into a form more easily synthesized into verilog.</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/contrib/xlscc/xlscc test.cc --clang_args_file clang.args &gt; test.ir
$ ./bazel-bin/xls/tools/opt_main test.ir &gt; test.opt.ir
</code></pre></div>
<p>The resulting <code>test.opt.ir</code> file should look something like the following</p>
<div class="highlight"><pre><span></span><code>package my_package

file_number 1 &quot;/usr/local/google/home/seanhaskell/tmp/tutorial_int.cc&quot;
file_number 2 &quot;/usr/local/google/home/seanhaskell/xls/xls/contrib/xlscc/synth_only/xls_int.h&quot;

top fn foo(x: bits[17], y: bits[5]) -&gt; bits[55] {
  literal.132: bits[1] = literal(value=0, id=132, pos=[(1,6,2)])
  literal.133: bits[13] = literal(value=0, id=133, pos=[(1,6,2)])
  xid4: bits[18] = concat(literal.132, x, id=134, pos=[(1,6,2)])
  yid6__1: bits[18] = concat(literal.133, y, id=135, pos=[(1,6,2)])
  literal.141: bits[37] = literal(value=0, id=141, pos=[(1,6,2)])
  xid4id8: bits[18] = add(xid4, yid6__1, id=140, pos=[(1,6,2)])
  ret xid4id8id2: bits[55] = concat(literal.141, xid4id8, id=143, pos=[(1,6,2)])
}
</code></pre></div>
<h2 id="tutorials-xlscc_integers-additional-xlscc-examples">Additional XLS[cc] examples.</h2>
<p>For developers, it is possible to check if a specific feature is supported by
checking
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/xls_int_test.cc">xls_int_test.cc</a>
for unit tests.</p></section><section class="print-page" id="tutorials-xlscc_channels"><h1 id="tutorials-xlscc_channels-xlscontrib-tutorial-xlscc-channels">[xls/contrib] Tutorial: XLS[cc] channels.</h1>
<div class="toc">
<ul>
<li><a href="#tutorials-xlscc_channels-xlscontrib-tutorial-xlscc-channels">[xls/contrib] Tutorial: XLS[cc] channels.</a><ul>
<li><a href="#tutorials-xlscc_channels-introduction-to-channels">Introduction to channels.</a></li>
<li><a href="#tutorials-xlscc_channels-translate-into-optimized-xls-ir">Translate into optimized XLS IR.</a></li>
<li><a href="#tutorials-xlscc_channels-note-the-metadata-output">Note the metadata output</a></li>
<li><a href="#tutorials-xlscc_channels-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</a></li>
<li><a href="#tutorials-xlscc_channels-additional-xlscc-examples">Additional XLS[cc] examples.</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial is aimed at walking you through the implementation and synthesis
into Verilog of a sequential C++ block containing channels.</p>
<h2 id="tutorials-xlscc_channels-introduction-to-channels">Introduction to channels.</h2>
<p>XLS implements channels via a FIFO-based (ready/valid/data) interface.</p>
<p>In C++, these channels are provided by a built-in template class called
<code>__xls_channel</code> supporting the two methods: <code>read()</code> and <code>write(val)</code>.</p>
<p>It can be aliased to the desired name like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">OutputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_Out</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">InputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_In</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>An example of a usage is below, which reads an integer on the input channel,
multiplies it by 3, and writes it to the output channel.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TestBlock</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">InputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>
<span class="w">    </span><span class="n">OutputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma hls_top</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="tutorials-xlscc_channels-translate-into-optimized-xls-ir">Translate into optimized XLS IR.</h2>
<p>With the above setup complete, XLS IR can now be generated using a sequence of
<code>xlscc</code> and <code>opt_main</code>.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/contrib/xlscc/xlscc<span class="w"> </span>test_channels.cc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--block_from_class<span class="w"> </span>TestBlock<span class="w"> </span>--block_pb<span class="w"> </span>meta.pb<span class="w"> </span>&gt;<span class="w"> </span>test_channels.ir
$<span class="w"> </span>./bazel-bin/xls/tools/opt_main<span class="w"> </span>test_channels.ir<span class="w"> </span>&gt;<span class="w"> </span>test_channels.opt.ir
</code></pre></div>
<p>Below is a quick summary of the options. 1. <code>--block_from_class TestBlock</code> -
tells XLS[cc] which class is the top block. 1. <code>--block_pb</code> - tells XLS[cc]
where to write the block's metadata description. This must be specified with
<code>--block_from_class</code>.</p>
<p>Note that unlike in the prior tutorial, XLS[cc] is used to generate
<a href="#ir_semantics-proc">XLS procs</a>
rather than functions. This is to support the additional interface requirements
of channels.</p>
<h2 id="tutorials-xlscc_channels-note-the-metadata-output">Note the metadata output</h2>
<p>The file <code>meta.pb</code> now contains a description of the block which can be useful
for integration. In this example, the result is:</p>
<div class="highlight"><pre><span></span><code>channels {
  name: &quot;in&quot;
  is_input: true
  type: FIFO
  width_in_bits: 32
}
channels {
  name: &quot;out&quot;
  is_input: false
  type: FIFO
  width_in_bits: 32
}
name: &quot;TestBlock&quot;
</code></pre></div>
<h2 id="tutorials-xlscc_channels-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</h2>
<p>With the same IR, you can either generate a combinational block or a clocked
pipelined block with the <code>codegen_main</code> tool. In this section, we'll demonstrate
how to generate a pipelined block using the above C++ code.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/codegen_main<span class="w"> </span>test_channels.opt.ir<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--generator<span class="o">=</span>pipeline<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--delay_model<span class="o">=</span><span class="s2">&quot;sky130&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output_verilog_path<span class="o">=</span>test_channels.v<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--module_name<span class="o">=</span>xls_test<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--top<span class="o">=</span>TestBlock_proc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset<span class="o">=</span>rst<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_active_low<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_asynchronous<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_data_path<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--pipeline_stages<span class="o">=</span><span class="m">5</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_inputs<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_outputs<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_inputs_kind<span class="o">=</span>skid<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_outputs_kind<span class="o">=</span>skid
</code></pre></div>
<p>Below is a quick summary of the options.</p>
<ol>
<li><code>--delay_model="sky130"</code> - use the sky130 delay model.</li>
<li><code>--top=TestBlock_proc</code> - the proc that is the top-level is named
    <code>TestBlock_proc</code>. This should be the block class name given to XLS[cc] with
    a <code>_proc</code> suffix appended.</li>
<li><code>--flop_inputs_kind=skid</code> and <code>--flop_outputs_kind=skid</code> - control what type
    of I/O buffering is used. In this case, we configure a skid buffer at both
    the input and output.</li>
</ol>
<h2 id="tutorials-xlscc_channels-additional-xlscc-examples">Additional XLS[cc] examples.</h2>
<p>For developers, it is possible to check if a specific feature is supported by
checking
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_io_test.cc">translator_io_test.cc</a>
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_proc_test.cc">translator_proc_test.cc</a>
for unit tests.</p></section><section class="print-page" id="tutorials-xlscc_memory"><h1 id="tutorials-xlscc_memory-xlscontrib-tutorial-xlscc-memories">[xls/contrib] Tutorial: XLS[cc] memories.</h1>
<div class="toc">
<ul>
<li><a href="#tutorials-xlscc_memory-xlscontrib-tutorial-xlscc-memories">[xls/contrib] Tutorial: XLS[cc] memories.</a><ul>
<li><a href="#tutorials-xlscc_memory-c-source">C++ Source</a></li>
<li><a href="#tutorials-xlscc_memory-translate-to-ir">Translate to IR</a></li>
<li><a href="#tutorials-xlscc_memory-examine-the-metadata">Examine the metadata</a></li>
<li><a href="#tutorials-xlscc_memory-optimize-the-ir-with-ram-rewrites">Optimize the IR with RAM rewrites</a></li>
<li><a href="#tutorials-xlscc_memory-generate-verilog-with-io-constraints">Generate Verilog with IO constraints</a></li>
<li><a href="#tutorials-xlscc_memory-additional-xlscc-examples">Additional XLS[cc] examples.</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial is aimed at walking you through usage of memories. Memories in
this context refer to externally implemented SRAMs. The example given will be
usage of a dual port "1 read 1 write" memory.</p>
<p>The channels tutorial should be followed as a prerequisite.</p>
<h2 id="tutorials-xlscc_memory-c-source">C++ Source</h2>
<p>Create a source file <code>test_memory.cc</code></p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">InputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_In</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">OutputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_Out</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TestBlock</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">InputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>
<span class="w">    </span><span class="n">OutputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">    </span><span class="n">Memory</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">store</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma hls_top</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">next_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mb">0b11111</span><span class="p">;</span>
<span class="w">        </span><span class="n">store</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">store</span><span class="p">[</span><span class="n">next_addr</span><span class="p">]);</span>
<span class="w">        </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="tutorials-xlscc_memory-translate-to-ir">Translate to IR</h2>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/contrib/xlscc/xlscc<span class="w"> </span>test_memory.cc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--block_from_class<span class="w"> </span>TestBlock<span class="w"> </span>--block_pb<span class="w"> </span>block.pb<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>&gt;<span class="w"> </span>test_memory.ir
</code></pre></div>
<h2 id="tutorials-xlscc_memory-examine-the-metadata">Examine the metadata</h2>
<p>The memory should appear in the resulting block <code>block.pb</code>:</p>
<div class="highlight"><pre><span></span><code>channels {
  name: &quot;in&quot;
  is_input: true
  type: FIFO
  width_in_bits: 32
}
channels {
  name: &quot;out&quot;
  is_input: false
  type: FIFO
  width_in_bits: 32
}
channels {
  name: &quot;store&quot;
  type: MEMORY
  width_in_bits: 16
  depth: 32
}
name: &quot;TestBlock&quot;
</code></pre></div>
<p>This block description information can be used to generate the RAM rewrites and
IO constraints specified in later steps.</p>
<h2 id="tutorials-xlscc_memory-optimize-the-ir-with-ram-rewrites">Optimize the IR with RAM rewrites</h2>
<p>Create <code>rewrites.textproto</code> with the following contents:</p>
<div class="highlight"><pre><span></span><code>rewrites {
  from_config {
    kind: RAM_ABSTRACT
    depth: 32
  }
  to_config {
    kind: RAM_1R1W
    depth: 32
  }
  from_channels_logical_to_physical: {
    key: &quot;abstract_read_req&quot;
    value: &quot;store__read_request&quot;
  }
  from_channels_logical_to_physical: {
    key: &quot;abstract_read_resp&quot;
    value: &quot;store__read_response&quot;
  }
  from_channels_logical_to_physical: {
    key: &quot;abstract_write_req&quot;
    value: &quot;store__write_request&quot;
  }
  from_channels_logical_to_physical: {
    key: &quot;write_completion&quot;
    value: &quot;store__write_response&quot;
  }
  to_name_prefix: &quot;store_&quot;
}
</code></pre></div>
<p>Then run <code>opt</code> with awareness of the RAM:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/opt_main<span class="w"> </span>test_memory.ir<span class="w"> </span>--ram_rewrites_pb<span class="w"> </span>rewrites.textproto<span class="w"> </span>&gt;<span class="w"> </span>test_memory.opt.ir
</code></pre></div>
<h2 id="tutorials-xlscc_memory-generate-verilog-with-io-constraints">Generate Verilog with IO constraints</h2>
<p>For this memory, we are assuming a fixed 1-cycle latency for reads and writes.
As such, we need to add these constraints to the <code>codegen</code> command, in addition
to making it aware of the RAM rewrites, so that the correct ports are generated.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/codegen_main<span class="w"> </span>test_memory.opt.ir<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--generator<span class="o">=</span>pipeline<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--delay_model<span class="o">=</span><span class="s2">&quot;sky130&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output_verilog_path<span class="o">=</span>memory_test.v<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--module_name<span class="o">=</span>memory_test<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--top<span class="o">=</span>TestBlock_proc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset<span class="o">=</span>rst<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_active_low<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_asynchronous<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_data_path<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--pipeline_stages<span class="o">=</span><span class="m">2</span><span class="w">  </span><span class="se">\</span>
<span class="w">  </span>--flop_inputs<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_outputs<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--io_constraints<span class="o">=</span>store__read_req:send:store__read_resp:recv:1:1,store__write_req:send:store__write_completion:recv:1:1<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--ram_configurations<span class="o">=</span>ram:1R1W:store__read_req:store__read_resp:store__write_req:store__write_completion
</code></pre></div>
<p>Below is a quick summary of the options.</p>
<ol>
<li><code>--io_constraints=store__read_req:send:store__read_resp:recv:1:1...</code> This
    option ensures that requests to the memory are written exactly 1 cycle
    before responses are read.</li>
<li><code>--ram_configurations=ram:1R1W:store__read_req...</code> This option informs
    codegen of the necessary information about the memory to generate the top
    level ports in the correct style. "ram" is the name prefix the ports will
    use.</li>
</ol>
<h2 id="tutorials-xlscc_memory-additional-xlscc-examples">Additional XLS[cc] examples.</h2>
<p>For developers, it is possible to check if a specific feature is supported by
checking
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_memory_test.cc">translator_memory_test.cc</a>
for unit tests.</p></section><section class="print-page" id="tutorials-xlscc_state"><h1 id="tutorials-xlscc_state-xlscontrib-tutorial-xlscc-state">[xls/contrib] Tutorial: XLS[cc] state.</h1>
<div class="toc">
<ul>
<li><a href="#tutorials-xlscc_state-xlscontrib-tutorial-xlscc-state">[xls/contrib] Tutorial: XLS[cc] state.</a><ul>
<li><a href="#tutorials-xlscc_state-c-source">C++ Source</a></li>
<li><a href="#tutorials-xlscc_state-generate-optimized-xls-ir">Generate optimized XLS IR.</a></li>
<li><a href="#tutorials-xlscc_state-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</a></li>
<li><a href="#tutorials-xlscc_state-additional-xlscc-examples">Additional XLS[cc] examples.</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial is aimed at walking you through the implementation and synthesis
into Verilog of a C++ function containing state.</p>
<p>XLS[cc] may infer that in order to achieve a particular implementation of a C++
function, operations may occur over multiple cycles and require additional proc
state to be kept. Common constructs that may require this are static variables,
or loops that aren't unrolled. In this tutorial we give an example using static
variables.</p>
<h2 id="tutorials-xlscc_state-c-source">C++ Source</h2>
<p>Create a file named <code>test_state.cc</code> with the following contents.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">OutputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_Out</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TestBlock</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">OutputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma hls_top</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="tutorials-xlscc_state-generate-optimized-xls-ir">Generate optimized XLS IR.</h2>
<p>Use a combination of <code>xlscc</code> and <code>opt_main</code> to generate optimized XLS IR.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/contrib/xlscc/xlscc<span class="w"> </span>test_state.cc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--block_from_class<span class="w"> </span>TestBlock<span class="w"> </span>--block_pb<span class="w"> </span>block.pb<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>&gt;<span class="w"> </span>test_state.ir
$<span class="w"> </span>./bazel-bin/xls/tools/opt_main<span class="w"> </span>test_state.ir<span class="w"> </span>&gt;<span class="w"> </span>test_state.opt.ir
</code></pre></div>
<h2 id="tutorials-xlscc_state-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</h2>
<p>In this case, we will generate a single-stage pipeline without input and output
flops. This will result in a module with a 32-bit increment adder along with
32-bit of state.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/codegen_main<span class="w"> </span>test_state.opt.ir<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--generator<span class="o">=</span>pipeline<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--delay_model<span class="o">=</span><span class="s2">&quot;sky130&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output_verilog_path<span class="o">=</span>xls_counter.v<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--module_name<span class="o">=</span>xls_counter<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--top<span class="o">=</span>TestBlock_proc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset<span class="o">=</span>rst<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_active_low<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_asynchronous<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_data_path<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--pipeline_stages<span class="o">=</span><span class="m">1</span><span class="w">  </span><span class="se">\</span>
<span class="w">  </span>--flop_inputs<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_outputs<span class="o">=</span><span class="nb">false</span>
</code></pre></div>
<p>After running codegen, you should see a file named <code>xls_counter.v</code> with contents
similar to the following.</p>
<div class="highlight"><pre><span></span><code>module xls_counter(
  input wire clk,
  input wire rst,
  input wire out_rdy,
  output wire [31:0] out,
  output wire out_vld
);
  reg [31:0] __st__1;
  wire literal_43;
  wire literal_40;
  wire [31:0] add_37;
  wire pipeline_enable;
  assign literal_43 = 1&#39;h1;
  assign literal_40 = 1&#39;h1;
  assign add_37 = __st__1 + 32&#39;h0000_0001;
  assign pipeline_enable = literal_43 &amp; literal_40 &amp; out_rdy &amp; (literal_43 &amp; literal_40 &amp; out_rdy);
  always_ff @ (posedge clk) begin
    if (rst) begin
      __st__1 &lt;= 32&#39;h0000_0000;
    end else begin
      __st__1 &lt;= pipeline_enable ? add_37 : __st__1;
    end
  end
  assign out = __st__1;
  assign out_vld = literal_40 &amp; literal_43 &amp; 1&#39;h1;
endmodule
</code></pre></div>
<h2 id="tutorials-xlscc_state-additional-xlscc-examples">Additional XLS[cc] examples.</h2>
<p>For developers, it is possible to check if a specific feature is supported by
checking
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_static_test.cc">translator_static_test.cc</a>
and
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_proc_test.cc">translator_proc_test.cc</a>
for unit tests.</p></section><section class="print-page" id="tutorials-xlscc_pipelined_loops"><h1 id="tutorials-xlscc_pipelined_loops-xlscontrib-tutorial-xlscc-pipelined-loops">[xls/contrib] Tutorial: XLS[cc] pipelined loops.</h1>
<div class="toc">
<ul>
<li><a href="#tutorials-xlscc_pipelined_loops-xlscontrib-tutorial-xlscc-pipelined-loops">[xls/contrib] Tutorial: XLS[cc] pipelined loops.</a><ul>
<li><a href="#tutorials-xlscc_pipelined_loops-c-source">C++ Source</a></li>
<li><a href="#tutorials-xlscc_pipelined_loops-generate-optimized-xls-ir">Generate optimized XLS IR.</a></li>
<li><a href="#tutorials-xlscc_pipelined_loops-examine-the-optimized-ir">Examine the optimized IR</a></li>
<li><a href="#tutorials-xlscc_pipelined_loops-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</a></li>
<li><a href="#tutorials-xlscc_pipelined_loops-additional-xlscc-examples">Additional XLS[cc] examples.</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial is aimed at walking you through the implementation and synthesis
into Verilog of a C++ function containing a pipelined loop. Pipelined loops are
an automatic way of generating stateful logic that can often be more intuitive
and software-like than using explicit state (eg via <code>static</code>).</p>
<h2 id="tutorials-xlscc_pipelined_loops-c-source">C++ Source</h2>
<p>Create a file named <code>test_loop.cc</code> with the following contents.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">InputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_In</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">OutputChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__xls_channel</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">__xls_channel_dir_Out</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TestBlock</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">InputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>
<span class="w">    </span><span class="n">OutputChannel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma hls_top</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="cp">#pragma hls_pipeline_unroll yes</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="tutorials-xlscc_pipelined_loops-generate-optimized-xls-ir">Generate optimized XLS IR.</h2>
<p>Use a combination of <code>xlscc</code> and <code>opt_main</code> to generate optimized XLS IR.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/contrib/xlscc/xlscc<span class="w"> </span>test_loop.cc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--block_from_class<span class="w"> </span>TestBlock<span class="w"> </span>--block_pb<span class="w"> </span>block.pb<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>&gt;<span class="w"> </span>test_loop.ir
$<span class="w"> </span>./bazel-bin/xls/tools/opt_main<span class="w"> </span>test_loop.ir<span class="w"> </span>--inline_procs<span class="w"> </span>&gt;<span class="w"> </span>test_loop.opt.ir
</code></pre></div>
<p>The <code>--inline_procs</code> option is necessary to make pipelined loops synthesizable.</p>
<h2 id="tutorials-xlscc_pipelined_loops-examine-the-optimized-ir">Examine the optimized IR</h2>
<p><code>test_loop.opt.ir</code> should look like this, containing only one proc:</p>
<div class="highlight"><pre><span></span><code>package my_package

file_number 1 &quot;/usr/local/google/home/seanhaskell/tmp/tutorial_loop.cc&quot;

chan in(bits[32], id=0, kind=streaming, ops=receive_only, flow_control=ready_valid, metadata=&quot;&quot;&quot;&quot;&quot;&quot;)
chan out(bits[32], id=1, kind=streaming, ops=send_only, flow_control=ready_valid, metadata=&quot;&quot;&quot;&quot;&quot;&quot;)

top proc TestBlock_proc(tkn: token, __for_1_proc_state__4: bits[1], __for_1_proc_state__5: bits[32], __for_1_proc_state__6: bits[32], __for_1_proc_activation__1: bits[1], __for_1_ctx_out_receive_holds_activation__1: bits[1], TestBlock_proc_activation__1: bits[1], after_all_186_holds_activation_0__1: bits[1], after_all_186_holds_activation_1__1: bits[1], after_all_84_holds_activation_0__1: bits[1], after_all_84_holds_activation_1__1: bits[1], after_all_84_holds_activation_2__1: bits[1], __for_1_ctx_in_receive_holds_activation__1: bits[1], init={1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0}) {
...
  next (after_all.354, __for_1_proc___first_tick_next_state, __for_1_proc_sum_next_state, __for_1_proc_i_next_state, __for_1_ctx_out_receive_activation_out, __for_1_ctx_out_receive_holds_activation_next__1, after_all_84_is_activated, after_all_186_holds_activation_0_next__1, after_all_186_holds_activation_1_next__1, after_all_84_holds_activation_0_next__1, after_all_84_holds_activation_1_next__1, after_all_84_holds_activation_2_next__1, __for_1_ctx_in_receive_holds_activation_next__1)
}
</code></pre></div>
<h2 id="tutorials-xlscc_pipelined_loops-perform-code-generation-into-a-pipelined-verilog-block">Perform code-generation into a pipelined Verilog block.</h2>
<p>In this case, we will generate a single-stage pipeline without input and output
flops. This will result in a module with a 32-bit increment adder along with
32-bit of state.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./bazel-bin/xls/tools/codegen_main<span class="w"> </span>test_loop.opt.ir<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--generator<span class="o">=</span>pipeline<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--delay_model<span class="o">=</span><span class="s2">&quot;sky130&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output_verilog_path<span class="o">=</span>xls_counter.v<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--module_name<span class="o">=</span>xls_counter<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--top<span class="o">=</span>TestBlock_proc<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset<span class="o">=</span>rst<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_active_low<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_asynchronous<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--reset_data_path<span class="o">=</span><span class="nb">true</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--pipeline_stages<span class="o">=</span><span class="m">1</span><span class="w">  </span><span class="se">\</span>
<span class="w">  </span>--flop_inputs<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--flop_outputs<span class="o">=</span><span class="nb">false</span>
</code></pre></div>
<h2 id="tutorials-xlscc_pipelined_loops-additional-xlscc-examples">Additional XLS[cc] examples.</h2>
<p>For developers, it is possible to check if a specific feature is supported by
checking
<a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc/unit_tests/translator_proc_test.cc">translator_proc_test.cc</a>
for unit tests.</p></section><h1 class='nav-section-title-end'>Ended: \[contrib\] XLS[cc]</h1><h1 class='nav-section-title-end'>Ended: Tutorials</h1><section class="print-page" id="faq"><h1 id="faq-xls-faq">XLS FAQ</h1>
<h2 id="faq-q-how-do-i-select-bubble-strategies-in-pipeline-generation">Q: How do I select bubble strategies in pipeline generation?</h2>
<p><strong>Tags:</strong> codegen, pipeline, configuration</p>
<p>I/O behavior is described in the
<a href="#codegen_options-io-behavior">codegen options</a> documentation. ("codegen" for
XLS is the concept of "exactly what verilog should be produced?") There are
currently options for controlling queueing behavior at the inputs or outputs of
the block, but not internal to the pipeline, ability to stall with queueing that
is embedded in the generated pipeline is tracked in
<a href="https://github.com/google/xls/issues/255">issue #255</a>.</p>
<h2 id="faq-q-what-is-the-granularity-of-readyvalid-signaling">Q: What is the granularity of ready/valid signaling?</h2>
<p><strong>Tags:</strong> codegen, pipeline, configuration</p>
<p>Ready/valid signals are associated with a (streaming) channel, and in general
I/O signaling is configured on a per-channel basis. Users are expected to send
things "broadside" (all together at once) if they should share the same
ready/valid signaling; e.g. by sending a struct or array over the channel.</p>
<p>See the <code>--streaming_channel_*</code> options within the
<a href="#codegen_options-naming">codegen options</a> documentation.</p>
<h2 id="faq-q-how-do-i-call-my-xls-functions-from-c">Q: How do I call my XLS functions from C++?</h2>
<p><strong>Tags:</strong> native, simulation, cpp</p>
<p>The steps are:</p>
<ol>
<li>Wrap up your XLS so it can be called from C++ (using a utility).</li>
<li>Include the created header.</li>
<li>Call the "Run" API with XLS-understood values.</li>
</ol>
<p>The
<a href="https://google.github.io/xls/bazel_rules_macros/#cc_xls_ir_jit_wrapper"><code>cc_xls_ir_jit_wrapper</code> rule</a>
in the Bazel rule set invokes a tool (the
<a href="https://github.com/google/xls/tree/main/xls/jit/jit_wrapper_generator_main.py">JIT wrapper generator</a>)
that makes a shim that helpfully JIT compiles the IR to native code (e.g. x64
code), and provides an object that can be used as a C++ callable.</p>
<p>As an example, see the
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/float32_mul_test.cc">float32 multiply test</a>,
which calls <code>Run()</code> on the float32 multiplier which is written in XLS and
wrapped in the
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/BUILD"><code>float32_mul_jit_wrapper</code> build target</a>.</p>
<p>Note that for some APIs, e.g. those taking a XLS single precision float, the
created interface <em>will</em> be able to accept a native C++ <code>float</code> directly, and
similar for types like <code>uint32_t</code>, <code>uint64_t</code>, etc.</p></section>
                        <h1 class='nav-section-title' id='section-ir'>
                            IR <a class='headerlink' href='#section-ir' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="ir_overview"><h1 id="ir_overview-xls-ir-overview">XLS: IR Overview</h1>
<div class="toc">
<ul>
<li><a href="#ir_overview-xls-ir-overview">XLS: IR Overview</a></li>
</ul>
</div>
<p>Before providing a detailed specification of the IR, in this section we briefly
outline the ideas and philosophy behind the IR design and explain how to build,
modify, and navigate the IR.</p>
<p>The XLS IR is a dataflow-oriented IR that has the static-single-assignment (SSA)
property, but is specialized for generating circuitry. It started out as a
purely functional IR but over time more and more side-effecting operations had
to be introduced. Specifically:</p>
<ul>
<li>XLS has a single IR representation which is used from the front-end down to
    the RTL-level. A single representation throughout the compiler enables
    maximal reuse of analysis and transformation components. Often compilers
    have different specialized IRs (or "dialects") for different levels of
    abstraction which can add complexity and inhibit reusability. However, in
    XLS this tradeoff between specialization and reusability is unnecessary
    because we start with a dataflow representation in the front end and can
    smoothly lower the IR down to the RTL-level which is itself dataflow.</li>
</ul>
<ul>
<li>XLS IR is <em>not</em> control-flow graph (CFG) based, as many other compiler
    infrastructures. The insight is that the CFG abstraction was developed to
    model serial execution on a CPU. In hardware, however, everything happens at
    all times and in parallel. A <em>sea-of-nodes</em> (SoN) representation much more
    closely resembles this reality, which is why we have chosen it.<p>It further turns out that many optimization passes are rather trivial to
  implement in the SoN representation, in particular as it requires no
  explicit SSA updates. The SSA property is automatically maintained by the IR
  being functional.</p>
</li>
</ul>
<p>TODO: High-level structure, package -&gt; func,proc,block -&gt; sea of nodes</p>
<p>TODO: How to navigate</p>
<p>TODO: Talk about basic types</p></section><section class="print-page" id="ir_semantics"><h1 id="ir_semantics-xls-ir-semantics">XLS: IR semantics</h1>
<div class="toc">
<ul>
<li><a href="#ir_semantics-xls-ir-semantics">XLS: IR semantics</a><ul>
<li><a href="#ir_semantics-data-types">Data types</a><ul>
<li><a href="#ir_semantics-bits">Bits</a></li>
<li><a href="#ir_semantics-array">Array</a></li>
<li><a href="#ir_semantics-tuple">Tuple</a></li>
<li><a href="#ir_semantics-token">Token</a></li>
</ul>
</li>
<li><a href="#ir_semantics-functions-procs-and-blocks">Functions, procs, and blocks</a><ul>
<li><a href="#ir_semantics-function">Function</a></li>
<li><a href="#ir_semantics-proc">Proc</a></li>
<li><a href="#ir_semantics-block">Block</a><ul>
<li><a href="#ir_semantics-port">Port</a></li>
<li><a href="#ir_semantics-register">Register</a></li>
<li><a href="#ir_semantics-instantiation">Instantiation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ir_semantics-operations">Operations</a><ul>
<li><a href="#ir_semantics-unary-bitwise-operations">Unary bitwise operations</a></li>
<li><a href="#ir_semantics-variadic-bitwise-operations">Variadic bitwise operations</a></li>
<li><a href="#ir_semantics-arithmetic-unary-operations">Arithmetic unary operations</a></li>
<li><a href="#ir_semantics-arithmetic-binary-operations">Arithmetic binary operations</a></li>
<li><a href="#ir_semantics-comparison-operations">Comparison operations</a></li>
<li><a href="#ir_semantics-shift-operations">Shift operations</a></li>
<li><a href="#ir_semantics-extension-operations">Extension operations</a><ul>
<li><a href="#ir_semantics-zero_ext">zero_ext</a></li>
<li><a href="#ir_semantics-sign_ext">sign_ext</a></li>
</ul>
</li>
<li><a href="#ir_semantics-channel-operations">Channel operations</a><ul>
<li><a href="#ir_semantics-receive">receive</a></li>
<li><a href="#ir_semantics-send">send</a></li>
</ul>
</li>
<li><a href="#ir_semantics-array-operations">Array operations</a><ul>
<li><a href="#ir_semantics-array_1">array</a></li>
<li><a href="#ir_semantics-array_index">array_index</a></li>
<li><a href="#ir_semantics-array_slice">array_slice</a></li>
<li><a href="#ir_semantics-array_update">array_update</a></li>
</ul>
</li>
<li><a href="#ir_semantics-tuple-operations">Tuple operations</a><ul>
<li><a href="#ir_semantics-tuple_1">tuple</a></li>
<li><a href="#ir_semantics-tuple_index">tuple_index</a></li>
</ul>
</li>
<li><a href="#ir_semantics-bit-vector-operations">Bit-vector operations</a><ul>
<li><a href="#ir_semantics-bit_slice">bit_slice</a></li>
<li><a href="#ir_semantics-bit_slice_update">bit_slice_update</a></li>
<li><a href="#ir_semantics-dynamic_bit_slice">dynamic_bit_slice</a></li>
<li><a href="#ir_semantics-concat">concat</a></li>
<li><a href="#ir_semantics-reverse">reverse</a></li>
<li><a href="#ir_semantics-decode">decode</a></li>
<li><a href="#ir_semantics-encode">encode</a></li>
<li><a href="#ir_semantics-one_hot">one_hot</a></li>
</ul>
</li>
<li><a href="#ir_semantics-control-oriented-operations">Control-oriented operations</a><ul>
<li><a href="#ir_semantics-param">param</a></li>
<li><a href="#ir_semantics-sel">sel</a></li>
<li><a href="#ir_semantics-one_hot_sel">one_hot_sel</a></li>
<li><a href="#ir_semantics-priority_sel">priority_sel</a></li>
<li><a href="#ir_semantics-invoke">invoke</a></li>
<li><a href="#ir_semantics-map">map</a></li>
<li><a href="#ir_semantics-dynamic_counted_for">dynamic_counted_for</a></li>
<li><a href="#ir_semantics-counted_for">counted_for</a></li>
</ul>
</li>
<li><a href="#ir_semantics-sequencing-operations">Sequencing operations</a><ul>
<li><a href="#ir_semantics-after_all">after_all</a></li>
</ul>
</li>
<li><a href="#ir_semantics-other-side-effecting-operations">Other side-effecting operations</a><ul>
<li><a href="#ir_semantics-assert">assert</a></li>
<li><a href="#ir_semantics-cover">cover</a></li>
<li><a href="#ir_semantics-gate">gate</a></li>
</ul>
</li>
<li><a href="#ir_semantics-rtl-level-operations">RTL-level operations</a><ul>
<li><a href="#ir_semantics-input_port">input_port</a></li>
<li><a href="#ir_semantics-output_port">output_port</a></li>
<li><a href="#ir_semantics-register_read">register_read</a></li>
<li><a href="#ir_semantics-register_write">register_write</a></li>
<li><a href="#ir_semantics-instantiation_input">instantiation_input</a></li>
<li><a href="#ir_semantics-instantiation_output">instantiation_output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>The XLS IR is a pure dataflow-oriented IR that has the static-single-assignment
property, but is specialized for generating circuitry. The aim is to create
effective circuit designs through a "lifted" understanding of the high-level
operations and their semantics, instead of trying to reverse all relevant
properties via dependence analysis, which often cannot take advantage of high
level knowledge that the designer holds in their mind at design time.</p>
<p>This document describes the semantics of the XLS intermediate representation
(IR) including data types, operations, and textual representation.</p>
<h2 id="ir_semantics-data-types">Data types</h2>
<h3 id="ir_semantics-bits">Bits</h3>
<p>A vector of bits with a fixed width.</p>
<p><strong>Type syntax:</strong></p>
<p><code>bits[N]</code> where <code>N</code> is the number of bits.</p>
<p><strong>Value syntax:</strong></p>
<ul>
<li>A literal decimal number. Example: <code>42</code>.</li>
<li>A binary number prefixed with <code>0b</code>. Example: <code>0b10101</code></li>
<li>A hexadecimal number: <code>0x</code>. Example: <code>0xdeadbeef</code></li>
</ul>
<p>The representation may optionally include the bit width in which case the type
is prefixed before the literal: <code>bits[N]:$literal</code>. Example: <code>bits[8]:0xab</code>.</p>
<h3 id="ir_semantics-array">Array</h3>
<p>A one-dimensional array of elements of the same type with a fixed number of
elements. An array can contain bits, arrays, or tuples as elements. Empty
(zero-element) arrays are not supported.</p>
<p><strong>Type syntax:</strong></p>
<p><code>$type[N]</code>: an array containing <code>N</code> elements of type <code>$type</code>. Examples:</p>
<ul>
<li>Two-element array of 8-bit bits type: <code>bits[8][2]</code></li>
<li>Three-element array of tuple type: <code>(bits[32], bits[2])[3]</code></li>
</ul>
<p><strong>Value syntax:</strong></p>
<p><code>[$value_1, ... , $value_N]</code> where <code>$value_n</code> is the value of the <code>n</code>-th
element. Examples:</p>
<ul>
<li>Array of bits elements with explicit bit count: <code>[bits[8]:10, bits[8]:30]</code></li>
<li>Three-element array consisting of two-element arrays of bits elements: <code>[[1,
    2], [3, 4], [5, 6]]]</code></li>
</ul>
<h3 id="ir_semantics-tuple">Tuple</h3>
<p>An ordered set of fixed size containing elements with potentially different
types. tuples can contain bits, arrays, or tuples as elements. May be empty.</p>
<p><strong>Type syntax:</strong></p>
<p><code>($type_{0}, ..., $type_{N-1})</code> where <code>N</code> is the number of elements and where
<code>$type_n</code> is the type of the <code>n</code>-th element.</p>
<p><strong>Value syntax:</strong></p>
<p><code>($value_{0}, ..., $value_{N-1})</code> where <code>$value_n</code> is the value of the <code>n</code>-th
element. Examples:</p>
<ul>
<li>Tuple containing two bits elements: <code>(0b100, 0b101)</code></li>
<li>A nested tuple containing various element types: <code>((1, 2), 42, [5, 6])</code></li>
</ul>
<h3 id="ir_semantics-token">Token</h3>
<p>A type used to enforce ordering between channel operations. The token type has
no value and all tokens are identical. A token is purely symbolic / semantic and
has no correlate in hardware.</p>
<p><strong>Type syntax:</strong></p>
<p><code>token</code></p>
<h2 id="ir_semantics-functions-procs-and-blocks">Functions, procs, and blocks</h2>
<p>The XLS IR has three function-level abstractions each which hold a data-flow
graph of XLS IR operations: <em>functions</em>, <em>procs</em>, and <em>blocks</em>. Names of
function, procs and blocks must be unique among their respective abstractions
(functions, procs, and blocks). For example, a block cannot share a name with
another block but can share a name with a function.</p>
<h3 id="ir_semantics-function">Function</h3>
<p>A function is a stateless abstraction with a single-output which is computed
from zero or more input parameters. May invoke other functions.</p>
<h3 id="ir_semantics-proc">Proc</h3>
<p>A Proc is a stateful abstraction with an arbitrarily-typed recurrent state.
Procs can communicate with other procs via channels which (abstractly) are
infinite-depth FIFOs with flow control. Channel communication is handled via
send and receive IR operations. Procs may invoke functions.</p>
<p>TODO(meheff): 2021/11/04 Expand to include more details.</p>
<h3 id="ir_semantics-block">Block</h3>
<p>A Block is an RTL-level abstraction used for code generation. It corresponds to
a single Verilog module. Procs and functions are converted to blocks as part of
the code generation process. Blocks may “invoke” other blocks via instantiation.
A block includes explicit representations of RTL constructs: ports, registers,
and instantiations. The constructs are scoped within the block.</p>
<h4 id="ir_semantics-port">Port</h4>
<p>A port is a representation of an input or output to the block. These correspond
to ports on Verilog modules. Ports can be arbitrarily-typed. In the block, each
port is represented with a <code>input_port</code> or <code>output_port</code> operation.</p>
<h4 id="ir_semantics-register">Register</h4>
<p>A register is a representation of a hardware register (flop). Registers can be
arbitrarily-typed. Each register must have a single <code>register_write</code> and a
single <code>register_read</code> operation for writing and reading the register
respectively.</p>
<p>Each register may optionally specify its reset behavior. The reset can be
specified to occur either synchronously or asynchronously and either on the
<code>reset</code> signal of the associated <code>register_write</code> being active-high or
active-low. If specified the reset value must match the type of the register. If
no reset behavior is specified then the <code>reset</code> argument of <code>register_write</code>
must be unset.</p>
<h4 id="ir_semantics-instantiation">Instantiation</h4>
<p>An instantiation is a block-scoped construct that represents a module
instantiation at the Verilog level. The instantiated object can be another
block, a FIFO (not yet supported), or a externally defined Verilog module (not
yet supported). The instantiation is integrated into the instantiating block
with <code>instantiation_input</code> and <code>instantiation_output</code> operations. There is a
one-to-one mapping between the instantiation input/output and the ports of the
instantiated objects.</p>
<h2 id="ir_semantics-operations">Operations</h2>
<p>Operations share a common syntax and have both positional and keyword arguments
à la Python. Positional arguments are ordered and must appear first in the
argument list. Positional arguments are exclusively the identifiers of the
operands. Keyword arguments are unordered and must appear after the positional
arguments. Keyword arguments can include arbitrary value types.</p>
<div class="highlight"><pre><span></span><code>result = operation(pos_arg_0, ..., pos_arg_N, keyword_0=value0, ..., keyword_M=valueM, ...)
</code></pre></div>
<p><strong>Common keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pos</code></td>
<td><code>SourceLocation</code></td>
<td>no</td>
<td></td>
<td>The source location associated with this operation. The syntax is a triplet of comma-separated integer values: <code>Fileno,Lineno,Colno</code></td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h3 id="ir_semantics-unary-bitwise-operations">Unary bitwise operations</h3>
<p>Performs a bit-wise operation on a single bits-typed operand.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = identity(operand)
result = not(operand)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[N]</code></td>
</tr>
</tbody>
</table>
<p><strong>Operations</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Opcode</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>identity</code></td>
<td><code>Op::kIdentity</code></td>
<td><code>result = operand</code></td>
</tr>
<tr>
<td><code>not</code></td>
<td><code>Op::kNot</code></td>
<td><code>result = ~operand</code></td>
</tr>
</tbody>
</table>
<h3 id="ir_semantics-variadic-bitwise-operations">Variadic bitwise operations</h3>
<p>Performs a bit-wise operation on one-or-more identically-typed bits operands. If
only a single argument is provided the operation is a no-op.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = and(operand_{0}, ..., operand_{N-1})
result = or(operand_{0}, ..., operand_{N-1})
result = xor(operand_{0}, ..., operand_{N-1})
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand_{i}</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[N]</code></td>
</tr>
</tbody>
</table>
<p><strong>Operations</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Opcode</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>and</code></td>
<td><code>Op::kAnd</code></td>
<td><code>result = lhs &amp; rhs &amp; ...</code></td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>Op::kOr</code></td>
<td><code>result = lhs \| rhs \| ...</code></td>
</tr>
<tr>
<td><code>xor</code></td>
<td><code>Op::kXor</code></td>
<td><code>result = lhs ^ rhs ^ ...</code></td>
</tr>
</tbody>
</table>
<h3 id="ir_semantics-arithmetic-unary-operations">Arithmetic unary operations</h3>
<p>Performs an arithmetic operation on a single bits-typed operand.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = neg(operand)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[N]</code></td>
</tr>
</tbody>
</table>
<p><strong>Operations</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Opcode</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>neg</code></td>
<td><code>Op::kNeg</code></td>
<td><code>result = -operand</code></td>
</tr>
</tbody>
</table>
<h3 id="ir_semantics-arithmetic-binary-operations">Arithmetic binary operations</h3>
<p>Performs an arithmetic operation on a pair of bits operands. Unsigned operations
are prefixed with a 'u', and signed operations are prefixed with a 's'.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = add(lhs, rhs)
result = smul(lhs, rhs)
result = umul(lhs, rhs)
result = sdiv(lhs, rhs)
result = smod(lhs, rhs)
result = sub(lhs, rhs)
result = udiv(lhs, rhs)
result = umod(lhs, rhs)
result = smulp(lhs, rhs)
result = umulp(lhs, rhs)
</code></pre></div>
<p><strong>Types</strong></p>
<p>Currently signed and unsigned multiply, as wells as their partial product
variants, support arbitrary width operands and result. For all other arithmetic
operations the operands and the result are the same width. The expectation is
that all arithmetic operations will eventually support arbitrary widths.</p>
<p><strong>Operations</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Operation</th>
<th>Opcode</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td><code>Op::kAdd</code></td>
<td><code>result = lhs + rhs</code></td>
</tr>
<tr>
<td><code>sdiv</code></td>
<td><code>Op::kSDiv</code></td>
<td><code>result = $signed(lhs) / $signed(rhs)</code> * **</td>
</tr>
<tr>
<td><code>smod</code></td>
<td><code>Op::kSMod</code></td>
<td><code>result = $signed(lhs) % $signed(rhs)</code> * ***</td>
</tr>
<tr>
<td><code>smul</code></td>
<td><code>Op::kSMul</code></td>
<td><code>result = $signed(lhs) * $signed(rhs)</code></td>
</tr>
<tr>
<td><code>smulp</code></td>
<td><code>Op::kSMulp</code></td>
<td><code>result[0] + result[1] = $signed(lhs) * $signed(rhs)</code> ****</td>
</tr>
<tr>
<td><code>sub</code></td>
<td><code>Op::kSub</code></td>
<td><code>result = lhs - rhs</code></td>
</tr>
<tr>
<td><code>udiv</code></td>
<td><code>Op::kUDiv</code></td>
<td><code>result = lhs / rhs</code> * **</td>
</tr>
<tr>
<td><code>umod</code></td>
<td><code>Op::kUMod</code></td>
<td><code>result = lhs % rhs</code> *</td>
</tr>
<tr>
<td><code>umul</code></td>
<td><code>Op::kUMul</code></td>
<td><code>result = lhs * rhs</code></td>
</tr>
<tr>
<td><code>umulp</code></td>
<td><code>Op::kUMulp</code></td>
<td><code>result[0] + result[1] = lhs * rhs</code> ****</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>* Synthesizing division or modulus can lead to failing synthesis and/or
problems with timing closure. It is usually best not to rely on this Verilog
operator in practice, but instead explicitly instantiate a divider of choice.</p>
<p>** Division rounds toward zero. For unsigned division this is the same as
truncation. If the divisor is zero, unsigned division produces a maximal
positive value. For signed division, if the divisor is zero the result is the
maximal positive value if the dividend is non-negative or the maximal negative
value if the dividend is negative.</p>
<p>*** The sign of the result of modulus matches the sign of the left operand. If
the right operand is zero the result is zero.</p>
<p>**** The partial product multiply variants return a two-element tuple with
both elements having the same type. The outputs are not fully constrained; the
operations are free to return any values that sum to the product <code>lhs * rhs</code>.</p>
<h3 id="ir_semantics-comparison-operations">Comparison operations</h3>
<p>Performs a comparison on a pair of identically-typed bits operands. Unsigned
operations are prefixed with a 'u', and signed operations are prefixed with a
's'. Produces a result of bits[1] type.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = eq(lhs, rhs)
result = ne(lhs, rhs)
result = sge(lhs, rhs)
result = sgt(lhs, rhs)
result = sle(lhs, rhs)
result = slt(lhs, rhs)
result = uge(lhs, rhs)
result = ugt(lhs, rhs)
result = ule(lhs, rhs)
result = ult(lhs, rhs)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lhs</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>rhs</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[1]</code></td>
</tr>
</tbody>
</table>
<p><strong>Operations</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Opcode</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eq</code></td>
<td><code>Op::kEq</code></td>
<td><code>result = lhs == rhs</code></td>
</tr>
<tr>
<td><code>ne</code></td>
<td><code>Op::kNe</code></td>
<td><code>result = lhs != rhs</code></td>
</tr>
<tr>
<td><code>sge</code></td>
<td><code>Op::kSGe</code></td>
<td><code>result = lhs &gt;= rhs</code></td>
</tr>
<tr>
<td><code>sgt</code></td>
<td><code>Op::kSGt</code></td>
<td><code>result = lhs &gt; rhs</code></td>
</tr>
<tr>
<td><code>sle</code></td>
<td><code>Op::kSLe</code></td>
<td><code>result = lhs &lt;= rhs</code></td>
</tr>
<tr>
<td><code>slt</code></td>
<td><code>Op::kSLt</code></td>
<td><code>result = lhs &lt; rhs</code></td>
</tr>
<tr>
<td><code>uge</code></td>
<td><code>Op::kUGe</code></td>
<td><code>result = lhs &gt;= rhs</code></td>
</tr>
<tr>
<td><code>ugt</code></td>
<td><code>Op::kUGt</code></td>
<td><code>result = lhs &gt; rhs</code></td>
</tr>
<tr>
<td><code>ule</code></td>
<td><code>Op::kULe</code></td>
<td><code>result = lhs &lt;= rhs</code></td>
</tr>
<tr>
<td><code>ult</code></td>
<td><code>Op::kULt</code></td>
<td><code>result = lhs &lt; rhs</code></td>
</tr>
</tbody>
</table>
<h3 id="ir_semantics-shift-operations">Shift operations</h3>
<p>Performs an shift operation on an input operand where the shift amount is
specified by a second operand.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = shll(operand, amount)
result = shra(operand, amount)
result = shrl(operand, amount)
</code></pre></div>
<p><strong>Types</strong></p>
<p>The shifted operand and the result of the shift are the same width. Widths of
the shift amount may be arbitrary.</p>
<p><strong>Operations</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Opcode</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shll</code></td>
<td><code>Op::kShll</code></td>
<td><code>result = lhs &lt;&lt; rhs</code> *</td>
</tr>
<tr>
<td><code>shra</code></td>
<td><code>Op::kShra</code></td>
<td><code>result = lhs &gt;&gt;&gt; rhs</code> (arithmetic shift right) **</td>
</tr>
<tr>
<td><code>shrl</code></td>
<td><code>Op::kShrl</code></td>
<td><code>result = lhs &gt;&gt; rhs</code> *</td>
</tr>
</tbody>
</table>
<p>* Logically shifting greater than or equal to the number of bits in the <code>lhs</code>
produces a result of zero.</p>
<p>** Arithmetic right shifting greater than or equal to the number of bits in the
<code>lhs</code> produces a result equal to all of the bits set to the sign of the <code>lhs</code>.</p>
<h3 id="ir_semantics-extension-operations">Extension operations</h3>
<p>Extends a bit value to a new (larger) target bit-length.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = zero_ext(x, new_bit_count=42)
result = sign_ext(x, new_bit_count=42)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arg</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>new_bit_count</code></td>
<td><code>int64_t</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[new_bit_count]</code></td>
</tr>
</tbody>
</table>
<p>Note: <code>new_bit_count</code> should be <code>&gt;= N</code> or an error may be raised.</p>
<h4 id="ir_semantics-zero_ext"><code>zero_ext</code></h4>
<p>Zero-extends a value: turns its bit-length into the new target bit-length by
filling zeroes in the most significant bits.</p>
<h4 id="ir_semantics-sign_ext"><code>sign_ext</code></h4>
<p>Sign-extends a value: turns its bit-length into the new target bit-length by
filling in the most significant bits (MSbs) with the following policy:</p>
<ul>
<li>ones in the MSbs if the MSb of the original value was set, or</li>
<li>zeros in the MSbs if the MSb of the original value was unset.</li>
</ul>
<h3 id="ir_semantics-channel-operations">Channel operations</h3>
<p>These operations send or receive data over channels. Channels are monomorphic,
and each channel supports a fixed set of data types which are sent or received
in a single transaction.</p>
<h4 id="ir_semantics-receive"><strong><code>receive</code></strong></h4>
<p>Receives a data value from a specified channel. The type of the data value is
determined by the channel. An optional predicate value conditionally enables the
receive operation. An optional <code>blocking</code> attribute determines whether the
receive operation is blocking. A blocking receive waits (or blocks) until valid
data is present at the channel. Compared to a blocking receive, a non-blocking
receive has an additional entry in its return tuple of type <code>bits[1]</code> denoting
whether the data read is valid.</p>
<div class="highlight"><pre><span></span><code>result = receive(tkn, predicate=&lt;pred&gt;, blocking=&lt;bool&gt;, channel_id=&lt;ch&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tkn</code></td>
<td><code>token</code></td>
</tr>
<tr>
<td><code>pred</code></td>
<td><code>bits[1]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>(token, T)</code> if <code>blocking</code> == <code>true</code> else <code>(token, T, bits[1])</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>predicate</code></td>
<td><code>bits[1]</code></td>
<td>no</td>
<td></td>
<td>A value is received iff <code>predicate</code> is true</td>
</tr>
<tr>
<td><code>blocking</code></td>
<td><code>bool</code></td>
<td>no</td>
<td><code>true</code></td>
<td>Whether the receive is blocking</td>
</tr>
<tr>
<td><code>channel_id</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>The ID of the channel to receive data from</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>If the predicate is false the data values in the result are zero-filled.</p>
<h4 id="ir_semantics-send"><strong><code>send</code></strong></h4>
<p>Sends data to a specified channel. The type of the data values is determined by
the channel. An optional predicate value conditionally enables the send
operation.</p>
<div class="highlight"><pre><span></span><code>result = send(tkn, data, predicate=&lt;pred&gt;, channel_id=&lt;ch&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tkn</code></td>
<td><code>token</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>pred</code></td>
<td><code>bits[1]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>token</code></td>
</tr>
</tbody>
</table>
<p>The type of <code>data</code> must match the type supported by the channel.</p>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>predicate</code></td>
<td><code>bits[1]</code></td>
<td>no</td>
<td></td>
<td>A value is sent iff <code>predicate</code> is true</td>
</tr>
<tr>
<td><code>channel_id</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>The ID of the channel to send data to.</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h3 id="ir_semantics-array-operations">Array operations</h3>
<h4 id="ir_semantics-array_1"><strong><code>array</code></strong></h4>
<p>Constructs an array of its operands.</p>
<div class="highlight"><pre><span></span><code>result = array(operand_{0}, ..., operand_{N-1})
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand_{i}</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T[N]</code></td>
</tr>
</tbody>
</table>
<p>Array can take an arbitrary number of operands including zero (which produces an
empty array). The n-th operand becomes the n-th element of the array.</p>
<h4 id="ir_semantics-array_index"><strong><code>array_index</code></strong></h4>
<p>Returns a single element from an array.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = array_index(array, indices=[idx_{0}, ... , idx_{N-1}])
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array</code></td>
<td>Array of at least <code>N</code> dimensions</td>
</tr>
<tr>
<td><code>idx_{i}</code></td>
<td>Arbitrary bits type</td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p>Returns the element of <code>array</code> indexed by the indices <code>idx_{0} ... idx_{N-1}</code>.
The array must have at least as many dimensions as number of index elements <code>N</code>.
Each element <code>idx_{i}</code> indexes a dimension of <code>array</code>. The first element
<code>idx_{0}</code> indexes the outer most dimension, the second element <code>idx_{1}</code> indexes
the second outer most dimension, etc. The result type <code>T</code> is the type of <code>array</code>
with the <code>N</code> outer most dimensions removed.</p>
<p>Any out-of-bounds indices <code>idx_{i}</code> are clamped to the maximum in bounds index
for the respective dimension.</p>
<p>The table below shows examples of the result type <code>T</code> and the result expression
assuming input array operand <code>A</code>.</p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Indices</th>
<th>Array type</th>
<th>result type <code>T</code></th>
<th>Result expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{1, 2}</code></td>
<td><code>bits[3][4][5]</code></td>
<td><code>bits[3]</code></td>
<td><code>A[1][2]</code></td>
</tr>
<tr>
<td><code>{10, 2}</code></td>
<td><code>bits[3][4][5]</code></td>
<td><code>bits[3]</code></td>
<td><code>A[4][2]</code> (first index is out-of-bounds and clamped at the maximum index)</td>
</tr>
<tr>
<td><code>{1}</code></td>
<td><code>bits[3][4][5]</code></td>
<td><code>bits[3][4]</code></td>
<td><code>A[1]</code></td>
</tr>
<tr>
<td><code>{}</code></td>
<td><code>bits[3][4][5]</code></td>
<td><code>bits[3][4][5]</code></td>
<td><code>A</code></td>
</tr>
<tr>
<td><code>{}</code></td>
<td><code>bits[32]</code></td>
<td><code>bits[32]</code></td>
<td><code>A</code></td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h4 id="ir_semantics-array_slice"><strong><code>array_slice</code></strong></h4>
<p>Returns a slice of an array.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = array_slice(array, start, width=&lt;width&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array</code></td>
<td>Array</td>
</tr>
<tr>
<td><code>start</code></td>
<td>Arbitrary bits type</td>
</tr>
<tr>
<td><code>result</code></td>
<td>Array with same <code>element_type</code> as <code>array</code> and size of <code>width</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>width</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>Width to make the resulting array.</td>
</tr>
</tbody>
</table>
<p>Returns a copy of the segment of the input array consisting of the <code>&lt;width&gt;</code>
consecutive elements starting from <code>start</code>. If any element in that segment is
out-of-bounds of the original array the value at the corresponding index is the
final element in the array. This is consistent behavior with respect to the
index operation.</p>
<h4 id="ir_semantics-array_update"><strong><code>array_update</code></strong></h4>
<p>Returns a modified copy of an array.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = array_update(array, value, indices=[idx_{0}, ... , idx_{N-1}])
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array</code></td>
<td>Array of at least <code>N</code> dimensions</td>
</tr>
<tr>
<td><code>value</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>idx_{i}</code></td>
<td>Arbitrary bits type</td>
</tr>
<tr>
<td><code>result</code></td>
<td>Same type as <code>array</code></td>
</tr>
</tbody>
</table>
<p>Returns a copy of the input array with the element at the given indices replaced
with the given value. If any index is out of bounds, the result is identical to
the input <code>array</code>. The indexing semantics is identical to <code>array_index</code> with the
exception of out-of-bounds behavior.</p>
<h3 id="ir_semantics-tuple-operations">Tuple operations</h3>
<h4 id="ir_semantics-tuple_1"><strong><code>tuple</code></strong></h4>
<p>Constructs a tuple of its operands.</p>
<div class="highlight"><pre><span></span><code>result = tuple(operand_{0}, ..., operand_{N-1})
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand_{i}</code></td>
<td><code>T_{i}</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>(T_{0}, ... , T_{N-1})</code></td>
</tr>
</tbody>
</table>
<p>Tuple can take and arbitrary number of operands including zero (which produces
an empty tuple).</p>
<h4 id="ir_semantics-tuple_index"><strong><code>tuple_index</code></strong></h4>
<p>Returns a single element from a tuple-typed operand.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = tuple_index(operand, index=&lt;index&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>(T_{0}, ... , T_{N-1})</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T_{&lt;index&gt;}</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>index</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>Index of tuple element to produce</td>
</tr>
</tbody>
</table>
<h3 id="ir_semantics-bit-vector-operations">Bit-vector operations</h3>
<h4 id="ir_semantics-bit_slice"><strong><code>bit_slice</code></strong></h4>
<p>Slices a contiguous range of bits from a bits-typed operand.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = bit_slice(operand, start=&lt;start&gt;, width=&lt;width&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[&lt;width&gt;]</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>The starting bit of the slice. <code>start</code> is is zero-indexed where zero is the least-significant bit of the operand.</td>
</tr>
<tr>
<td><code>width</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>The width of the slice.</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>The bit-width of <code>operand</code> must be greater than or equal to <code>&lt;start&gt;</code> plus
<code>&lt;width&gt;</code>.</p>
<h4 id="ir_semantics-bit_slice_update"><strong><code>bit_slice_update</code></strong></h4>
<p>Replaces a contiguous range of bits in a bits-typed operand at a variable start
index with a given value.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = bit_slice_update(operand, start, update_value)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>start</code></td>
<td><code>bits[I]</code></td>
</tr>
<tr>
<td><code>update_value</code></td>
<td><code>bits[M]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[N]</code></td>
</tr>
</tbody>
</table>
<p>Evaluates to <code>operand</code> with the contiguous <code>M</code> bits starting at index <code>start</code>
replaced with <code>update_value</code>. Out-of-bound bits (which occur if <code>start + M &gt; N</code>)
are ignored. Examples:</p>
<table>
<thead>
<tr>
<th><code>operand</code></th>
<th><code>start</code></th>
<th><code>update_value</code></th>
<th><code>result</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bits[16]:0xabcd</code></td>
<td><code>0</code></td>
<td><code>bits[8]:0xff</code></td>
<td><code>bits[16]:0xabff</code></td>
</tr>
<tr>
<td><code>bits[16]:0xabcd</code></td>
<td><code>4</code></td>
<td><code>bits[8]:0xff</code></td>
<td><code>bits[16]:0xaffd</code></td>
</tr>
<tr>
<td><code>bits[16]:0xabcd</code></td>
<td><code>12</code></td>
<td><code>bits[8]:0xff</code></td>
<td><code>bits[16]:0xfbcd</code></td>
</tr>
<tr>
<td><code>bits[16]:0xabcd</code></td>
<td><code>16</code></td>
<td><code>bits[8]:0xff</code></td>
<td><code>bits[16]:0xabcd</code></td>
</tr>
</tbody>
</table>
<h4 id="ir_semantics-dynamic_bit_slice"><strong><code>dynamic_bit_slice</code></strong></h4>
<p>Slices a contiguous range of bits from a bits-typed operand, with variable
starting index but fixed width. Out-of-bounds slicing is supported by treating
all out-of-bounds bits as having value 0.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = dynamic_bit_slice(operand, start, width=&lt;width&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>start</code></td>
<td><code>bits[M]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[&lt;width&gt;]</code></td>
</tr>
</tbody>
</table>
<p><code>start</code> can be of arbitrary bit width. It will be interpreted as an unsigned
integer.</p>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>width</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>The width of the slice.</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h4 id="ir_semantics-concat"><strong><code>concat</code></strong></h4>
<p>Concatenates and arbitrary number of bits-typed operands.</p>
<div class="highlight"><pre><span></span><code>result = concat(operand{0}, ..., operand{n-1})
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand_{i}</code></td>
<td><code>bits[N_{i}]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[Sum(N_{i})]</code></td>
</tr>
</tbody>
</table>
<p>This is equivalent to the verilog concat operator: <code>result = {arg0, ..., argN}</code></p>
<h4 id="ir_semantics-reverse"><strong><code>reverse</code></strong></h4>
<p>Reverses the order of bits of its operand.</p>
<div class="highlight"><pre><span></span><code>result = reverse(operand)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[N]</code></td>
</tr>
</tbody>
</table>
<h4 id="ir_semantics-decode"><strong><code>decode</code></strong></h4>
<p>Implements a binary decoder.</p>
<div class="highlight"><pre><span></span><code>result = decode(operand, width=&lt;width&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[M]</code></td>
</tr>
</tbody>
</table>
<p>The result width <code>M</code> must be less than or equal to 2**<code>N</code> where <code>N</code> is the
operand width.</p>
<p><strong>Keyword arguments</strong></p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>width</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>Width of the result</td>
</tr>
</tbody>
</table>
<p><code>decode</code> converts the binary-encoded operand value into a one-hot result. For an
operand value of <code>n</code> interpreted as an unsigned number the <code>n</code>-th result bit and
only the <code>n</code>-th result bit is set. The width of the <code>decode</code> operation may be
less than the maximum value expressible by the input (2**<code>N</code> - 1). If the
encoded operand value is larger than the number of bits of the result the result
is zero.</p>
<h4 id="ir_semantics-encode"><strong><code>encode</code></strong></h4>
<p>Implements a binary encoder.</p>
<div class="highlight"><pre><span></span><code>result = encode(operand, width=&lt;width&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[M]</code></td>
</tr>
</tbody>
</table>
<p>The result width <code>M</code> must be equal to <span class="arithmatex">\(<span class="arithmatex">\(\lceil \log_{2} N \rceil\)</span>\)</span>.</p>
<p><code>encode</code> converts the one-hot operand value into a binary-encoded value of the
"hot" bit of the input. If the <code>n</code>-th bit and only the <code>n</code>-th bit of the operand
is set the result is equal the value <code>n</code> as an unsigned number.</p>
<p>If multiple bits of the input are set the result is equal to the logical or of
the results produced by the input bits individually. For example, if bit 3 and
bit 5 of an <code>encode</code> input are set the result is equal to 3 | 5 = 7.</p>
<p>If no bits of the input are set the result is zero.</p>
<h4 id="ir_semantics-one_hot"><strong><code>one_hot</code></strong></h4>
<p>Produces a bits value with exactly one bit set. The index of the set bit depends
upon the input value.</p>
<p>This operation can be thought of like a command: "canonicalize/normalize this
input value to be one-hot", where <code>lsb_prio</code> indicates which side of the
bitvector wins in the case that there are multiple input bits set. Contrast this
with the <a href="#ir_semantics-decode"><code>decode</code></a> operation which instead converts a binary-encoded
operand value into a one-hot value.</p>
<p>(Note: once this operation has been applied to a value, the optimizer knows that
the output has the one-hot property [i.e. exactly one bit is set], which helps
the optimizer know that one-hot-select operations that use the output value as a
selector are selecting between distinct values.)</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = one_hot(input, lsb_prio=true)
result = one_hot(input, lsb_prio=false)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>input</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>bits[N+1]</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lsb_prio</code></td>
<td><code>bool</code></td>
<td>yes</td>
<td></td>
<td>Whether the least significant bit (LSb) has priority.</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>For <code>lsb_prio=true</code>: result bit <code>i</code> for <code>0 &lt;= i &lt; N</code> is set in <code>result</code> iff bit
<code>i</code> is set in the input and all lower bits <code>j</code> for <code>j &lt; i</code> are not set in the
input.</p>
<p>For <code>lsb_prio=false</code>: result bit <code>i</code> for <code>N-1 &gt;= i &gt;= 0</code> is set in <code>result</code> iff
bit <code>i</code> is set in the input and all higher (more significant) bits <code>j</code> for <code>j &gt;
i</code> are not set in the input.</p>
<p>For <strong>both</strong> <code>lsb_prio=true</code> and <code>lsb_prio=false</code>, result bit <code>N</code> (the most
significant bit in the output) is only set if no bits in the input are set.</p>
<p>Examples:</p>
<ul>
<li><code>one_hot(0b0011, lsb_prio=true)</code> =&gt; <code>0b00001</code> -- note that an extra MSb has
    been appended to the output to potentially represent the "all zeros" case.</li>
<li><code>one_hot(0b0111, lsb_prio=false)</code> =&gt; <code>0b00100</code>.</li>
<li><code>one_hot(0b00, lsb_prio=false)</code> =&gt; <code>0b100</code>.</li>
<li><code>one_hot(0b00, lsb_prio=true)</code> =&gt; <code>0b100</code> -- note the output for <code>one_hot</code>
    is the same for the all-zeros case regardless of whether <code>lsb_prio</code> is true
    or false.</li>
</ul>
<p>This operation is useful for constructing match or switch operation semantics
where a condition is matched against an ordered set of cases and the first match
is chosen. It is also useful for one-hot canonicalizing, e.g. as a prelude to
counting leading/trailing zeros.</p>
<h3 id="ir_semantics-control-oriented-operations">Control-oriented operations</h3>
<p>For context note that, in XLS, operations are evaluated eagerly in a very
general sense: all "branches" of computation may be evaluated in full before the
result is selected via an operation such as <code>one_hot_sel</code> or <code>sel</code>. This model
is amenable to pipeline-like hardware execution, where operations tend to be
fixed in some spatial area and operations execute a single function, while
interconnect is used for reconfiguration purposes.</p>
<p>Towards this eager-evaluation-capable model, operations used within a function
are generally not Turing-complete: operations such as <code>counted_for</code> require a
finite bound so that they could be implemented using a finite amount of pipeline
area. Operations such as <code>dynamic_counted_for</code> are an exception, where that
operation will only be possible to use in a time-multiplexed code generation
mode, such as the XLS sequential emitter, where arbitrary iteration to some
dynamic bound is likely to be possible.</p>
<h4 id="ir_semantics-param"><strong><code>param</code></strong></h4>
<p>A parameter to the current IR function, which can be used as an operand for
operations within the function.</p>
<p><strong>Syntax</strong></p>
<p>Parameters have a special syntactic form distinct from other nodes, where they
are listed directly in the function signature with their type.</p>
<div class="highlight"><pre><span></span><code>fn f(x: bits[32]) -&gt; bits[32] {
  ret identity.2 = identity(x, id=2)
}
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td><code>str</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td><code>type</code></td>
</tr>
</tbody>
</table>
<h4 id="ir_semantics-sel"><strong><code>sel</code></strong></h4>
<p>Selects between operands based on a selector value.</p>
<p>This behaves as if the <code>selector</code> indexes into the values given in <code>cases</code>,
providing <code>default</code> if it is indexing beyond the given <code>cases</code>.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = sel(selector, cases=[case_{0}, ... , case_{N-1}], default=&lt;default&gt;)
</code></pre></div>
<p>A default value must be provided <strong>iff</strong> the <code>selector</code> is not the correct width
for the <code>cases</code> array. That is, if the number of cases is less than
<span class="arithmatex">\(2^{bitwidth(selector)}\)</span> then a default value must be specified (because it must
be well defined what happens when the selector takes on values outside the case
range). If the selector is exactly the correct bitwidth a default value must not
be provided.</p>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>selector</code></td>
<td><code>bits[M]</code></td>
</tr>
<tr>
<td><code>case_{i}</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>default</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h4 id="ir_semantics-one_hot_sel"><strong><code>one_hot_sel</code></strong></h4>
<p>Selects between operands based on a one-hot selector, <code>OR</code>-ing all selected
cases if more than one case is selected.</p>
<p>See <code>one_hot</code> for an example of the one-hot selector invariant. Note that when
the selector is not one-hot, this operation is still well defined.</p>
<p>Note that when <code>one_hot</code> operations are used to precondition the <code>selector</code>
operand to <code>one_hot_sel</code>, the XLS optimizer will try to determine when they are
unnecessary and subsequently eliminate them.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = one_hot_sel(selector, cases=[case_{0}, ... , case_{N-1}])
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>selector</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>case_{i}</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p>The result is the logical OR of all cases <code>case_{i}</code> for which the corresponding
bit <code>i</code> is set in the selector. When selector is one-hot this performs a select
operation.</p>
<h4 id="ir_semantics-priority_sel"><strong><code>priority_sel</code></strong></h4>
<p>Selects between operands based on a selector, choosing the highest-priority case
if more than one case is selected. Each bit in the selector corresponds to a
case, with the least significant bit corresponding to the first case and having
the highest priority. If there are no bits in the selector set, no case is
selected and the default value of 0 is chosen.</p>
<p>See <code>one_hot</code> for an example of the one-hot selector invariant. Note that when
the selector is not one-hot, this operation is still well defined.</p>
<p>Note that when <code>one_hot</code> operations are used to precondition the <code>selector</code>
operand to <code>priority_sel</code>, the XLS optimizer will try to determine when they are
unnecessary and subsequently eliminate them.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = priority_sel(selector, cases=[case_{0}, ... , case_{N-1}])
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>selector</code></td>
<td><code>bits[N]</code></td>
</tr>
<tr>
<td><code>case_{i}</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p>The result is the first case <code>case_{i}</code> for which the corresponding bit <code>i</code> is
set in the selector. If the selector is known to be one-hot, then the
<code>priority_sel()</code> operation is equivalent to a <code>one_hot_sel()</code>.</p>
<h4 id="ir_semantics-invoke"><strong><code>invoke</code></strong></h4>
<p>Invokes a function. The return value for the invoked function is the result
value.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = invoke(operand_{0}, ... , operand_{N-1}, to_apply=&lt;to_apply&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>init</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>to_apply</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the function to use as the loop body</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h4 id="ir_semantics-map"><strong><code>map</code></strong></h4>
<p>Applies a function to the elements of an array and returns the result as an
array.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = map(operand, to_apply=&lt;to_apply&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand</code></td>
<td><code>array[T]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>array[U]</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>to_apply</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the function to apply to each element of the operand</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h4 id="ir_semantics-dynamic_counted_for"><strong><code>dynamic_counted_for</code></strong></h4>
<p>Invokes a dynamic-trip count loop.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = counted_for(init, trip_count, stride, body=&lt;body&gt;, invariant_args=&lt;inv_args&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>init</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>trip_count</code></td>
<td><code>bits[N], treated as unsigned</code></td>
</tr>
<tr>
<td><code>stride</code></td>
<td><code>bits[M], treated as signed</code>,</td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>invariant_args</code></td>
<td>array of</td>
<td>yes</td>
<td></td>
<td>Names of the invariant operands as the loop body</td>
</tr>
<tr>
<td><code>body</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the function to use as the loop body</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p><code>dynamic_counted_for</code> invokes the function <code>body</code> <code>trip_count</code> times, passing
loop-carried data that starts with value <code>init</code>. The induction variable is
incremented by <code>stride</code> after each iteration.</p>
<ul>
<li>The first argument passed to <code>body</code> is the induction variable -- presently,
    the induction variable always starts at zero and increments by <code>stride</code>
    after every trip.</li>
<li>The second argument passed to <code>body</code> is the loop-carry data. The return type
    of <code>body</code> must be the same as the type of the <code>init</code> loop carry data. The
    value returned from the last trip is the result of the <code>counted_for</code>
    expression.</li>
<li>All subsequent arguments passed to <code>body</code> are passed from <code>invariant_args</code>;
    e.g. if there are two members in <code>invariant_args</code> those values are passed as
    the third and fourth arguments.</li>
</ul>
<p>Therefore <code>body</code> should have a signature that matches the following:</p>
<div class="highlight"><pre><span></span><code>body(i, loop_carry_data, [invariant_arg0, invariant_arg1, ...])
</code></pre></div>
<p>Note that we currently inspect the <code>body</code> function to see what type of induction
variable (<code>i</code> above) it accepts in order to pass an <code>i</code> value of that type.
<code>trip_count</code> must have fewer bits than <code>i</code> and <code>stride</code> should have fewer than
or equal number of bits to <code>i</code>.</p>
<p>Code generation support for <code>dynamic_counted_for</code> is limited because the
pipeline generator cannot handle an unknown trip count.</p>
<h4 id="ir_semantics-counted_for"><strong><code>counted_for</code></strong></h4>
<p>Invokes a fixed-trip count loop.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = counted_for(init, trip_count=&lt;trip_count&gt;, stride=&lt;stride&gt;, body=&lt;body&gt;, invariant_args=&lt;inv_args&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>init</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>trip_count</code></td>
<td><code>int64_t</code></td>
<td>yes</td>
<td></td>
<td>Trip count of the loop (number of times that the loop body will be executed)</td>
</tr>
<tr>
<td><code>stride</code></td>
<td><code>int64_t</code></td>
<td>no</td>
<td>1</td>
<td>Stride of the induction variable</td>
</tr>
<tr>
<td><code>invariant_args</code></td>
<td>array of</td>
<td>yes</td>
<td></td>
<td>Names of the invariant operands as the loop body</td>
</tr>
<tr>
<td><code>body</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the function to use as the loop body</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p><code>counted_for</code> invokes the function <code>body</code> <code>trip_count</code> times, passing
loop-carried data that starts with value <code>init</code>.</p>
<ul>
<li>The first argument passed to <code>body</code> is the induction variable -- presently,
    the induction variable always starts at zero and increments by <code>stride</code>
    after every trip.</li>
<li>The second argument passed to <code>body</code> is the loop-carry data. The return type
    of <code>body</code> must be the same as the type of the <code>init</code> loop carry data. The
    value returned from the last trip is the result of the <code>counted_for</code>
    expression.</li>
<li>All subsequent arguments passed to <code>body</code> are passed from <code>invariant_args</code>;
    e.g. if there are two members in <code>invariant_args</code> those values are passed as
    the third and fourth arguments.</li>
</ul>
<p>Therefore <code>body</code> should have a signature that matches the following:</p>
<div class="highlight"><pre><span></span><code>body(i, loop_carry_data[, invariant_arg0, invariant_arg1, ...])
</code></pre></div>
<p>Note that we currently inspect the <code>body</code> function to see what type of induction
variable (<code>i</code> above) it accepts in order to pass an <code>i</code> value of that type.</p>
<h3 id="ir_semantics-sequencing-operations">Sequencing operations</h3>
<p>Some operations in XLS IR are sensitive to sequence order, similar to
<a href="#ir_semantics-channel-operations">channel operations</a>, but are not themselves
channel-related. Tokens are used to determine the possible sequencing of these
effects, and <code>after_all</code> can be used to join together tokens as a sequencing
merge point for concurrent threads of execution described by different tokens.</p>
<h4 id="ir_semantics-after_all"><strong><code>after_all</code></strong></h4>
<p>Used to construct partial orderings among channel operations.</p>
<div class="highlight"><pre><span></span><code>result = after_all(operand_{0}, ..., operand_{N-1})
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operand_{i}</code></td>
<td><code>token</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>token</code></td>
</tr>
</tbody>
</table>
<p><code>after_all</code> can consume an arbitrary number of token operands including zero.</p>
<h3 id="ir_semantics-other-side-effecting-operations">Other side-effecting operations</h3>
<p>Aside from channels operations such as <code>send</code> and <code>receive</code> several other
operations have side-effects. Care must be taken when adding, removing, or
transforming these operations, e.g., in the optimizer.</p>
<h4 id="ir_semantics-assert"><strong><code>assert</code></strong></h4>
<p>Raises an error at software run-time (DSLX/IR interpretation, JIT execution, RTL
simulation) if the given condition evaluates to false. The operation takes a
literal string attribute which is included in the error message. This is a
software-only operation and has no representation in the generated hardware.
Tokens are used to connect the operation to the graph and order with respect to
other side-effecting operations.</p>
<div class="highlight"><pre><span></span><code>result = assert(tkn, condition, message=&lt;string&gt;)
result = assert(tkn, condition, message=&lt;string&gt;, label=&lt;string&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tkn</code></td>
<td><code>token</code></td>
</tr>
<tr>
<td><code>condition</code></td>
<td><code>bits[1]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>token</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Message to include in raised error</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>optional string</code></td>
<td>yes</td>
<td></td>
<td>Label to associate with the assert statement in the generated (System)Verilog</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h4 id="ir_semantics-cover"><strong><code>cover</code></strong></h4>
<p>Records the number of times the given condition evaluates to true. Just like
<code>assert</code>, this is a software-only construct and is not emitted in a final
hardware design.</p>
<div class="highlight"><pre><span></span><code>result = cover(condition, label=&lt;string&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>condition</code></td>
<td><code>bits[1]</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>()</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>label</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name associated with the counter.</td>
</tr>
</tbody>
</table>
<h4 id="ir_semantics-gate"><strong><code>gate</code></strong></h4>
<p>Gates an arbitrarily-typed value based on a condition.</p>
<p>The result of the operation is the data operand if the condition is true,
otherwise the result is a zero value of the type of the data operand (i.e., the
value is gated off). A helpful mnemonic is to think of this as analogous to an
<code>AND</code> gate: if the condition is <code>true</code>, the value passes through, otherwise it's
zeroed.</p>
<p>This operation can reduce switching and may be used in power optimizations. This
is intended for use in operand gating for power reduction, and the compiler may
ultimately use it to perform register-level load-enable gating.</p>
<p>The operation is considered side-effecting to prevent removal of the operation
when the gated result (condition is false) is not observable. The 'side-effect'
of this operation is the effect it can have on power consumption.</p>
<p>Despite being 'side-effecting' this operation is special cased to still be
eligible for total removal by various passes. This will only be done in cases
where the gate is redundant, for example the condition is known to be false or
the data is known to be zero.</p>
<div class="highlight"><pre><span></span><code>result = gate(condition, data)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>condition</code></td>
<td><code>bits[1]</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h3 id="ir_semantics-rtl-level-operations">RTL-level operations</h3>
<p>These IR operations correspond to RTL-level constructs in the emitted Verilog.
These operations are added and used in the code generation process and may only
appear in blocks (not procs or functions).</p>
<h4 id="ir_semantics-input_port"><strong><code>input_port</code></strong></h4>
<p>Corresponds to an input port on a Verilog module.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = input_port()
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p>An input_port operation can be an arbitrary type.</p>
<h4 id="ir_semantics-output_port"><strong><code>output_port</code></strong></h4>
<p>Corresponds to an output port on a Verilog module. The value sent to the output
port is the data operand.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = output_port(data)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h4 id="ir_semantics-register_read"><strong><code>register_read</code></strong></h4>
<p>Reads a value from a register.</p>
<p>The register is defined on the block.</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = register_read(register=&lt;register_name&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p>The type <code>T</code> of the result of the operation is the type of the register.</p>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>register</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the register to read</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<h4 id="ir_semantics-register_write"><strong><code>register_write</code></strong></h4>
<p>Writes a value to a register.</p>
<p>The write to the register may be conditioned upon an optional load-enable and/or
reset signal. The register is defined on the block.</p>
<p>If <code>reset</code> is given the <code>register</code> associated with this read <strong>must</strong> have a
reset behavior set.</p>
<p>If the <code>reset</code> value matches the reset-active value of the register then the
<code>reset_value</code> of the register is written and the <code>data</code> is ignored.</p>
<p>If the <code>load_enable</code> argument is present the register will only be written if
the argument evaluates to <code>1</code>, remaining unchanged otherwise (i.e. if present it
is equivalent to <code>register_write.REG(sel(load_enable, {register_read.REG,
data}))</code>).</p>
<p>The <code>reset</code> and <code>load_enable</code> arguments affect the value written according to
the following table.</p>
<p>| <code>Register</code> reset      | <code>reset</code> value | <code>load_enable</code> value | new value     |
: behavior              :               :                     :               :
| --------------------- | ------------- | ------------------- | ------------- |
| <code>active_low == false</code> | <code>false</code> / <code>0</code> | not present         | <code>data</code>        |
| <code>active_low == false</code> | <code>true</code> / <code>1</code>  | not present         | <code>reset_value</code> |
| <code>active_low == true</code>  | <code>false</code> / <code>0</code> | not present         | <code>reset_value</code> |
| <code>active_low == true</code>  | <code>true</code> / <code>1</code>  | not present         | <code>data</code>        |
| <code>active_low == false</code> | <code>false</code> / <code>0</code> | <code>true</code> / <code>1</code>        | <code>data</code>        |
| <code>active_low == false</code> | <code>true</code> / <code>1</code>  | <code>true</code> / <code>1</code>        | <code>reset_value</code> |
| <code>active_low == true</code>  | <code>false</code> / <code>0</code> | <code>true</code> / <code>1</code>        | <code>reset_value</code> |
| <code>active_low == true</code>  | <code>true</code> / <code>1</code>  | <code>true</code> / <code>1</code>        | <code>data</code>        |
| <code>active_low == false</code> | <code>false</code> / <code>0</code> | <code>false</code> / <code>0</code>       | No change     |
| <code>active_low == false</code> | <code>true</code> / <code>1</code>  | <code>false</code> / <code>0</code>       | <code>reset_value</code> |
| <code>active_low == true</code>  | <code>false</code> / <code>0</code> | <code>false</code> / <code>0</code>       | <code>reset_value</code> |
| <code>active_low == true</code>  | <code>true</code> / <code>1</code>  | <code>false</code> / <code>0</code>       | No change     |
| not present           | not present   | <code>true</code> / <code>1</code>        | <code>data</code>        |
| not present           | not present   | <code>false</code> / <code>0</code>       | No change     |</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = register_write(data, load_enable=&lt;load_enable&gt;, reset=&lt;reset&gt;, register=&lt;register_name&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>load_enable</code></td>
<td><code>bits[1]</code> (optional)</td>
</tr>
<tr>
<td><code>reset</code></td>
<td><code>bits[1]</code> (optional)</td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>()</code> (empty tuple)</td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>register</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the register to write</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>The type <code>T</code> of the data operand must be the same as the the type of the
register.</p>
<h4 id="ir_semantics-instantiation_input"><strong><code>instantiation_input</code></strong></h4>
<p>Corresponds to a single input port of an instantiation.</p>
<p>An instantiation is a block-scoped construct that represents a module
instantiation at the Verilog level. Each <code>instantation_input</code> operation
corresponds to a particular port of the instantiated object, so generally a
single instantiation can have multiple associated <code>instantiation_input</code>
operations (one for each input port).</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = instantiation_input(data, instantiation=&lt;instantiation&gt;, port_name=&lt;port_name&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>()</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>instantiation</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the instantiation.</td>
</tr>
<tr>
<td><code>port_name</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the associated port of the instantiation.</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>The type <code>T</code> of the data operand must be the same as the the type of the
associated input port of the instantiated object.</p>
<h4 id="ir_semantics-instantiation_output"><strong><code>instantiation_output</code></strong></h4>
<p>Corresponds to a single output port of an instantiation.</p>
<p>An instantiation is a block-scoped construct that represents a module
instantiation at the Verilog level. Each <code>instantation_output</code> operation
corresponds to a output particular port of the instantiated object, so generally
a single instantiation can have multiple associated <code>instantiation_output</code>
operations (one for each output port).</p>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code>result = instantiation_output(instantiation=&lt;instantiation&gt;, port_name=&lt;port_name&gt;)
</code></pre></div>
<p><strong>Types</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>result</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong>Keyword arguments</strong></p>
<!-- mdformat off(multiline table cells not supported in mkdocs) -->

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>instantiation</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the instantiation.</td>
</tr>
<tr>
<td><code>port_name</code></td>
<td><code>string</code></td>
<td>yes</td>
<td></td>
<td>Name of the associated port of the instantiation.</td>
</tr>
</tbody>
</table>
<!-- mdformat on -->

<p>The type <code>T</code> of the result is type of the associated output port of the
instantiated object.</p></section><section class="print-page" id="optimizations-optimizations"><h1 id="optimizations-optimizations-xls-optimizations">XLS Optimizations</h1>
<div class="toc">
<ul>
<li><a href="#optimizations-optimizations-xls-optimizations">XLS Optimizations</a><ul>
<li><a href="#optimizations-optimizations-traditional-compiler-optimizations">Traditional compiler optimizations</a><ul>
<li><a href="#optimizations-optimizations-dead-code-elimination-dce">Dead Code Elimination (DCE)</a></li>
<li><a href="#optimizations-optimizations-common-subexpression-elimination-cse">Common Subexpression Elimination (CSE)</a></li>
<li><a href="#optimizations-optimizations-constant-folding">Constant Folding</a></li>
<li><a href="#optimizations-optimizations-assert-cleanup">Assert Cleanup</a></li>
<li><a href="#optimizations-optimizations-io-simplifications">IO Simplifications</a></li>
<li><a href="#optimizations-optimizations-reassociation">Reassociation</a></li>
</ul>
</li>
<li><a href="#optimizations-optimizations-narrowing-optimizations">Narrowing Optimizations</a><ul>
<li><a href="#optimizations-optimizations-select-operations">Select operations</a></li>
<li><a href="#optimizations-optimizations-arithmetic-and-shift-operations">Arithmetic and shift operations</a></li>
<li><a href="#optimizations-optimizations-comparison-operations">Comparison operations</a></li>
<li><a href="#optimizations-optimizations-known-literals-and-arrayindex">Known-literals and ArrayIndex</a></li>
</ul>
</li>
<li><a href="#optimizations-optimizations-strength-reductions">Strength Reductions</a><ul>
<li><a href="#optimizations-optimizations-arithmetic-comparison-strength-reductions">Arithmetic Comparison Strength Reductions</a></li>
</ul>
</li>
<li><a href="#optimizations-optimizations-simple-boolean-simplification">"Simple" Boolean Simplification</a></li>
<li><a href="#optimizations-optimizations-bit-slice-optimizations">Bit-slice optimizations</a><ul>
<li><a href="#optimizations-optimizations-slicing-sign-extended-values">Slicing sign-extended values</a></li>
</ul>
</li>
<li><a href="#optimizations-optimizations-concat-optimizations">Concat optimizations</a><ul>
<li><a href="#optimizations-optimizations-hoisting-a-reverse-above-a-concat">Hoisting a reverse above a concat</a></li>
<li><a href="#optimizations-optimizations-hoisting-a-bitwise-operation-above-a-concat">Hoisting a bitwise operation above a concat</a></li>
<li><a href="#optimizations-optimizations-merging-consecutive-bit-slices">Merging consecutive bit-slices</a></li>
</ul>
</li>
<li><a href="#optimizations-optimizations-select-optimizations">Select optimizations</a><ul>
<li><a href="#optimizations-optimizations-converting-chains-of-selects-to-into-a-single-onehotselect">Converting chains of Selects to into a single OneHotSelect</a></li>
<li><a href="#optimizations-optimizations-specializing-select-arms">Specializing select arms</a></li>
<li><a href="#optimizations-optimizations-consecutive-selects-with-identical-selectors">Consecutive selects with identical selectors</a></li>
<li><a href="#optimizations-optimizations-sparsifying-selects-with-range-analysis">Sparsifying selects with range analysis</a></li>
</ul>
</li>
<li><a href="#optimizations-optimizations-binary-decision-diagram-based-optimizations">Binary Decision Diagram based optimizations</a><ul>
<li><a href="#optimizations-optimizations-bdd-common-subexpression-elimination">BDD common subexpression elimination</a></li>
<li><a href="#optimizations-optimizations-onehot-msb-elimination">OneHot MSB elimination</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="optimizations-optimizations-traditional-compiler-optimizations">Traditional compiler optimizations</h2>
<p>Many optimizations from traditional compilers targeting CPUs also apply to the
optimization of hardware. Common objectives of traditional compiler
optimizations include exposing parallelism, reducing latency, and eliminating
instructions. Often these translate directly into the primary objectives of
hardware optimization of reducing delay and area.</p>
<h3 id="optimizations-optimizations-dead-code-elimination-dce">Dead Code Elimination (DCE)</h3>
<p>Dead Code Elimination (DCE for short) is usually one of the easiest and most
straightforward optimization passes in compilers. The same is true for XLS (the
implementation is in <code>xls/passes/dce_pass.*</code>). Understanding the pass is also a
good way to familiarize yourself with basics of the compiler IR, how to
implement a pass, how to iterate over the nodes in the IR, how to query for node
properties and so on.</p>
<p>In general, DCE removes nodes from the IR that cannot be reached. Nodes can
become unreachable by construction, for example, when a developer writes
side-effect-free computations in DSLX that are disconnected from the function
return ops. Certain optimization passes may also result in dead nodes.</p>
<p>Let's look at the structure of the pass. The header file is straightforward, The
<code>DeadCodeEliminationPass</code> is a function-level pass and hence derived from
<code>OptimizationFunctionBasePass</code>. Every function-level pass must implement the
function <code>RunOnFunctionBaseInternal</code> and return a status indicating whether or
not the pass made a change to the IR:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DeadCodeEliminationPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OptimizationFunctionBasePass</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">DeadCodeEliminationPass</span><span class="p">()</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">OptimizationFunctionBasePass</span><span class="p">(</span><span class="s">&quot;dce&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Dead Code Elimination&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="o">~</span><span class="n">DeadCodeEliminationPass</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>

<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Iterate all nodes, mark and eliminate the unvisited nodes.</span>
<span class="w">  </span><span class="n">absl</span><span class="o">::</span><span class="n">StatusOr</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RunOnFunctionBaseInternal</span><span class="p">(</span>
<span class="w">      </span><span class="n">FunctionBase</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OptimizationPassOptions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">,</span>
<span class="w">      </span><span class="n">PassResults</span><span class="o">*</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Now let's look at the implementation (in file <code>xls/passes/dce_pass.cc</code>). After
the function declaration:</p>
<div class="highlight"><pre><span></span><code><span class="n">absl</span><span class="o">::</span><span class="n">StatusOr</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DeadCodeEliminationPass</span><span class="o">::</span><span class="n">RunOnFunctionBaseInternal</span><span class="p">(</span>
<span class="w">    </span><span class="n">FunctionBase</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OptimizationPassOptions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">PassResults</span><span class="o">*</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>There is a little lambda function testing whether a node is deletable or not:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">is_deletable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">function_base</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HasImplicitUse</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">           </span><span class="o">!</span><span class="n">OpIsSideEffecting</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">());</span>
<span class="w">  </span><span class="p">};</span>
</code></pre></div>
<p>This function tests for two special classes of nodes.</p>
<ul>
<li>A node with implicit uses (defined in <code>xls/ir/function.h</code>) is a function's
    return value. In case of procs, the return is not reached and may appear as
    dead. It must not be removed as XLS expects each function to have a return
    value.</li>
</ul>
<ul>
<li>There are a number of side-effecting nodes, such as send/receive operations,
    asserts, covers, input / output ports, register read / writes, or parameters
    (and a few more). Because of their side effects, they must not be eliminated
    by DCE.</li>
</ul>
<p>Next the pass iterates over all nodes in the function and adds deletable nodes
with no users to a worklist. Those are leaf nodes, they are the initial
candidates for deletion:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">worklist</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">().</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">is_deletable</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">worklist</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>
<p>Now on to the heart of the DCE algorithm. The algorithm iterates over nodes in
the worklist until it is empty, popping elements from the front of the list and
potentially adding new elements to the list. For example, assume there was a
leaf node A with no further users. Further assume that its operand(s) only have
node A as user, then the operand will be added to the worklist and visited in
the next iteration over the worklist. There is a minor subtlety here - the code
has to ensure that operands are only visited once, hence the use of a
<code>flat_hash_set&lt;Node*&gt;</code> to check whether an operand has been visited already.</p>
<p>After all operands have been visited and potentially added to the worklist, the
original leaf node A is being removed and a corresponding logging statement
(level 3) is generated.</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">removed_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">absl</span><span class="o">::</span><span class="n">flat_hash_set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">unique_operands</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">worklist</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worklist</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="w">    </span><span class="n">worklist</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// A node may appear more than once as an operand of &#39;node&#39;. Keep track of</span>
<span class="w">    </span><span class="c1">// which operands have been handled in a set.</span>
<span class="w">    </span><span class="n">unique_operands</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">operand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unique_operands</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">operand</span><span class="p">).</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">HasSingleUse</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">is_deletable</span><span class="p">(</span><span class="n">operand</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">worklist</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">VLOG</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DCE removing &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">();</span>
<span class="w">    </span><span class="n">XLS_RETURN_IF_ERROR</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
<span class="w">    </span><span class="n">removed_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>
<p>Finally, a pass has to indicate whether or not it made any changes to the IR.
For this pass, this amounts to returning whether or not a single IR node has
been DCE'ed:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">VLOG</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Removed &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">removed_count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; dead nodes&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">removed_count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="optimizations-optimizations-common-subexpression-elimination-cse">Common Subexpression Elimination (CSE)</h3>
<p>Common subexpression elimination is another example of a classic compiler
optimization that equally applies to high-level synthesis. The heuristics on
which specific expressions to commonize may differ, given that commonizing
expressions can increase fan-out and connectivity of the IR, complicating place
and route. Currently, XLS is greedy and does not apply heuristics. It commonizes
any and all common expressions it can find. The CSE implementation can be found
in files <code>xls/passes/cse_pass.*</code>.</p>
<p>What does CSE actually do? The principles are quite simple and similar in
classic control-flow based compilers. Yet, as mentioned, the heuristics may be
moderately different. In CFG-based IRs, CSE would look for common expressions
and substitute in temporary variables. For example, for code like this with the
common expression <code>a+b</code>:</p>
<div class="highlight"><pre><span></span><code><span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">...</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
</code></pre></div>
<p>The compiler would first determine that addition is commutative and that hence
the expressions <code>a+b</code> and <code>b+a</code> can be canonicalized, eg., by ordering the
operands alphabetically. Then the compiler would introduce a temporary variable
for the expression and forward-substitute it into all occurances. For the
example, the resulting code would be something like this:</p>
<div class="highlight"><pre><span></span><code><span class="w">   </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">...</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
</code></pre></div>
<p>In effect, an arithmetic operation has been traded against a register (or cache)
access. Even in classic compilers, the CSE heuristics may consider factors such
as the length and number of live ranges (and corresponding register pressure) to
determine whether or not it may be better to just recompute the expression.</p>
<p>In XLS's "sea of nodes" IR, this transformation is quite simple. Given a graph
that contains multiple common subexpressions, for example:</p>
<div class="highlight"><pre><span></span><code>   A   B
    \ /
     C1      A   B
      \       \ /
       ...     C2
               /
             op(C2)
</code></pre></div>
<p>XLS would find that <code>C1</code> and <code>C2</code> compute identical expressions and would simply
replace the use of <code>C2</code> with <code>C1</code>, as in this graph (which will result in <code>C2</code>
being dead-code eliminated):</p>
<div class="highlight"><pre><span></span><code>   A   B
    \ /
     C1      A   B
      \       \ /
       ...     C2
         \
        op(C1)
</code></pre></div>
<p>Now let's see how this is implemented in XLS. CSE is a function-level
transformation and accordingly the pass is derived from
<code>OptimizationFunctionBasePass</code>. In the header file:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CsePass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OptimizationFunctionBasePass</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">CsePass</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OptimizationFunctionBasePass</span><span class="p">(</span><span class="s">&quot;cse&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Common subexpression elimination&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="o">~</span><span class="n">CsePass</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>

<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="n">absl</span><span class="o">::</span><span class="n">StatusOr</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RunOnFunctionBaseInternal</span><span class="p">(</span>
<span class="w">      </span><span class="n">FunctionBase</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OptimizationPassOptions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">,</span>
<span class="w">      </span><span class="n">PassResults</span><span class="o">*</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Several other optimizations passes expose new CSE opportunities. To make it easy
to call CSE from these other passes, we declare a standalone function to call
it. It accepts as input the function and returns a map containing the potential
replacements of one node with another:</p>
<div class="highlight"><pre><span></span><code><span class="n">absl</span><span class="o">::</span><span class="n">StatusOr</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RunCse</span><span class="p">(</span><span class="n">FunctionBase</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">,</span>
<span class="w">                            </span><span class="n">absl</span><span class="o">::</span><span class="n">flat_hash_map</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*&gt;*</span><span class="w"> </span><span class="n">replacements</span><span class="p">);</span>
</code></pre></div>
<p>CSE conceptually has to check for each op and its operands whether or not a
similar op exists somewhere else in the IR. To make this more efficient, XLS
first computes a 64-bit hash for each node. It combines the nodes' opcode with
all operands' IDs into a vector and computes the hash function over this vector.</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">Hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">node_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values_to_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">())};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">span_backing_store</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">operand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">GetOperandsForCse</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">span_backing_store</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">values_to_hash</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// If this is slow because of many literals, the Literal values could be</span>
<span class="w">    </span><span class="c1">// combined into the hash. As is, all literals get the same hash value.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">hasher</span><span class="p">(</span><span class="n">values_to_hash</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>
</code></pre></div>
<p>Note that this procedure uses the function <code>GetOperandsForCse</code> to collect the
operands. What does this function do? For nodes to be considered as equivalent,
the operands must be in the same order. Commutative operands are agnostic to
operand order. So in order to expand the opportunities for CSE, XLS sorts
commutative operands by their ID. As an optimization, to avoid having to
construct and return a full vector for each node and operands, the function gets
a parameter to a vector of nodes to use as storage and returns a
<code>absl::Span&lt;Node * const&gt;</code> over this backing store. This may look a bit
confusing in the code but is really just a performance optimization:</p>
<div class="highlight"><pre><span></span><code><span class="n">absl</span><span class="o">::</span><span class="n">Span</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetOperandsForCse</span><span class="p">(</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;*</span><span class="w"> </span><span class="n">span_backing_store</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">CHECK</span><span class="p">(</span><span class="n">span_backing_store</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">());</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">OpIsCommutative</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">span_backing_store</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">span_backing_store</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span>
<span class="w">                             </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">().</span><span class="n">end</span><span class="p">());</span>
<span class="w">  </span><span class="n">SortByNodeId</span><span class="p">(</span><span class="n">span_backing_store</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">span_backing_store</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Now on to the meat of the optimization pass. As always, we have to maintain
whether or not the pass modified the IR:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</code></pre></div>
<p>We store each first occurance of an expression in a map which is indexed by the
expression's hash value. Since potentially there is no redundancy in the IR, we
can pre-allocate this map to the size of function's IR. Note that non-common
expressions may result in the same hash value. Because of that, <code>node_buckets</code>
is a map from the hash value to a vector of nodes with the same hash value:</p>
<div class="highlight"><pre><span></span><code><span class="n">absl</span><span class="o">::</span><span class="n">flat_hash_map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;&gt;</span><span class="w"> </span><span class="n">node_buckets</span><span class="p">;</span>
<span class="n">node_buckets</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">node_count</span><span class="p">());</span>
</code></pre></div>
<p>Now we iterate over the nodes in the IR, ignoring nodes that have side effects:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">TopoSort</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OpIsSideEffecting</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>First thing to check is whether or not the op represents an expression that we
have potentially already seen. If this is the first occurrance of the
expression, which is efficient to check via the hash value, we store the op in
<code>node_buckets</code> and continue with the next node.</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_hash</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">node_buckets</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">node_buckets</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>Now it is getting more interesting. We may have found a node that is common with
a previously seen node. We collect the nodes operands (again, this looks a bit
complicated because of the performance optimization):</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">node_span_backing_store</span><span class="p">;</span>
<span class="w">    </span><span class="n">absl</span><span class="o">::</span><span class="n">Span</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node_operands_for_cse</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">GetOperandsForCse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node_span_backing_store</span><span class="p">);</span>
</code></pre></div>
<p>Then we iterate over all previously seen nodes with the same hash value which
are stored in <code>node_buckets</code>. Again, the may be multiple expressions with the
same hash value, hence we have to iterate over all candidates with that hash
value.</p>
<p>For each candidate, we collect the operands and then check whether the node is
<em>definitely</em> identical to a previously seen node. In this case the node's uses
can be replaced:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">node_buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">candidate_span_backing_store</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_operands_for_cse</span><span class="w"> </span><span class="o">==</span>
<span class="w">              </span><span class="n">GetOperandsForCse</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">candidate_span_backing_store</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">          </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">IsDefinitelyEqualTo</span><span class="p">(</span><span class="n">candidate</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="p">[...]</span>
</code></pre></div>
<p>If it was a match we replace the nodes, fill in the resulting replacement map,
and mark the IR as modified. We also note whether a true match was found (via
<code>replaced</code>):</p>
<div class="highlight"><pre><span></span><code><span class="w">        </span><span class="n">VLOG</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">StreamFormat</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;Replacing %s with equivalent node %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetName</span><span class="p">(),</span>
<span class="w">            </span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">GetName</span><span class="p">());</span>
<span class="w">        </span><span class="n">XLS_RETURN_IF_ERROR</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceUsesWith</span><span class="p">(</span><span class="n">candidate</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">replacements</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="p">(</span><span class="o">*</span><span class="n">replacements</span><span class="p">)[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidate</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">replaced</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>If, however, it turns out that while the hash value was identical but the ops
were not identical, we have to update <code>node_buckets</code> and insert the new
candidate.</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">replaced</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">node_buckets</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>As a final step, we return whether or not the IR was modified:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">changed</span><span class="p">;</span>
</code></pre></div>
<h3 id="optimizations-optimizations-constant-folding">Constant Folding</h3>
<p>Constant folding is another classic compiler optimization that equally applies
to high-level synthesis. What does it do? Given an arithmetic expression that as
inputs only as constant values, the compiler computes this expression at compile
time and replaces it with the result. There are two complexities:</p>
<ol>
<li>
<p>The IR has to be updated after the transformation.</p>
</li>
<li>
<p>More importantly, the evaluation of the expression must match the semantics
    of the target architecture!</p>
</li>
</ol>
<p>Both problems are solved elegantly in XLS. The IR update itself is trivial to do
with the sea-of-nodes IR. For expression evaluation, XLS simply re-uses the
interpreter, which implements the correct semantics. Let's look again at the
implementation, which is in file <code>xls/passes/constant_folding_pass.*</code>.</p>
<p>We define the pass as usual and maintain whether or not the pass modified the IR
in a boolean variable <code>changed</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">absl</span><span class="o">::</span><span class="n">StatusOr</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ConstantFoldingPass</span><span class="o">::</span><span class="n">RunOnFunctionBaseInternal</span><span class="p">(</span>
<span class="w">    </span><span class="n">FunctionBase</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OptimizationPassOptions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">PassResults</span><span class="o">*</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</code></pre></div>
<p>We now iterate over all nodes in the IR and check whether the node only has
literals as operands as well as whether it is safe to replace the node.</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">TopoSort</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Is</span><span class="o">&lt;</span><span class="n">Literal</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">TypeHasToken</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetType</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="o">!</span><span class="n">OpIsSideEffecting</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">().</span><span class="n">end</span><span class="p">(),</span>
<span class="w">                    </span><span class="p">[](</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">o</span><span class="o">-&gt;</span><span class="n">Is</span><span class="o">&lt;</span><span class="n">Literal</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="p">}))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">VLOG</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Folding: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">;</span>
</code></pre></div>
<p>Here now comes the fun part. If the condition is true, XLS simply collects the
operands in a vector and calls the interpreter to compute the result. Again,
the interpreter has to implement the proper semantics, which leads to this
exceedingly simple implementation.</p>
<div class="highlight"><pre><span></span><code><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand_values</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">operand</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">operand_values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">As</span><span class="o">&lt;</span><span class="n">Literal</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">XLS_ASSIGN_OR_RETURN</span><span class="p">(</span><span class="n">Value</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">InterpretNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">operand_values</span><span class="p">));</span>
<span class="w">      </span><span class="n">XLS_RETURN_IF_ERROR</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceUsesWithNew</span><span class="o">&lt;</span><span class="n">Literal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">status</span><span class="p">());</span>
<span class="w">      </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</code></pre></div>
<h3 id="optimizations-optimizations-assert-cleanup">Assert Cleanup</h3>
<p>Asserts whose condition is known to be true (represented by a 1-bit value of 1)
are removed as they will never trigger. This pass is implemented in file
<code>xls/passes/useless_assert_removel_pass.*</code> and is rather trivial. Again,
it shows in a simple way how to navigate the IR:</p>
<p>https://github.com/google/xls/blob/main/xls/passes/useless_assert_removal_pass.cc#L27-L43</p>
<h3 id="optimizations-optimizations-io-simplifications">IO Simplifications</h3>
<p>Conditional sends and receives that have a condition known to be false are
replaced with their input token (in the case of sends) or a tuple containing
their input token and a literal representing the zero value of the appropriate
channel (in the case of receives). Conditional sends and receives that have a
condition known to be true are replaced with unconditional sends and receives.
These two transforms are implemented in file
<code>xls/passes/useless_io_removal_pass.*</code>.</p>
<h3 id="optimizations-optimizations-reassociation">Reassociation</h3>
<p>Reassociation in XLS uses the associative and commutative property of arithmetic
operations (such as adds and multiplies) to rearrange expressions of identical
operations to minimize delay and area. Delay is reduced by transforming chains
of operations into balanced trees which reduces the critical-path delay. For
example, given the following expression:</p>
<p><img alt="drawing" src="../optimizations/reassoc_before.png" /></p>
<p>This can be reassociated into the following balanced tree:</p>
<p><img alt="drawing" src="../optimizations/reassoc_after.png" /></p>
<p>The transformation has reduced the critical path through the expression from
three adds down to two adds.</p>
<p>Reassociation can also create opportunities for constant folding. If an
expression contains multiple literal values (constants) the expressions can be
reassociated to gather literals into the same subexpression which can then be
folded. Generally this requires the operation to be commutative as well as
associative. For example, given the following expression:</p>
<p><img alt="drawing" src="../optimizations/literal_reassoc_before.png" /></p>
<p>This can be reassociated into:</p>
<p><img alt="drawing" src="../optimizations/literal_reassoc_after.png" /></p>
<p>The right-most add of the two literals can be folded reducing the number of adds
in the expression to two.</p>
<h2 id="optimizations-optimizations-narrowing-optimizations">Narrowing Optimizations</h2>
<p>The XLS compiler performs <strong>bitwise flow analysis</strong>, and so can deduce that
certain bits in the output of operations are always-zero or always-one. As a
result, after running this bit-level tracking flow analysis, some of the bits on
the output of an operation may be "known". With known bits in the output of an
operation, we can often narrow the operation to only produce the <em>unknown</em> bits
(those bits that are not known static constants), which reduces the "cost" of
the operation (amount of delay through the operation) by reducing its bitwidth.</p>
<h3 id="optimizations-optimizations-select-operations">Select operations</h3>
<p>An example of this is select narrowing, as shown in the following -- beforehand
we have three operands, but from our bitwise analysis we know that there are two
constant bits in the MSb as well as two constant bits in the LSb being
propagated from all of our input operands.</p>
<p><img alt="One-Hot-Select Before Squeezing" src="../optimizations/one_hot_select_before.png" style="display:block;margin:auto;width:50%" /></p>
<p>Recognizing that property, we squeeze the one hot select operation -- in the
"after" diagram below observe we've narrowed the operation by slicing the
known-constant bits out of the one hot select operation, making it cheaper in
terms of delay, and propagated the slices up to the input operands -- these
slices being presented at the output of the operands may in turn let <em>them</em>
narrow their operation and become cheaper, and this can continue transitively):</p>
<p><img alt="One-Hot-Select After Squeezing" src="../optimizations/one_hot_select_after.png" style="display:block;margin:auto;width:50%" /></p>
<h3 id="optimizations-optimizations-arithmetic-and-shift-operations">Arithmetic and shift operations</h3>
<p>Most arithmetic ops support mixed bit widths where the operand widths may not be
the same width as each other or the result. This provides opportunities for
narrowing. Specifically (for multiplies, adds and subtracts):</p>
<ol>
<li>
<p>If the operands are wider than the result, the operand can be truncated to
    the result width.</p>
</li>
<li>
<p>If the operation result is wider than the full-precision width of the
    operation, the operation result can be narrowed to the full-precision width
    then sign- or zero-extended (depending upon the sign of the operation) to
    the original width to produce the desired result. The full-precision width
    of an add or subtract is one more than the width of the widest operand, and
    the full-precision width of a multiply is the sum of the operand widths.</p>
</li>
<li>
<p>If the most-significant bit of an operand are zeros (for unsigned
    operations) or the same as the sign-bit value (for signed operations), the
    operand can be narrowed to remove these known bits.</p>
</li>
</ol>
<p>As a special case, adds can be narrowed if the least-significant bits of an is
all zeros. The add operation is narrowed to exclude this range of
least-significant bits. The least-significant bits of the result are simply the
least-significant bits of the non-zero operand:</p>
<p><img alt="drawing" src="../optimizations/narrowed_add.png" /></p>
<p>Similarly, if the most-significant bits of the shift-amount of a shift operation
are zero the shift amount can be narrowed.</p>
<h3 id="optimizations-optimizations-comparison-operations">Comparison operations</h3>
<p>Leading and trailing bits can be stripped from the operands of comparison
operations if these bits do not affect the result of the comparison. For
unsigned comparisons, leading and trailing bits which are identical between the
two operands can be stripped which narrows the comparison and reduces the cost
of the operation.</p>
<p>Signed comparison are more complicated to handle because the sign bit
(most-significant bit) affects the interpretation of the value of the remaining
bits. Stripping leading bits must preserve the sign bit of the operand.</p>
<h3 id="optimizations-optimizations-known-literals-and-arrayindex">Known-literals and <code>ArrayIndex</code></h3>
<p>The narrowing pass also converts any node that is determined by range analysis
to have a range containing only one value into a literal. As a further extension
of this idea, it also converts <code>ArrayIndex</code> nodes that are determined to have a
small number of possible indices into select chains.</p>
<p>This latter optimization is sometimes harmful, so we currently hide it behind
the <code>--convert_array_index_to_select=&lt;n&gt;</code> flag in <code>opt_main</code> and
<code>benchmark_main</code>, where <code>&lt;n&gt;</code> controls the number of possible array indices
above which the optimization does not fire. The right number to put there is
highly contextual, since this optimization relies heavily on later passes to
clean up its output.</p>
<h2 id="optimizations-optimizations-strength-reductions">Strength Reductions</h2>
<h3 id="optimizations-optimizations-arithmetic-comparison-strength-reductions">Arithmetic Comparison Strength Reductions</h3>
<p>When arithmetic comparisons occur with respect to constant values, comparisons
which are be arithmetic in the general case may be strength reduced to more
boolean-analyzeable patterns; for example, comparison with mask constants:</p>
<div class="highlight"><pre><span></span><code>u4:0bwxyz &gt; u4:0b0011
</code></pre></div>
<p>Can be strength reduced -- for the left hand side to be greater one of the <code>wx</code>
bits must be set, so we can simply replace this with an or-reduction of <code>wx</code>.
Similarly, a trailing-bit and-reduce is possible for less-than comparisons.</p>
<p>NOTE These examples highlight a set of optimizations that are not applicable
(profitable) on traditional CPUs: the ability to use bit slice values below what
we'd traditionally think of as a fundamental comparison "instruction", which
would nominally take a single cycle.</p>
<h2 id="optimizations-optimizations-simple-boolean-simplification">"Simple" Boolean Simplification</h2>
<p>NOTE This optimization is a prelude to a more general optimization we expect to
come in the near future that is based on Binary Decision Diagrams. It is
documented largely as a historical note of an early / simple optimization
approach.</p>
<p>With the addition of the <code>one_hot_select</code> and its corresponding optimizations, a
larger amount of boolean logic appears in XLS's optimized graphs (e.g. or-ing
together bits in the selector to eliminate duplicate <code>one_hot_select</code> operands).
Un-simplified boolean operations compound their delay on the critical path; with
the process independent constant <span class="arithmatex">\(\tau\)</span> a single bit <code>or</code> might be <span class="arithmatex">\(6\tau\)</span>,
which is just to say that having lots of dependent <code>or</code> operations can
meaningfully add up in the delay estimation for the critical path. If we can
simplify several layers of boolean operations into one operation (say, perhaps
with inputs optionally inverted) we could save a meaningful number of tau versus
a series of dependent boolean operations.</p>
<p>For a simple approach to boolean simplification:</p>
<ul>
<li>The number of parameters to the boolean function is limited to three inputs</li>
<li>The truth table is computed for the aggregate boolean function by flowing
    input bit vectors through all the boolean operation nodes.</li>
<li>The result bit vectors on the output frontier are matched the resulting
    truth table from the flow against one of our standard operations (perhaps
    with the input operands inverted).</li>
</ul>
<p>The algorithm starts by giving <code>x</code> and <code>y</code> their vectors (columns) from the
truth table, enumerating all possible bit combinations for those operands. For
example, consider two operands and a (bitwise) boolean function, the following
is the truth table:</p>
<div class="highlight"><pre><span></span><code>X Y | X+~Y
----+------
0 0 |  1
0 1 |  0
1 0 |  1
1 1 |  1
</code></pre></div>
<p>Each column in this table is a representation of the possibilities for a node in
the graph to take on, as a vector. After giving the vector <code>[0, 0, 1, 1]</code> to the
first input node (which is arbitrarily called X) and the vector <code>[0, 1, 0, 1]</code>
to the second input node (which is arbitrarily called Y), and flowing those bit
vectors through a network of boolean operations, if you wind up with a vector
<code>[1, 0, 1, 1]</code> at the end, it is sound to replace that whole network with the
expression <code>X+~Y</code>. Similarly, if the algorithm arrived at the vector <code>[1, 1, 1,
1]</code> at the end of the network, you could replace the result with a literal <code>1</code>,
because it has been proven for all input operand possibilities the result is
always <code>1</code> in every bit. Effectively, this method works by brute force
enumerating all the possibilities for input bits and operating on all of those
possibilities at the same time. In the end, the algorithm arrives at a composite
boolean function that can be pattern matched against XLS's set of "simple
boolean functions".</p>
<p>In the following example there are two nodes on the "input frontier" for the
boolean operations (<code>sub</code> and <code>add</code>, which we "rename" to <code>x</code> and <code>y</code> for the
purposes of analysis).</p>
<p><img alt="Two-Input Boolean Simplification" src="../optimizations/two_input_boolean_simplification.png" style="display:block;margin:auto;width:75%" /></p>
<p>As shown in the picture, the algorithm starts flowing the bit vector, which
represents all possible input values for <code>x</code> and <code>y</code>. You can see that the <code>not</code>
which produces <span class="arithmatex">\(\bar{x}\)</span> (marked with a red star) simply inverts all the entries
in the vector and corresponds to the <span class="arithmatex">\(\bar{x}\)</span> column in the truth table.
Similarly the <code>and</code> operation joins the two vector with the binary <code>&amp;</code>
operation, and finally we end up with the blue-starred bit vector on the "output
frontier", feeding the dependent <code>one_hot_select</code> (marked as <code>ohs</code> in the
diagram).</p>
<p>When we resolve that final result bit vector with the blue star against our
table of known function substitutions, we see that the final result can be
replaced with a node that is simply <code>or(x, y)</code>, saving two unnecessary levels of
logic, and reducing the critical path delay in this example from something like
<span class="arithmatex">\(13\tau\)</span> to something like <span class="arithmatex">\(6\tau\)</span>.</p>
<p>This basic procedure is then extended to permit three variables on the input
frontier to the boolean expression nodes, and the "known function" table is
extended to include all of our supported logical operators (i.e. <code>nand</code>, <code>nor</code>,
<code>xor</code>, <code>and</code>, <code>or</code>) with bit vectors for all combinations of inputs being
present, and when present, either asserted, or their inversions (e.g. we can
find <span class="arithmatex">\(nand(\bar{X}, Y)\)</span> even though X is inverted).</p>
<h2 id="optimizations-optimizations-bit-slice-optimizations">Bit-slice optimizations</h2>
<p>Bit-slice operations narrow values by selecting a contiguous subset of bits from
their operand. Bit-slices are zero-cost operations as no computation is
performed. However, optimization of bit-slices can be beneficial as bit-slices
can interfere with optimizations and hoisting bit-slices can narrow other
operations reducing their computation cost.</p>
<h3 id="optimizations-optimizations-slicing-sign-extended-values">Slicing sign-extended values</h3>
<p>A bit-slice of a sign-extended value is a widening operation followed by a
narrowing operation and can be optimized. The details of the transformation
depends upon relative position of the slice and the sign bit of the original
value. Let <code>sssssssXXXXXXXX</code> be the sign-extended value where <code>s</code> is the sign
bit and <code>X</code> represents the bits of the original value. There are three possible
cases:</p>
<ol>
<li>
<p>Slice is entirely within the sign-extend operand.</p>
<p><img alt="drawing" src="../optimizations/bitslice_of_sign_ext_1.png" /></p>
<p><strong>Transformation:</strong> replace the bit-slice of the sign-extended value with a
  bit-slice of the original value.</p>
</li>
<li>
<p>Slice spans the sign bit of the sign-extend operand.</p>
<p><img alt="drawing" src="../optimizations/bitslice_of_sign_ext_2.png" /></p>
<p><strong>Transformation:</strong> slice the most significant bits from the original value
  and sign-extend the result.</p>
</li>
<li>
<p>Slice is entirely within the sign-extended bits.</p>
<p><img alt="drawing" src="../optimizations/bitslice_of_sign_ext_3.png" /></p>
<p><strong>Transformation:</strong> slice the sign bit from the original value and
  sign-extend it.</p>
</li>
</ol>
<p>To avoid introducing additional sign-extension operations cases (2) and (3)
should only be performed if the bit-slice is the only user of the
sign-extension.</p>
<h2 id="optimizations-optimizations-concat-optimizations">Concat optimizations</h2>
<p><code>Concat</code> (short for concatenation) operations join their operands into a single
word. Like <code>BitSlice</code>s, <code>Concat</code> operations have no cost since since they simply
create a new label to refer to a set of bits, performing no actual computation.
However, <code>Concat</code> optimizations can still provide benefit by reducing the number
of IR nodes (increases human readability) or by refactoring the IR in a way that
allows other optimizations to be applied. Several <code>Concat</code> optimizations involve
hoisting an operation on one or more <code>Concat</code>s to above the <code>Concat</code> such that
the operation is applied on the <code>Concat</code> operands directly. This may provide
opportunities for optimization by bringing operations which actually perform
logic closer to other operations performing logic.</p>
<h3 id="optimizations-optimizations-hoisting-a-reverse-above-a-concat">Hoisting a reverse above a concat</h3>
<p>A <code>Reverse</code> operation reverses the order of the bits of the input operand. If a
<code>Concat</code> is reversed and the <code>Concat</code> has no other consumers except for
reduction operations (which are not sensitive to bit order), we hoist the
<code>Reverse</code> above the <code>Concat</code>. In the modified IR, the <code>Concat</code> input operands
are <code>Reverse</code>'d and then concatenated in reverse order, e.g. :</p>
<div class="highlight"><pre><span></span><code>Reverse(Concat(a, b, c))
=&gt; Concat(Reverse(c), Reverse(b), Reverse(a))
</code></pre></div>
<h3 id="optimizations-optimizations-hoisting-a-bitwise-operation-above-a-concat">Hoisting a bitwise operation above a concat</h3>
<p>If the output of multiple <code>Concat</code> operations are combined with a bitwise
operation, the bitwise operation is hoisted above the <code>Concat</code>s. In the modified
IR, we have a single <code>Concat</code> whose operands are bitwise'd <code>BitSlice</code>s of the
original <code>Concat</code>s, e.g. :</p>
<div class="highlight"><pre><span></span><code>Or(Concat(A, B), Concat(C, D)), where A,B,C, and D are 1-bit values
=&gt; Concat(Or(Concat(A, B)[1], Concat(C, D)[1]), Or(Concat(A, B)[0], Concat(C, D)[0]))
</code></pre></div>
<p>In the case that an added <code>BitSlice</code> exactly aligns with an original <code>Concat</code>
operand, other optimizations (bit slice simplification, constant folding, dead
code elimination) will replace the <code>BitSlice</code> with the operand, e.g. for the
above example:</p>
<div class="highlight"><pre><span></span><code>=&gt; Concat(Or(A, C), Or(B, D))
</code></pre></div>
<h3 id="optimizations-optimizations-merging-consecutive-bit-slices">Merging consecutive bit-slices</h3>
<p>If consecutive <code>Concat</code> operands are consecutive <code>BitSlice</code>s, we create a new,
merged <code>BitSlice</code> spanning the range of the consecutive <code>BitSlice</code>s. Then, we
create a new <code>Concat</code> that includes this <code>BitSlice</code> as an operand, e.g.</p>
<div class="highlight"><pre><span></span><code>Concat(A[3:2], A[1:0], B)
=&gt; Concat(A[3:0], B)
</code></pre></div>
<p>This optimization is sometimes helpful and sometimes harmful, e.g. in the case
that there are other consumers of the original <code>BitSlice</code>s, we may only end up
adding more IR nodes since the original <code>BitSlice</code>s will not be removed by DCE
once they are replaced in the <code>Concat</code>. Some adjustments might be able to help
with this issue. An initial attempt at this limited the application of this
optimization to cases where the given<code>Concat</code> is the only consumer of the
consecutive <code>BitSlice</code>s. This limited the more harmful applications of this
optimization, but also reduced instances in which the optimization was
beneficially applied (e.g. the same consecutive <code>BitSlice</code>s could be merged in
multiple <code>Concat</code>s).</p>
<h2 id="optimizations-optimizations-select-optimizations">Select optimizations</h2>
<p>XLS supports two types of select operations:</p>
<ol>
<li>
<p><code>Select</code> (opcode <code>Op::kSel</code>) is a traditional multiplexer. An <code>n</code>-bit
    binary-encoded selector chooses among 2**<code>n</code> inputs.</p>
</li>
<li>
<p><code>OneHotSelect</code> (opcode <code>Op::kOneHotSel</code>) has one bit in the selector for
    each input. The output of the operation is equal to the logical-or reduction
    of the inputs corresponding to the set bits of the selector. Generally, a
    <code>OneHotSelect</code> is lower latency and area than a <code>Select</code> as a <code>Select</code> is
    effectively a decode operation followed by a <code>OneHotSelect</code>.</p>
</li>
</ol>
<h3 id="optimizations-optimizations-converting-chains-of-selects-to-into-a-single-onehotselect">Converting chains of <code>Select</code>s to into a single <code>OneHotSelect</code></h3>
<p>A linear chain of binary <code>Select</code> operations may be produced by the front end to
select amongst a number of different values. This is equivalent to nested
ternary operators in C++.</p>
<p><img alt="drawing" src="../optimizations/select_chain.png" /></p>
<p>A chain of <code>Select</code>s has high latency, but latency may be reduced by converting
the <code>Select</code> chain into a single <code>OneHotSelect</code>. This may only be performed if
the single-bit selectors of the <code>Select</code> instructions are one-hot (at most one
selector is set at one time). In this case, the single-bit <code>Select</code> selectors
are concatenated together to produce the selector for the one hot.</p>
<p><img alt="drawing" src="../optimizations/compacted_one_hot_select.png" /></p>
<p>This effectively turns a serial operation into a lower latency parallel one. If
the selectors of the original <code>Select</code> instructions can be all zero (but still
at most one selector is asserted) the transformation is slightly modified. An
additional selector which is the logical NOR of all of the original <code>Select</code>
selector bits is appended to the <code>OneHotSelect</code> selector and the respective case
is the value selected when all selector bits are zero (<code>case_0</code> in the diagram).</p>
<h3 id="optimizations-optimizations-specializing-select-arms">Specializing select arms</h3>
<p>Within any given arm of a <code>Select</code> multiplexer, we can assume that the
selector has the specific value required to select that arm. This assumption
is safe because in the event that the selector has a different value, the
arm is dead.</p>
<p><img alt="drawing" src="../optimizations/selector_substitution.png" /></p>
<p>This makes it possible to try specialize the arms based on the selector
value. In the above example, a LHS of <code>Selector + x</code> could be simplified to
<code>0 + x</code>.</p>
<p>The current optimization simply substitutes any usages of the selector in a
<code>Select</code> arm with its known value in that arm. Future improvements could use
range based analysis or other techniques to narrow down the possible values of
any variables within the selector, and use that information to optimize the
select arms.</p>
<h3 id="optimizations-optimizations-consecutive-selects-with-identical-selectors">Consecutive selects with identical selectors</h3>
<p>Two consecutive two-way selects which use the same selector can be compacted
into a single select statement. The selector only has two states so only two of
the three different cases may be selected. The third is dead. Visually, the
transformation looks like:</p>
<p><img alt="drawing" src="../optimizations/consecutive_selects.png" /></p>
<p>The specific cases which remain in the new select instruction depends on whether
the upper select feeds the true or false input of the lower select.</p>
<h3 id="optimizations-optimizations-sparsifying-selects-with-range-analysis">Sparsifying selects with range analysis</h3>
<p>If range analysis determines that the selector of a select has fewer possible
values than the number of cases, we can do a form of dead code elimination to
remove the impossible cases.</p>
<p>Currently, we do this in the following way:</p>
<div class="highlight"><pre><span></span><code>// Suppose bar has interval set {[1, 4], [6, 7], [10, 13]}
foo = sel(bar, cases=[a1, ..., a16])
// Sparsification will lead to the following code:
foo = sel((bar &gt;= 1) &amp;&amp; (bar &lt;= 4), cases=[
  sel((bar &gt;= 6) &amp;&amp; (bar &lt;= 7), cases=[
    sel(bar - 10, cases=[a11, ..., a14], default=0),
    sel(bar - 6, cases=[a7, a8], default=0)
  ]),
  sel(bar - 1, cases=[a2, ..., a5], default=0)
])
</code></pre></div>
<p>This adds a little bit of code for the comparisons and subtractions but is
generally worth it since eliminating a case branch can be a big win.</p>
<h2 id="optimizations-optimizations-binary-decision-diagram-based-optimizations">Binary Decision Diagram based optimizations</h2>
<p>A binary decision diagram (BDD) is a data structure that can represent arbitrary
boolean expressions. Properties of the BDD enable easy determination of
relationships between different expressions (equality, implication, etc.) which
makes them useful for optimization and analysis</p>
<h3 id="optimizations-optimizations-bdd-common-subexpression-elimination">BDD common subexpression elimination</h3>
<p>Determining whether two expression are equivalent is trivial using BDDs. This
can be used to identify operations in the graph which produce identical results.
BDD CSE is an optimization pass which commons these equivalent operations.</p>
<h3 id="optimizations-optimizations-onehot-msb-elimination">OneHot MSB elimination</h3>
<p>A <code>OneHot</code> instruction returns a bitmask with exactly one bit equal to 1. If the
input is not all-0 bits, this is the first 1 bit encountered in the input going
from least to most significant bit or vice-versa depending on the priority
specified. If the input is all-0 bits, the most significant bit of the <code>OneHot</code>
output is set to 1. The semantics of <code>OneHot</code> are described in detail
<a href="#ir_semantics">here</a>. If the MSB of a <code>OneHot</code>
does not affect the functionality of a program, we replace the MSB with a 0-bit,
e.g.</p>
<div class="highlight"><pre><span></span><code>OneHot(A) such that the MSB has no effect
⇒ Concat(0, OneHot(A)[all bits except MSB]))
</code></pre></div>
<p>This can open up opportunities for further optimization. To determine if a
<code>OneHot</code>’s MSB has any effect on a function, we iterate over the <code>OneHot</code>’s
post-dominators. We use the BDD to test if setting the <code>OneHot</code>’s MSB to 0 or to
1 (other bits are 0 in both cases) implies the same value for the post-dominator
node. If so, we know the value of the MSB cannot possibly affect the function
output, so the MSB can safely be replaced with a 0 bit. Note: This approach
assumes that IR nodes do not have any side effects. When IR nodes with side
effects are introduced (i.e. channels) the analysis for this optimization will
have to be adjusted slightly to account for this.</p></section>
                        <h2 class='nav-section-title' id='section-scheduling'>
                            Scheduling <a class='headerlink' href='#section-scheduling' title='Permanent link'>↵</a>
                        </h2>
                        <section class="print-page" id="scheduling"><h1 id="scheduling-xls-pipeline-scheduling">XLS Pipeline scheduling</h1>
<div class="toc">
<ul>
<li><a href="#scheduling-xls-pipeline-scheduling">XLS Pipeline scheduling</a><ul>
<li><a href="#scheduling-scheduling-process">Scheduling process</a><ul>
<li><a href="#scheduling-step-1-determine-the-effective-clock-period">Step 1: determine the effective clock period</a></li>
<li><a href="#scheduling-step-2-schedule-to-minimize-pipeline-registers">Step 2: schedule to minimize pipeline registers</a></li>
<li><a href="#scheduling-common-options">Options for common scheduling objectives</a></li>
</ul>
</li>
<li><a href="#scheduling-sdc">Minimizing pipeline registers via SDC scheduling</a><ul>
<li><a href="#scheduling-constraints">Constraints</a></li>
<li><a href="#scheduling-additional-technical-details">Additional technical details</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>Pipeline scheduling divides the IR nodes of an XLS function or proc into a
sequence of stages constituting a feed-forward pipeline. Sequential stages are
separated by registers enabling pipeline parallelism. The schedule must satisfy
dependency constraints between XLS nodes as well as timing constraints imposed
by the target clock frequency. Pipeline scheduling has multiple competing
optimization objectives: minimize number of stages (minimize pipeline latency),
minimize maximum delay of any stage (maximize clock frequency), and minimize the
number of pipeline registers.</p>
<h2 id="scheduling-scheduling-process">Scheduling process</h2>
<p>Pipeline scheduling occurs in two phases:</p>
<ol>
<li>
<p>Determine the effective clock period. This clock period defines the maximum
    delay, based on XLS's internal <a href="#delay_estimation">delay model</a>, through
    any pipeline stage and limits how many IR operations might be placed in each
    stage.</p>
</li>
<li>
<p>Given the constraints of the effective clock period and, optionally, a
    user-defined number of pipeline stages, find the schedule which minimizes
    the number of pipeline registers. Pipeline registers are required for any IR
    operation whose value which is used in a later stage.</p>
</li>
</ol>
<p>The schedule process is controlled via several options defined
<a href="https://github.com/google/xls/tree/main/xls/scheduling/pipeline_schedule.h">here</a>.
These options are typically passed in as flags to the
<a href="https://github.com/google/xls/tree/main/xls/tools/codegen_main.cc"><code>codegen_main</code> binary</a>
but maybe set programmatically. Each is optional though at least one of <strong>clock
period</strong> or <strong>pipeline stages</strong> must be specified. Different combinations of
options result in different strategies as described <a href="#scheduling-common-options">below</a>.</p>
<p>Clock period
:   The target clock period.</p>
<p>Pipeline stages
:   The number of stages in the pipeline.</p>
<p>Clock margin percent
:   The percentage to reduce the target clock period before scheduling. May only
    be specified with <strong>clock period</strong>. This option is equivalent to specifying
    a reduced value for <strong>clock period</strong>.</p>
<p>Clock period relaxation percent
:   This is the percentage that the computed minimum clock period, as determined
    by the number of pipeline stages, is increased (relaxed) prior to
    scheduling. May not be specified with <strong>clock period</strong>.</p>
<h3 id="scheduling-step-1-determine-the-effective-clock-period">Step 1: determine the effective clock period</h3>
<p>The effective clock period determines the maximum delay through any pipeline
stage for the purpose of scheduling. The value is determined in one of two ways
depending upon whether the <strong>clock period</strong> option is specified.</p>
<ol>
<li>
<p><strong>clock period</strong> specified</p>
<p>The effective clock period is set the <strong>clock period</strong> value. If <strong>clock
  margin percent</strong> is also specified, then the effective clock period is also
  reduced by the given percentage. Example: if <strong>clock period</strong> is 800ps and
  <strong>clock margin percent</strong> is 20% then the effective clock period is 640ps.</p>
</li>
<li>
<p><strong>clock period</strong> not specified</p>
<p>In this case, <strong>pipeline stages</strong> must be specified. The effective clock
  period is computed as the minimum clock period in which a schedule may be
  found that meets timing with the specified number of pipeline stages. This
  is done via a binary search through clock period values, where at each step
  of the binary search the scheduler is run in its entirety. If <strong>clock period
  relaxation percent</strong> is specified then the computed effective clock period
  is <em>increased</em> by the given percentage. The motivation is that this
  relaxation may result in fewer pipeline registers because of increased
  scheduling flexibility. Example: if the minimum clock period found by XLS
  was 1000ps and <strong>clock period relaxation percent</strong> is 10% the effective
  clock period is 1100ps.</p>
</li>
</ol>
<h3 id="scheduling-step-2-schedule-to-minimize-pipeline-registers">Step 2: schedule to minimize pipeline registers</h3>
<p>Once an effective clock period is determined, XLS computes a schedule which
minimizes the number of registers (see <a href="#scheduling-sdc">below</a> for details) while
satisfying various constraints, including the critical path delay constraints
imposed by the effective clock period. The number of stages in the pipeline may
be specified by the user via the <strong>pipeline stages</strong> option. If the number of
pipeline stages specified is too small an error such that no feasible schedule
can be found then an error is returned. If <strong>pipeline stages</strong> is not given then
the minimum number of stages which meets the delay constraint imposed by the
effective clock period is used.</p>
<h3 id="scheduling-common-options">Options for common scheduling objectives</h3>
<p>Different scheduling options result in different optimization strategies for the
scheduler. Below are several common scheduling objectives and options which
should be set to enable them.</p>
<ol>
<li>
<p>Minimize the number of pipeline registers for a given clock period and given
    number of pipeline stages.</p>
<p>Specify both <strong>clock period</strong> and <strong>pipeline stages</strong>. The scheduler will
  attempt to minimize the number of pipeline registers given those
  constraints. The option <strong>clock margin percent</strong> can be swept to search the
  local design space (or equivalently, sweep <strong>clock period</strong>)</p>
</li>
<li>
<p>Minimize the clock period for a given number of pipeline stages</p>
<p>Specify only <strong>pipeline stages</strong>. XLS will find a schedule with minimum
  clock period with a secondary objective of minimizing the number of pipeline
  registers. Sweeping <strong>clock period relaxation percent</strong> explores relaxing
  the timing constraint which may result in fewer pipeline registers.</p>
</li>
<li>
<p>Minimize the number of pipeline stages for a given clock period</p>
<p>Specify only <strong>clock period</strong>. XLS will find a schedule of the minimum
  number of stages with a secondary objective of minimizing the number of
  pipeline registers. The option <strong>clock margin percent</strong> can be swept to
  search the local design space (or equivalently, sweep <strong>clock period</strong>)</p>
</li>
<li>
<p>Minimize the number of pipeline registers for a given clock period</p>
<p>Specify only <strong>clock period</strong> and sweep <strong>pipeline stages</strong>. Pick the
  schedule which produces the minimum number of pipeline registers.</p>
</li>
<li>
<p>Sweep the entire scheduling space</p>
<p>The various options directly or indirectly control the two degrees of
  freedom within the scheduler: pipeline stages and clock period. Sweeping
  these two degrees of freedom is most easily done by sweeping <strong>pipeline
  stages</strong> and <strong>clock period relaxation percent</strong>. The advantage of sweeping
  <strong>clock period relaxation percent</strong> instead of <strong>clock period</strong> directly is
  that the percent relaxation can be a fixed range (e.g., 0 to 50%) for all
  designs and each value will produce a feasible schedule. If <strong>clock period</strong>
  is swept some combinations of <strong>pipeline stages* and </strong>clock period** values
  will result in an error returned because the design point is infeasible.</p>
</li>
</ol>
<h2 id="scheduling-sdc">Minimizing pipeline registers via SDC scheduling</h2>
<p>For scheduling pipelines, XLS uses a variation on the approach described in
<a href="https://www.csl.cornell.edu/~zhiruz/pdfs/sdcmod-iccad2013.pdf">SDC-Based Modulo Scheduling for Pipeline Synthesis</a>.
The basic principle is to create a set of real-valued variables, each
corresponding to the cycle in which a node is scheduled or the
lifetime<sup id="scheduling-fnref:lifetime"><a class="footnote-ref" href="#scheduling-fn:lifetime">1</a></sup> of a node, and then carefully constrain the variables using
linear inequality constraints such that minimizing a linear objective always
gives an answer with <em>integer</em> values for all the variables. This avoids the
need for integer linear programming, which is NP complete, and instead can be
solved with linear programming, which is polynomial time in theory and takes
roughly cubic time in practice.</p>
<p>Prior to the implementation of the SDC scheduler, we used a scheduler based on
taking the min-cut of the node graph with Ford-Fulkerson. However, this design
proved difficult to extend with needed features like IO constraints, and unlike
the SDC algorithm was not optimal in the particular, narrow, sense that it
assigns nodes to cycles such that the required register bits are minimized. We
found that switching from the min-cut algorithm to SDC resulted in marginal
improvements to benchmarks and increased compile times by an small and
acceptable amount.</p>
<h3 id="scheduling-constraints">Constraints</h3>
<p>Currently, we generate a variety of constraints:</p>
<ul>
<li>Causality constraints, i.e.: if node Y uses the output of node X, then the
    cycle of node X must be less than or equal to the cycle of node Y.</li>
<li>Timing constraints, i.e.: if the critical path between node X and node Y is
    greater than the clock period, then the cycle of Y must be strictly greater
    than the cycle of X.</li>
<li>IO constraints among sends and receives on a given channel (see the codegen
    documentation for more details).</li>
<li>"Node in cycle" constraints, which allow forcing a given node to be
    scheduled in a given cycle. This is useful for incremental scheduling in the
    scheduling pass pipeline.</li>
<li>"Receives first, sends last" constraints, which allow accessing the old
    behavior in which receives all went into the first cycle and sends all went
    into the last cycle.</li>
<li>Backedge constraints: when the initiation interval is 1, a state parameter
    and its corresponding next state must be scheduled in the same cycle. More
    generally, we build up a graph of states where there is an edge between two
    states if the output of one affects the input of another, and then compute
    the strongly connected components of this graph. All nodes within a strongly
    connected component must be in the same cycle.</li>
</ul>
<h3 id="scheduling-additional-technical-details">Additional technical details</h3>
<p>The linear inequality constraints can be summarized by a matrix M and a vector y
such that Mx ≤ y. If the linear program has the property described above (that
minimizing a linear objective gives an integer answer), then the matrix M is
considered to be <em>integral</em>. One class of integral matrices is that of the
"totally unimodular matrices". The exact definition of this class is out of
scope to discuss here, but it suffices to say that it includes constraints of
the following form:</p>
<ul>
<li>Difference constraints between variables with an integer bound: <code>x - y ≤ k</code>
    where <code>k</code> is an integer</li>
<li>Constraints of the form <code>x - y - z ≤ k</code> where <code>k</code> is an integer</li>
</ul>
<p>In the SDC scheduler, we use <code>x - y ≤ k</code> constraints to express causality and
timing constraints, whereas <code>x - y - z ≤ k</code> constraints are used to constrain
the lifetime variables to be equal to the difference between the max user cycle
and the cycle of a given node.</p>
<div class="footnote">
<hr />
<ol>
<li id="scheduling-fn:lifetime">
<p>The lifetime of a node is the interval starting at the cycle number
assigned to the node and ending at the maximum cycle number of the
users of the node.&#160;<a class="footnote-backref" href="#scheduling-fnref:lifetime" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><section class="print-page" id="delay_estimation"><h1 id="delay_estimation-delay-estimation-methodology">Delay Estimation Methodology</h1>
<h2 id="delay_estimation-context">Context</h2>
<p>This doc describes the delay estimation methodology used in XLS and related
background.</p>
<p>Estimating delays through networks of CMOS gates is a rich topic, and Static
Timing Analysis (STA) is used in chip backend flows to ensure that, even for
parts operating at the tail end of the distribution, chips continue to function
as specified logically in the netlist.</p>
<p>In stark contrast to something with very concrete constraints, like a
"post-global routing, high-accuracy parasitics static timing analysis", the HLS
tool needs to estimate at a high level, reasonably near to the user's behavioral
specification, what delay HLS operations will have when they are "stacked on
top" of each other in a data dependent fashion in the design.</p>
<p>This information lets the HLS tool schedule operations into cycles without
violating timing constraints; e.g. if the user specifies 1GHz (= 1000ps) as
their target clock frequency, the HLS tool may choose to pack as much data
dependent work into the 1000ps budget (minus clock uncertainty) as it can on any
given cycle.</p>
<p>Although what we're estimating is a close relative of Static Timing Analysis,
the fact it's being analyzed at a very high level presents a different set of
tradeoffs, where <strong>coarse granularity estimation</strong> and <strong>conservative bounds</strong>
are more relevant. Fine-grained / precise analyses are used later in the chip
design process, in the backend flows, but the HLS tool acts more like an RTL
designer, creating an RTL output that early timing analysis deems acceptable.</p>
<p>Notably, we don't want to be <em>too</em> conservative, as being conservative on timing
can lead to designs that take more area and consume more power, as the flops
introduced by additional pipeline stages are significant. We want to be as
accurate as possible while providing a good experience of being able to close
timing quickly (say, in a single pass, or with a small number of iterations in
case of a pathological design).</p>
<h2 id="delay_estimation-background">Background</h2>
<h3 id="delay_estimation-what-xls-is-compiling">What XLS is compiling</h3>
<p>XLS currently supports feed-forward pipelines -- once the user program is
unrolled into a big "sea of nodes" we must schedule each of those operations
(represented by nodes) to occur in a cycle.</p>
<p>It seems clear that an operation like <code>add(bits[32], bits[32]) -&gt; bits[32]</code>
takes some amount of time to produce a result -- we need to be able to determine
what that amount of time is for packing that operation into a given cycle.
<sup><a href="#delay_estimation-footnote1">1</a></sup> Note that XLS operations are parametric in their
bitwidth, so <code>add(bits[17], bits[17]) -&gt; bits[17]</code> is just as possible as a
value like <code>32</code>. This ain't C code.</p>
<p><a name='footnote1'>1</a>: Note that we currently pack operations into cycles
atomically -- that is, we don't break an <code>add</code> that would straddle a cycle
boundary into <code>add.first_half</code> and <code>add.second_half</code> automatically to pull
things as early as possible in the pipeline, but this is future work of
interest. Ideally operations would be described structurally in a way that could
automatically be cut up according to available delay budget. This would also
permit operations in the IR that take more than a single cycle to produce a
value (currently they would have to be "legalized" into operations that fit
within a cycle, but that is not yet done, the user will simply receive a
scheduling error).</p>
<p>Some operations, such as <code>bit_slice</code> or <code>concat</code> are just wiring "feng shui";
however, they still have some relevance for delay calculations! Say we
concatenate a value with zeros for zero extension. Even if we could schedule
that in "cycle 0", if the consumer can only be placed in "cycle 1", we would
want to "sink" the concat down into "cycle 1" as well to avoid unnecessary
registers being materialized sending the zero values from "cycle 0".</p>
<h3 id="delay_estimation-the-delay-problem">The delay problem</h3>
<p>Separately from XLS considerations, there are fundamental considerations in
calculating the delay through clouds of functional logic in (generated) RTL.</p>
<p>Between each launching and capturing flop is a functional network of logic
gates, implemented with standard cells in our ASIC process flows. Chip designs
target a particular clock frequency as their operating point, and the functional
network has to produce its output value with a delay that meets the timing
constraint of the clock frequency. The RTL designer typically has to iterate
their design until:</p>
<p>timing path delay &lt;= target clock period - clock uncertainty</p>
<p>For all timing paths in their design, where clock uncertainty includes
setup/hold time constraints, and slop that's built in as margin for later
sources of timing variability (like instantiating a clock tree, which can skew
the clock signal observed by different flops).</p>
<p>In a reasonable model, gate delay is affected by a small handful of properties,
as reflected in the "(Method of) Logical Effort" book:</p>
<ul>
<li>The transistor network used to implement a logic function (AKA logical
  effort): on an input pin change, the gate of each transistor must be driven to
  a point it recognizes whether a 0 or 1 voltage is being presented. More gates
  to drive, or larger gates, means more work for the driver.</li>
<li>The load being driven by the logic function (AKA electrical effort): fanning
  out to more gates generally means more work to drive them all to their
  threshold voltages. Being loaded down by bigger gates means more work to drive
  it to its threshold voltage.</li>
<li>Parasitic delays: RC elements in the system that leech useful work, typically
  in a smaller way compared to the efforts listed above.</li>
</ul>
<p>The logical effort book describes a way to analyze the delays through a network
of gates to find the minimal delay, and size transistors in a way that can
achieve that minimal delay (namely by geometrically smoothing the ability for
gate to drive capacitance).</p>
<p>Confounding factors include:</p>
<ul>
<li>Medium/large wires: sizing transistors to smooth capacitance becomes difficult
  as fixed-capacitance elements (wires) are introduced. It seems that small
  wires have low enough capacitance they can generally be treated as parasitic.</li>
<li>Divergence/reconvergence in the functional logic network (as a DAG). Different
  numbers of logic levels and different drive currents may be presented from
  different branches of a fork/join the logic graph, which forces delay analysis
  into a system of equations to attempt to minimize the overall delay, as
  observed by the critical path, with transistor sizing and gate choices. (Some
  simplifications are possible, like buffering non-critical paths until they
  have the same number of logic levels so they also have plenty of current to
  supply at join points.)</li>
</ul>
<p>Somewhat orthogonal to the analytical modeling problem, there are also several
industry standards for supplying process information to Static Timing Analysis
engines for determining delay through a netlist. This information is often given
in interpolated tables for each standard cell, for example in the NLDM model
describing how delay changes as a function of input transition time and load
(load capacitance).</p>
<p>These models and supplied pieces of data are important to keep in mind for
contrast, as we now ignore it all and do something very simple.</p>
<h2 id="delay_estimation-simple-delay-estimation">Simple Delay Estimation</h2>
<p>Currently, XLS delay estimation follows a conceptually simple procedure:</p>
<ul>
<li>
<p>For every operation in XLS (e.g. binary addition):</p>
<ul>
<li>For some relevant-seeming set of bitwidths; e.g. <code>{2, 4, 8, 16, ...,
    2048}</code></li>
<li>Find the maximum frequency at which that operation closes timing at that
    bitwidth, in 100MHz units as determined by the synthesis tool.
    <sup><a href="#delay_estimation-footnote2">2</a></sup> Call the clock period for this frequency
    <code>t_best</code>. (Note that we currently just use a single process corner /
    voltage for this sweep.)</li>
<li>Subtract the clock uncertainty from <code>t_best</code>.</li>
<li>Record that value in a table (with the keys of the table being operation
    / bitwidth).</li>
</ul>
</li>
</ul>
<p><a name='footnote2'>2</a>: The timing report can provide the delay through a
path at any clock frequency, but a wrinkle is that synthesis tools potentially
only start using their more aggressive techniques as you bump up against the
failure-to-close-timing point -- there it'll be more likely to change the
structure of the design to make it more delay friendly. The sweep helps to try
to cajole it in that way.</p>
<p>Inspecting the data acquired in this way we observe all of the plots consist of
one or more the following delay components:</p>
<ul>
<li>Constant as a function of bitwidth for a given op (e.g. binary-or just
    requires a single gate for each bit regardless of the width of the inputs).</li>
<li>Logarithmic as a function of bitwidth (e.g. adders may end up using
    tree-like structures to minimize delay, single-selector muxes end up using a
    tree to fan out the selector to the muxes, etc.).</li>
<li>Linear as a function of bitwidth (e.g., ripple-carry adders and some
    components of multipliers).</li>
</ul>
<p>So given this observation we fit a curve of the form:</p>
<div class="highlight"><pre><span></span><code>a * bitwidth + b * log_2(bitwidth) + c
</code></pre></div>
<p>to the sweep data for each operation, giving us <code>(a, b, c)</code> values to use in our
XLS delay estimator.</p>
<p>The utility <code>delay_model_visualizer</code> under the <code>tools</code> directory renders a graph
of the delay model estimate against the measured data points. This graph for add
shows a good correspondence to the measured delay.</p>
<p><img alt="drawing" src="../add2_delay_plot.png" /></p>
<h3 id="delay_estimation-sweeping-multiple-dimensions">Sweeping multiple dimensions</h3>
<p>Operations with attributes in addition to bitwidth that affect delay are swept
across multiple dimensions. An example is <code>Op::kOneHotSelect</code> which has
dimensions of bitwidth and number of cases. For the <code>Op::kOneHotSelect</code> example
the formula is:</p>
<div class="highlight"><pre><span></span><code>a * bitwidth + b * log_2(bitwidth) + c * (# of cases) + d * log_2(# of cases) + c
</code></pre></div>
<p>Below is plot of delay for <code>Op::kOneHotSelect</code> showing the two dimensions of
bitwidth and operand count affecting delay:</p>
<p><img alt="drawing" src="../one_hot_sel_delay_plot.png" /></p>
<h3 id="delay_estimation-sources-of-pessimismoptimism">Sources of pessimism/optimism</h3>
<p>This simple method has both sources of optimism and pessimism, though we hope to
employ a method that will be generally conservative, so that users can easily
close timing and get a close-to-best-achievable result (say, within tens of
percent) with a single HLS iteration.</p>
<p>Sources of pessimism (estimate is conservative):</p>
<ul>
<li>The operation sweeps mentioned are not bisecting to the picosecond, so there
    is inherent slop in the measurement on account of sweep granularity.</li>
<li>We expect, in cycles where multiple dependent operations are present, there
    would be "K-map style" logic reductions with adjacent operations. For
    example, because we don't do cell library mapping in XLS delay estimation,
    something a user wrote that mapped to an AOI21 cell would be the sum of
    (and+or+invert) delays.</li>
<li>[Unsure] May there be additional logic branch splitting options and
    earlier-produced results available to the synthesis tool when there are more
    operations in the graph (vs a lone critical path measured for a single
    operation)?</li>
</ul>
<p>Sources of optimism (estimate is overeager):</p>
<ul>
<li>For purposes of the sweep the outputs of an operation are only loaded by a
    single capture flop flop -- when operations have fanout the delay will
    increase.<p>Note that we do account for fanout <em>within</em> individual operations as part of
  this sweep; e.g. a 128-bit selector fanout (e.g. 128 ways to 128 muxes) for
  a select is accounted for the in delay timing of the select operation. It is
  the <em>output</em> logic layer that is only loaded by a single flop in our
  characterization. Notably because most of these operations turn into trees
  of logic, there are <span class="arithmatex">\(<span class="arithmatex">\(log_2(bitcount)\)</span>\)</span> layers of logic in which we can
  potentially smoothly increase drive strength out to the output logic layer,
  and paths can presumably be replicated by synthesis tools to reduce
  pointwise fanout when multiple high-level operations are data-dependent
  within a cycle. (Is it <em>possible</em> for a user to break up their 32-bit select
  into bitwise pieces in their XLS code to mess with our modeling? Sure, but
  probably not too expected, so we're currently sort of relying on the notion
  people are using high level operations instead of compodecomposing them into
  bitwise pieces in our graph.)</p>
<p>A potential way to reconcile this output fanout in the future is to do a
  delay sweep with a high-capacitive fanout (e.g. four flops of load) and then
  ensure the IR has a maximum fanout of four for our delay estimation.</p>
</li>
</ul>
<ul>
<li>Wiring delay / load / congestion / length are not estimated. This will need
    additional analysis / refinement as we run XLS through synthesis tools with
    advanced timing analysis, as it is certainly not viable for arbitrary
    designs (tight pipelines may be ok for now, though).</li>
</ul>
<h3 id="delay_estimation-iterative-refinement">Iterative refinement</h3>
<p>The caveats mentioned above seem somewhat daunting, but this first cut approach
appears to work <em>comfortably</em> at target frequenties, in practice, for the
real-world blocks being designed as XLS "first samples".</p>
<p>Notably, human RTL designers fail to close timing on a first cut as well -- HLS
estimations like the above assist in getting a numeric understanding (in lieu of
an intuitive guess) of something that may close timing on a first cut. As this
early model fails, we will continue to refine it; however, there is also a
secondary procedure that can assist as the model improves.</p>
<p>Let's call the delay estimation described above applied to a program a
<em>prediction</em> of its delays. Let's call the first prediction we make <code>p0</code>: <code>p0</code>
will either meet timing or fail to meet timing.</p>
<p>When we meet timing with <code>p0</code>, there may be additional wins left on the table.
If we're willing to put synthesis tool runs "in the loop" (say running a "tuner"
overnight), we can refine XLS's estimates according to the realities of the
current program, and, for example, try to squeeze as much as possible into as
few cycles as possible if near-optimality of latency/area/power were a large
consideration. This loop would generate <code>p1</code>, <code>p2</code>, ... as it refined its model
according to empirical data observed from the synthesis tool's more refined
analysis.</p>
<p>When we fail to close timing with <code>p0</code>, we can feed back the negative slack
delays for comparison with our estimates and relax estimates accordingly.
Additionally, an "aggression" knob could be implemented that backs off delay
estimations geometrically (say via a "fudge factor" coefficient) in order to
ensure HLS developer time is not wasted unnecessarily to ensure. Once a
combination of these mechanisms has obtained a design that closes timing, the
"meeting timing, now refine" procedure can be employed as described above.</p>
<h3 id="delay_estimation-on-hints">On Hints</h3>
<p>To whatever extent possible, XLS should <em>be</em> the tool that reasons about how to
target the backend (vs having a tool that sits on top of it and messes with XLS'
input in an attempt to achieve a result). User-facing hint systems are typically
very fragile, owing to the fact they don't have easily obeyed semantics. XLS, by
contrast, knows about its own internals, so can do things with awareness of
what's happened upstream and what remains to happen downstream.</p>
<p>By contrast, we <strong>should</strong> continue to add ways for users to provide more
semantic information / intent as part of their program (e.g. via more high-level
patterns that make high level structure more clear), and make XLS smarter about
how to lower those constructs into hardware (and why it should be lowering them
that way) in the face of some prioritized objectives (power/area/latency).</p>
<p>That being said, because we're probably trying to produce hardware at a given
point in time against a given technology, it likely makes sense to permit human
users to specify things directly (at a point in time), even if those
specifications might be ignored / handled very differently in the future or
against different technology nodes. This would be the moral equivalent of what
existing EDA tools do as a "one-off TCL file" used in a particular design, vs
something carried from design to design. Recall, though, that the intent of XLS
is to make things easier to carry from design to design and require fewer
one-off modifications!</p>
<h2 id="delay_estimation-tools">Tools</h2>
<p>XLS provides tools for analyzing its delay estimation model. (Note that the
given IR should be in a form suitable for code generation; e.g. it has run
through the <code>opt_main</code> binary).</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/tools:benchmark_main -- $PWD/bazel-bin/xls/examples/crc32.opt.ir --clock_period_ps=500 --delay_model=sky130
&lt;snip&gt;
Critical path delay: 8351ps
Critical path entry count: 43
Critical path:
   8351ps (+ 21ps): not.37: bits[32] = not(xor.213: bits[32], id=37, pos=[(0,30,51)])
   8330ps (+128ps): xor.213: bits[32] = xor(concat.203: bits[32], and.222: bits[32], id=213, pos=[(0,25,19)])
   8202ps (+ 81ps): and.222: bits[32] = and(mask__7: bits[32], literal.395: bits[32], id=222, pos=[(0,25,33)])
   8121ps (+621ps)!: mask__7: bits[32] = neg(concat.199: bits[32], id=202, pos=[(0,24,15)])
   7330ps (+  0ps): concat.199: bits[32] = concat(literal.387: bits[31], bit_slice.198: bits[1], id=199, pos=[(0,24,21)])
   7330ps (+  0ps): bit_slice.198: bits[1] = bit_slice(xor.196: bits[32], start=0, width=1, id=198, pos=[(0,24,21)])
   7330ps (+128ps): xor.196: bits[32] = xor(concat.194: bits[32], and.221: bits[32], id=196, pos=[(0,25,19)])
   7202ps (+ 81ps): and.221: bits[32] = and(mask__6: bits[32], literal.394: bits[32], id=221, pos=[(0,25,33)])
&lt;snip&gt;
</code></pre></div>
<p>In addition to the critical path, the cycle-by-cycle breakdown of which
operations have been scheduled is provided in stdout.</p></section><h1 class='nav-section-title-end'>Ended: Scheduling</h1><section class="print-page" id="ir_visualization"><h1 id="ir_visualization-ir-visualization">IR Visualization</h1>
<p>The XLS IR visualization
<a href="https://github.com/google/xls/tree/main/xls/visualization/ir_viz/app.py">web app</a>
presents the IR in text and graphical form side-by-side and enables interactive
exploration of the IR.</p>
<h2 id="ir_visualization-running-the-web-app">Running the web app</h2>
<p>To build and launch the IR visualization web app run:</p>
<div class="highlight"><pre><span></span><code>bazel<span class="w"> </span>run<span class="w"> </span>-c<span class="w"> </span>opt<span class="w"> </span>//xls/visualization/ir_viz:app<span class="w"> </span>--<span class="w"> </span>--delay_model<span class="o">=</span>unit
</code></pre></div>
<p>Then visit <a href="http://localhost:5000">http://localhost:5000</a> in a browser.</p>
<h2 id="ir_visualization-screenshot">Screenshot</h2>
<p>The screenshot below shows a zoomed-in portion of the IR graph for the
<code>fp_adder</code> benchmark. The highlighted path in blue is the timing critical path
the through the graph.</p>
<p><img alt="XLS IR Visualization" src="../fp_adder_viz.png" /></p>
<h2 id="ir_visualization-usage">Usage</h2>
<h3 id="ir_visualization-text-ir">Text IR</h3>
<p>The left hand side of the UI shows the IR in text form in an editable text box.
The IR may be entered or loaded in several ways:</p>
<ul>
<li>Upload from a file on the local file system via the <strong>Upload</strong> button.</li>
</ul>
<ul>
<li>Enter directly by typing in the text box or cut and pasting.</li>
</ul>
<ul>
<li>Load a pre-compiled benchmark via the <strong>Benchmarks</strong> button. The IR is from
    the benchmark after optimizations.</li>
</ul>
<p>The text IR is parsed as you type. The result of the parse (<strong>OK</strong> or an error)
appears in an alert at the bottom of the text box. On successful parsing all
identifiers in the IR will be shown in bold.</p>
<h3 id="ir_visualization-ir-graph">IR graph</h3>
<p>The right-hand side of the UI shows the IR in graphical form. Clicking on the
<strong>View Graph</strong> button renders the text IR on the left hand side as a graph. The
<strong>View Graph</strong> button is enabled only if the IR is parsed successfully. The
graph view may be manipulated as follows:</p>
<ul>
<li><strong><em>Zoom</em></strong> The mouse scroll wheel zooms the view of the IR graph.</li>
</ul>
<ul>
<li><strong><em>Pan</em></strong> Clicking and holding the left mouse button down in the graph panel
    (while not on a graph element) and moving the mouse pans the graph.</li>
</ul>
<ul>
<li><strong><em>Moving nodes</em></strong> Nodes in the graph are moved by clicking and holding on
    the node and moving the mouse.</li>
</ul>
<ul>
<li><strong><em>Focusing on nodes</em></strong> Clicking on a node in the graph while holding down
    the control key scrolls the respective definition of the node in the text IR
    into view in the text box. Similarly, control clicking on an identifier in
    the text IR zooms and centers the graph view on the respective node.</li>
</ul>
<h4 id="ir_visualization-node-colors">Node colors</h4>
<p>Every node in the graph is assigned a color on a spectrum from white (<code>#FFFFFF</code>)
to red (<code>#FF0000</code>) depending on the modeled latency of the operation. The nodes
with the longest latency in the graph are assigned red. Nodes with zero latency
are assigned white.</p>
<h3 id="ir_visualization-hovering-on-ir-elements">Hovering on IR elements</h3>
<p>Hovering on nodes and edges in the graph highlights the corresponding element in
the text IR and vice versa. In the text IR, the definition and all uses of the
IR value are highlighted when a node is highlighted. When a graph edge is
highlighted, the definition and corresponding use are highlighted in the text
IR.</p>
<p>Information about a highlighted node (identifier in text IR) is displayed in a
box above the IR graph. This information includes:</p>
<ul>
<li>The definition of the IR value in text form.</li>
</ul>
<ul>
<li>Estimate of the delay in picoseconds of the corresponding operation. The
    delay estimation methodology is described <a href="#delay_estimation">here</a>.</li>
</ul>
<ul>
<li>Any known bits of the value as determined by the query engine
    (https://github.com/google/xls/tree/main/xls/passes/query_engine.h).</li>
</ul>
<h3 id="ir_visualization-selecting-nodes">Selecting nodes</h3>
<p>Nodes in the graph may be in a selected or deselected state. Clicking on a node
in the graph or identifier in the text IR toggles the selection state. A
selected node (identifier in IR text) is shown with a blue border. Nodes and
edges which are neighbors of selected nodes (the selection frontier) are shown
in orange.  Clicking on an empty area of the graph deselects all nodes.</p>
<h4 id="ir_visualization-showing-only-selected-nodes">Showing only selected nodes</h4>
<p>The toggle <strong>Show only selected nodes</strong> controls whether to show the entire
graph or only the selected node and those elements in the selection frontier.
Showing only selected nodes can be used to display only a subgraph of interest.
For large graphs which are slow to render in their entirety, this mechanism can
be used to interactively explore parts of the graph.</p>
<p>When showing only selected nodes, the graph maybe be expanded by selecting
additional nodes to add to the graph. The graph is re-rendered to include the
newly selected node. Similarly, nodes may be removed from the graph by
deselecting nodes.</p>
<h4 id="ir_visualization-selecting-the-critical-path">Selecting the critical path</h4>
<p>The button <strong>Critical Path</strong> selects exactly those nodes which are on the
critical path as determined by XLS's timing model. This may be used with the
<strong>Show only selected nodes</strong> toggle to show a graph containing only critical
path elements and neighbors. In the screenshot above, the selected critical
path is shown in blue.</p></section>
                        <h2 class='nav-section-title' id='section-native-jit'>
                            Native JIT <a class='headerlink' href='#section-native-jit' title='Permanent link'>↵</a>
                        </h2>
                        <section class="print-page" id="ir_jit"><h1 id="ir_jit-ir-jit-compiler">IR JIT Compiler</h1>
<div class="toc">
<ul>
<li><a href="#ir_jit-ir-jit-compiler">IR JIT Compiler</a><ul>
<li><a href="#ir_jit-usage">Usage</a><ul>
<li><a href="#ir_jit-specialized-matching">Specialized matching</a></li>
<li><a href="#ir_jit-direct-usage">Direct usage</a></li>
</ul>
</li>
<li><a href="#ir_jit-design">Design</a><ul>
<li><a href="#ir_jit-arg-passing">Arg passing</a></li>
<li><a href="#ir_jit-arrayindex">ArrayIndex</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>XLS provides a JIT compiler for evaluating functions written in the [XLS]
compiler intermediate representation (IR) at native machine speed.</p>
<h2 id="ir_jit-usage">Usage</h2>
<p>Given a DSLX file and build target, one can build and run it through the JIT by:</p>
<ol>
<li>Declaring a
    <a href="https://github.com/google/xls/tree/main/xls/build_rules/xls_build_defs.bzl"><code>cc_xls_ir_jit_wrapper</code></a>
    target matching the DSLX build target.</li>
<li>Creating a JIT object and calling its <code>Run()</code> method. Using the 2-way
    floating-point adder as an example:<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="cp">#</span><span class="w"> </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&quot;xls/modules/fpadd_2x24_jit_wrapper.h&quot;</span>

<span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">StatusOr</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">Value</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="c1">// Only create this once and re-use it; it&#39;s created here just as</span>
<span class="w">   </span><span class="c1">// an illustration.</span>
<span class="w">   </span><span class="n">XLS_ASSIGN_OR_RETURN</span><span class="p">(</span><span class="n">Fpadd2x32</span><span class="w"> </span><span class="n">adder</span><span class="p">,</span><span class="w"> </span><span class="n">Fpadd2x32</span><span class="o">::</span><span class="n">Create</span><span class="p">());</span><span class="w"> </span><span class="k">return</span>
<span class="w">   </span><span class="n">adder</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>
</code></pre></div>
</li>
</ol>
<p>The advantages of JIT compilation (or any compilation, for that matter) only
come into play when repeatedly using the compiled object, so programs should be
structured to create a JIT wrapper once and to reuse it many times, e.g., to
test a module across many - or even exhaustively, across all possible - inputs.</p>
<h3 id="ir_jit-specialized-matching">Specialized matching</h3>
<p>In many cases, the types used by DSLX designs map to native types, such as the
C/C++ <code>float</code>. In that case, a simplified wrapper call is available:</p>
<div class="highlight"><pre><span></span><code>#include &quot;xls/modules/fpadd_2x24_jit_wrapper.h&quot;

absl::StatusOr&lt;float&gt; foo(float a, float b) {
  ...
  // Only create this once and re-use it; it&#39;s created here just as
  // an illustration.
  XLS_ASSIGN_OR_RETURN(Fpadd2x32 adder, Fpadd2x32::Create());
  return adder.Run(a, b);
}
</code></pre></div>
<p>When available, these simplified wrappers should be used for higher performance
(~30% in our measured cases). Currently, floats and integral types &gt;= 64 bits in
this way. For non-native integral types, the generated wrapper will accept the
next larger native type e.g., <code>uint64_t</code> for <code>bits[47]</code>. Proper operation with
next-larger types depends on the input value being present in the
least-significant bits of the containing type.</p>
<p>These are higher performance because they avoid unnecessary marshaling of these
types into Views (e.g., a <code>float</code> outside the JIT -&gt; View -&gt; <code>float</code> inside the
JIT).</p>
<h3 id="ir_jit-direct-usage">Direct usage</h3>
<p>The JIT is also available as a library with a straightforward interface:</p>
<div class="highlight"><pre><span></span><code>absl::StatusOr&lt;Value&gt; RunOnJit(
    Function* function, absl::Span&lt;const Value&gt; args) {
  XLS_ASSIGN_OR_RETURN(auto jit, FunctionJit::Create(function));
  return jit-&gt;Run(args);
}
</code></pre></div>
<p>The IR JIT is the default backend for the
<a href="#tools-eval-ir-main">eval_ir_main</a>
tool, which loads IR from disk and runs with args present on either the command
line or in a specified file.</p>
<h2 id="ir_jit-design">Design</h2>
<p>Internally, the JIT converts XLS IR to LLVM IR and uses
<a href="https://llvm.org/docs/ORCv2.html">LLVM's ORC infrastructure</a> to convert that
into native machine code. The details of compiling an LLVM IR program with ORC
are mostly generic and are available online - here are discussed details
specific to our usage in XLS.</p>
<p>XLS IR is converted to LLVM IR by recursively visiting every node in a function
using the DfsVisitor functions. Most nodes have relatively straightforward
implementations, e.g., in Concat, we create an empty value with the combined
width of the operands, and each is shifted and blitted into that value to
produce the result. Some operations, though, merit more discussion.</p>
<h3 id="ir_jit-arg-passing">Arg passing</h3>
<p>When LLVM JIT-compiles a program, the resulting value is simply a function
pointer to the requested entry point (that can be called like any function
pointer). Calling such a function pointer with concrete-typed arguments, though,
is difficult: one must either make heavy [ab]use of C++ templates or "hide" the
argument types behind an opaque pointer. The latter approach is taken here.</p>
<p>When a compiled function is invoked (via <code>FunctionJit::Run()</code>), the typed input
args are "packed" into an opaque byte buffer which is passed into the new
function. Inside there, any references to an argument (via
<code>DfsVisitor::HandleParam()</code>) calculate the offset of that param in the opaque
buffer and load from there appropriately (this should happen at most once per
arg; LLVM and/or XLS should optimize away redundant loads).</p>
<p>A special case is for function invocations (inside the JITted function): for
these, the arguments already exist inside "LLVM-space", so there's no need for
unpacking args, so <code>LlvmFunction::getArg()</code> can be used as usual.</p>
<p>Results must be handled in a similar way - they could be of any type and will
need to be packed inside XLS types before returning, so there's a corresponding
argument unpacking phase at function exit.</p>
<p>For both packing and unpacking, LLVM's DataLayout must be used to determining
where input and output values will be placed, as LLVM will use those conventions
when, e.g., loading values from a struct.</p>
<h3 id="ir_jit-arrayindex">ArrayIndex</h3>
<p>IRBuilder provides three means of extracting values from an aggregate type:</p>
<ol>
<li><code>CreateGEP</code>: these use the getelementptr instruction, which requires a
    pointer-typed value (not the same thing as an array!). This requires holding
    a value in a specially-created allocation (via <code>CreateAlloca()</code> or in an
    input buffer).</li>
<li><code>CreateExtractElement</code>: returns the value at a given index in a
    <em>vector</em>-typed value.</li>
<li><code>CreateExtractValue</code>: returns the value at a given <em>constant index</em> in an
    aggregate value.</li>
</ol>
<p>Unfortunately, #2 doesn't apply, as arrays aren't LLVM vectors, and #3 doesn't
apply, as an array index isn't necessarily a constant value. Uniformly managing
arrays as allocas doesn't scale well (consider the case of arrays of arrays of
tuples...), so for <code>ArrayIndex</code> nodes, we lazily create allocas for <em>only the
array of interest</em> and load the requested index from there.</p></section><section class="print-page" id="data_layout"><h1 id="data_layout-data-layout">Data layout</h1>
<p>For many uses, XLS types exist within their own conceptual space or domain, so
"portability" concerns don't exist. When interacting with the JIT, however, XLS
and host-native types must interact, so the data layouts of both must be
understood and possibly reconciled.</p>
<div class="toc">
<ul>
<li><a href="#data_layout-data-layout">Data layout</a><ul>
<li><a href="#data_layout-xls-data-layout">XLS data layout</a></li>
<li><a href="#data_layout-host-data-layout">Host data layout</a></li>
<li><a href="#data_layout-jit-data-layout">JIT data layout</a></li>
<li><a href="#data_layout-packed-views">Packed views</a><ul>
<li><a href="#data_layout-tuple-types">Tuple types</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="data_layout-xls-data-layout">XLS data layout</h2>
<p>The concrete XLS <a href="https://github.com/google/xls/tree/main/xls/ir/bits.h"><code>Bits</code></a> type is
the ultimate container of actual data for any XLS IR type: tuples and arrays may
be contain any number of tuple, array, or bits types, but whatever the layout of
the type tree, all leaf nodes are Bits. When accessing the underlying storage of
a <code>Bits</code> via the <code>ToBytes()</code> member function, the results are returned in a
little-endian layout, i.e, with the least-significant data elements stored in
the lowest addressable location. For example, the 32-bit value 12,345,678
(0xBC614E), would be returned as:</p>
<div class="highlight"><pre><span></span><code>High  &lt;--  Low
0x 00 BC 61 4E
</code></pre></div>
<h2 id="data_layout-host-data-layout">Host data layout</h2>
<p>Different architectures can use different native layouts. For example, x86 (and
descendants) use little-endian (i.e., <code>0x00 BC 61 4E</code>), and modern ARM can be
configurable as either. (There are actually other layouts, but they're best left
to the dustbin of history).</p>
<h2 id="data_layout-jit-data-layout">JIT data layout</h2>
<p>From the above, we can see that XLS' native layout differs from that of most
modern hosts. When compiling XLS code, the [LLVM] JIT understandably uses the
host's native layout. What this means is that any data fed into the JIT from XLS
will need to be byte-swapped before ingestion.</p>
<p>For Value or unpacked view input, this swapping is handled automatically, in
<code>LlvmIrRuntime::PackArgs()</code> (via <code>LlvmIrRuntime::BlitValueToBuffer()</code>) - and the
__un__swapping is also automatically performed in <code>LlvmIrRuntime::UnpackBuffer()</code>.
Thus, for these uses, no special action is required of the user.</p>
<h2 id="data_layout-packed-views">Packed views</h2>
<p><em>However</em>, this is not the case for use of packed views. The motivating use case
for packed views is to allow users to map native types directly into JIT-usable
values - for example, to use an IEEE float32 (e.g., a C <code>float</code>) <em>directly</em>,
without needing to be exploded into a <code>bits[1]</code> for the sign, a <code>bits[8]</code> for
the exponent, and a <code>bits[23]</code> for the fractional part.</p>
<p>When creating a packed view from a C <code>float</code>, no special action is needed - that
<code>float</code> is in native host layout, which is the layout used by the JIT. If,
however, data is coming from XLS (perhaps a <code>float</code> converted into a Value,
manipulated in some way, then passed into the JIT), then the <em>user</em> must un-swap
the bits back to native layout. This is because the JIT has no way of knowing
the provenance of that data (if it's from a native type or XLS), so it's up to
the provider of that data to ensure proper layout.</p>
<p>Distilled into a simple rule of thumb: if packed view data is coming from XLS,
it needs to be byte swapped before being passed into the JIT.</p>
<h3 id="data_layout-tuple-types">Tuple types</h3>
<p>Another wrinkle is the usage of packed tuple views. When XLS emits a tuple type
in Verilog, the first element in the tuple declaration is placed in the most
significant bits, and so on, with the last-declared element placed in the least
significant bits. To match this layout, PackedTupleView elements must be also
declared from most significant to least significant element. This way, when
running on a host, the in-memory layout of input data matches that expected by
XLS tools. That means, using the usual float32 example, that the packed view
declaration is:</p>
<div class="highlight"><pre><span></span><code>PackedTupleView&lt;PackedBitsView&lt;1&gt;, PackedBitsView&lt;8&gt;, PackedBitsView&lt;23&gt;&gt;
</code></pre></div>
<p>(The non-packed-View tuple declaration is much the same, but matters less, as it
doesn't directly correspond to in-memory data layout.)</p>
<p>Be aware of this layout when accessing elements in a PackedTupleView. In the
float32 above, accessing element 0 yields the sign bit (the most significant bit
in memory), and accessing element 2 yields the fractional part (the least
significant 23 bits in memory), as one would expect given the tuple type
declaration order.</p>
<p>While this may initially seem confusing, it suffices to remember that
PackedTupleView element declaration order is the "reverse" of the in-memory
order; refer to
<a href="https://github.com/google/xls/tree/main/xls/ir/value_view_test.cc">value_view_test.cc</a>
and
<a href="https://github.com/google/xls/tree/main/xls/jit/function_jit_test.cc">function_jit_test.cc</a>
for test examples, or the [generated] float32_add_jit_wrapper.h/cc and
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/float32_add_test.cc">float32_add_test.cc</a>
for practical usage.</p></section><h1 class='nav-section-title-end'>Ended: Native JIT</h1><section class="print-page" id="solvers"><h1 id="solvers-xls-solvers">XLS Solvers</h1>
<p>Programs that are represented as optimized XLS IR are converted into circuits
based on boolean logic, and so it is also possible to feed those as logical
operations to a theorem prover.</p>
<p>We have implemented that conversion with the Z3 theorem prover using its "bit
vector" type support. As a result, you can conceptually ask Z3 to prove any
predicate that can be expressed as XLS, over all possible parameter inputs.</p>
<p>See the
<a href="#tools">tools documentation</a>
for usage information on related command line tools.</p>
<h2 id="solvers-applications">Applications</h2>
<p>This facility is expected to be useful to augment random testing. While
profiling the values in an XLS IR function that is given random stimulus, we may
observe bits that result from nodes that <em>appear</em> to be constant (but are not
created via a "literal" or a "concat" of a literal).</p>
<p><strong>Example:</strong> Say the value resulting from <code>and.1234</code> in the graph appears to be
constant zero with all the stimulus provided via a fuzzer thus far -- the solver
provides a facility whereby we can ask "is there a counterexample to <code>and.1234</code>
always being zero?" and the solver will either say "no, it is always zero", or
it will yield a counterexample, or will not terminate within the allocated
deadline.</p>
<p>Assuming we can prove useful properties in a reasonable amount of time, we can
use this proof capability to help find interesting example inputs that provide
unique stimulus.</p>
<h3 id="solvers-correctness-wrt-reference-32-bit-floating-point-adder">Correctness WRT reference: <a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/float32.x">32-bit Floating-Point Adder</a></h3>
<p>The full input space for a 32-bit adder is a whopping 64 bits - far more than is
possible to exhaustively test for correctness. Proving correctness via Z3,
however, is relatively straightforward: at a high level, one simply compares the
output from the DSLX (translated into Z3) to the same operation performed
solely in Z3.</p>
<p>In detail, the steps are:</p>
<ol>
<li>Translate the DSLX implementation into Z3 via
    <code>Z3Translator::CreateAndTranslate()</code>.</li>
<li>Create a Z3 implementation of the same addition. This is nearly trivial, as
    Z3 helpfully has built-in support for floating-point values and theories.</li>
<li>Take the result nodes from each "branch" above and create a new node
    subtracting the two. This is the absolute error. Note: Usually, one is
    interested in relative error when working with FP values, but here, our
    target is absolute equivalence, so absolute error sufficies (and is
    simpler).</li>
<li>Create a Z3 node comparing that error to the maximum bound (here 0.0f).</li>
<li>Feed that error node into a Z3 solver, asking it to prove that the error
    could be greater than that bound.</li>
</ol>
<p>If the solver can not satisfy that criterion, then that means the error is
<em>never</em> greater than that bound, i.e., that the implementations are equivalent
(with our 0.0f bound).</p>
<h3 id="solvers-ir-transform-validity">IR Transform validity</h3>
<p>It's usually not possible (or is merely extremely difficult) to write tests to
prove that an optimization/transform is safe across all input IR. By comparing
the optimized vs. unoptimized IR in a similar manner as the correctness proof
above, we can symbolically prove safety.</p>
<p>The only difference between this and the correctness proof is that both the
optimized and unoptimized IR need to be fed into the same Z3Translator (the
second via <code>Z3Translator::AddFunction()</code>) and the result nodes each are used in
the error comparison.</p>
<h3 id="solvers-ir-to-netlist-logical-equivalence-checking-lec">IR to netlist Logical Equivalence Checking (LEC)</h3>
<p>After a user design has been lowered to IR, it is optimized (see the previous
section), then Verilog is generated for that optimized IR. That Verilog is then
compiled by an external tool, which, if successful, will output a "netlist" - a
set of standard cells (think AND, OR, NOT, flops, etc.) and wires connecting
them that realizes the design.</p>
<p>Between the IR level and that netlist, many, many transformations are applied to
the design. Before processing the netlist further - and certainly before sending
the final design to fabrication - it's a very good idea to ensure that the
netlist describes the correct logic!</p>
<p>Demonstrating initial design correctness is up to the user, via unit tests or
integration tests at the DSLX level. At all stages below that, though, ensuring
logical equivalence between forms is XLS' responsibility. To prove equivalence
between the IR and netlist forms of a design, XLS uses formal verification via
solvers - currently only Z3, above.</p>
<p>Performing IR-to-netlist LEC is very similar to the checking above - the source
IR is one half of the comparison. Here, the second half is the netlist
translated into IR, which only requires a small amount of extra work. Consider
the snippet below:</p>
<div class="highlight"><pre><span></span><code>FOO p1_and_1 ( .A(p0_i0), .B(p0_i1), .Z(p1_and_1_comb) );
BAR p1_and_2 ( .A(p0_i2), .B(p0_i3), .Z(p1_and_2_comb) );
</code></pre></div>
<p>These lines describe, in order:</p>
<ul>
<li>One cell, called <code>FOO</code>, that takes two inputs, .A and .B, provided by the
    wires <code>p0_i0</code> and <code>p0_i1</code>, respectively, and one output, .Z, which will be
    assigned to the wire `p1_and_1_comb.</li>
<li>One cell, called <code>BAR</code>, that takes two inputs, .A and .B, provided by the
    wires <code>p0_i2</code> and <code>p0_i2</code>, respectively, and one output, .Z, which will be
    assigned to the wire `p1_and_2_comb.</li>
</ul>
<p>Note that the <em>values</em> computed by the cells wasn't mentioned - that's because
<code>FOO</code> and <code>BAR</code> are defined in the "cell library", the list of standard cells
used to generate the netlist. Thus, to be able to model these gates in a solver,
we need to take that cell library as input to the LEC tool. The netlist
describes how cells are laid out, and the cell library indicates what cells
actually <em>do</em>. With both of these in hand, preparing the netlist half of a LEC
is a [relatively] straightforward matter of parsing a netlist and cell library
and converting those together into a description of logic. See
<a href="https://github.com/google/xls/tree/main/xls/solvers/z3_netlist_translator.cc">z3_netlist_translator.cc</a>
for full details.</p>
<h3 id="solvers-utilities">Utilities</h3>
<ul>
<li><a href="https://github.com/google/xls/tree/main/xls/tools/lec_main.cc">tools/lec_main.cc</a>:
    Driver function for performing IR-to-netlist LEC.</li>
</ul>
<h2 id="solvers-current-limitations">Current Limitations</h2>
<h3 id="solvers-time-to-result">Time-to-result</h3>
<p>Under the hood, Z3 (and many other tools in this space) is an
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solver</a>. At a
high level, think of an SMT solver as a SAT solver that has special handling for
certain classes of data (bit vectors, floating-point numbers). Many sufficiently
complicated problems will reduce to raw SAT solving (especially those involving
netlists, which have to implement complex logic at the gate level. Consider what
that means for a multiply, for example!). Since SAT scales exponentially with
the size of its inputs, execution time can quickly grow past a point of utility
for complex operations, notably multiplication. Fortunately, for most designs
(without such complex ops), proving equivalence of a single pipeline stage can
complete in a small amount of time (O(minutes)).</p>
<h3 id="solvers-predicate-coverage">Predicate coverage</h3>
<p>Hypothetically, any XLS function that computes a predicate (bool) can be fed to
Z3 for satisfiability testing. Currently a more limited set of predicates are
exposed that can be easily expressed on the command line; however, it should be
possible to provide:</p>
<ul>
<li>an XLS IR file</li>
<li>a set of nodes in the entry function</li>
<li>a DSLX function that computes a predicate on those nodes</li>
</ul>
<p>Which would allow the user to compute arbitrary properties of nodes in the
function with the concise DSL syntax.</p>
<h3 id="solvers-subroutines">Subroutines</h3>
<p>Z3 doesn't intrinsically have support for subroutines, or as they're called in
Z3, "macros", instead requiring that
<a href="https://stackoverflow.com/questions/7740556/equivalent-of-define-fun-in-z3-api">all function calls be inlined</a>.</p>
<p>There is an extension that adds support for <em>recursive</em> function decls and defs,
but in our experience, it doesn't behave the way we'd expect.</p>
<p>Consider the following example:</p>
<div class="highlight"><pre><span></span><code>package p

fn mapper(value: bits[32]) -&gt; bits[32] {
  ret value
}

fn main() -&gt; bits[1] {
  literal_0: bits[32] = literal(value=0)
  literal_1: bits[1] = literal(value=1)
  elem_0: bits[32] = invoke(literal_0, to_apply=mapper)
  eq_12: bits[1] = eq(literal_0, elem_0)
  ret and_13: bits[1] = and(eq_12, literal_1)
}
</code></pre></div>
<p>Here, it's trivial for a human reader to see that the results are the same; the
output should be equal to 1. Z3, however, reports that this is not necessarily
the case, suggesting that <code>literal_0</code> and <code>elem_0</code> would not be equal in the
case where the input to <code>mapper</code> was 1...which is clearly never the case here.</p>
<p>To address this, we require that all subroutines (including those used in maps
and counted fors) be inlined before consumption by Z3.</p></section><section class="print-page" id="elaboration"><h1 id="elaboration-xls-elaboration">XLS: Elaboration</h1>
<div class="toc">
<ul>
<li><a href="#elaboration-xls-elaboration">XLS: Elaboration</a><ul>
<li><a href="#elaboration-function">Function</a></li>
<li><a href="#elaboration-proc">Proc</a></li>
<li><a href="#elaboration-block">Block</a><ul>
<li><a href="#elaboration-topological-sorting">Topological Sorting</a></li>
<li><a href="#elaboration-visitors">Visitors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>XLS IR has a notion of instantiation and elaboration similar to RTL.<sup id="fnref:1"><a class="footnote-ref" href="#elaboration-fn:1">1</a></sup>
A hierarchy is a directed acyclic graph of elements connected via instantiation.
An elaboration flattens the hierarchy into a tree by walking all paths in the
hierarchy starting at a <code>top</code> proc/block where a path is a chain of
instantiations. The elaboration creates an "instance" object for each path
through the hierarchy from the top proc/block to each IR construct (channel or
instantiation).</p>
<p>This outlines what elaboration looks like for each kind of <code>FunctionBase</code>.</p>
<h2 id="elaboration-function">Function</h2>
<p>Functions are "instantiated" via <code>invoke</code> operations. <code>opt</code> inlines all function
invocations, so there is no separate elaboration of functions.</p>
<h2 id="elaboration-proc">Proc</h2>
<p>New-style procs can instantiate child procs. They have a notion of "channel
references" that are a parent proc can bind to a child proc via instantiation,
which is how procs communicate with the procs they instantiate. These channel
references are bound to channel instances during elaboration.</p>
<p>Example proc hierarchy:</p>
<div class="highlight"><pre><span></span><code>  proc leaf_proc&lt;ch0: ... in, ch1: .... out&gt;(...) { }

  proc other_proc&lt;x: ... in, y: .... out&gt;(...) {
    chan z(...)
    proc_instantiation other_inst0(x, z, proc=leaf_proc)
    proc_instantiation other_inst1(z, y, proc=leaf_proc)
  }

  proc my_top&lt;a: ... in, b: ... out&gt;(...) {
    chan c(...)
    chan d(...)
    proc_instantiation my_inst0(a, b, proc=other_proc)
    proc_instantiation my_inst1(c, c, proc=other_proc)
    proc_instantiation my_inst2(d, d, proc=leaf_proc)
  }
</code></pre></div>
<p>Elaborating this hierarchy from <code>my_top</code> yields the following elaboration tree.
Each line is a instance of either a proc or a channel.</p>
<div class="highlight"><pre><span></span><code> &lt;a, b&gt;my_top
   chan c
   chan d
   other_proc&lt;x=a, y=b&gt; [my_inst0]
     chan z
     leaf_proc&lt;ch0=x, ch1=z&gt; [other_inst0]
     leaf_proc&lt;ch0=z, ch1=y&gt; [other_inst1]
   other_proc&lt;x=c, y=c&gt; [my_inst1]
     chan z
     leaf_proc&lt;ch0=x, ch1=z&gt; [other_inst0]
     leaf_proc&lt;ch0=z, ch1=y&gt; [other_inst1]
   leaf_proc&lt;ch0=d, ch1=d&gt; [my_inst2]
</code></pre></div>
<p>There are five instances of <code>leaf_proc</code> as there are five paths from <code>top_proc</code>
to <code>leaf_proc</code> in the proc hierarchy.</p>
<h2 id="elaboration-block">Block</h2>
<p>Blocks can instantiate:</p>
<ul>
<li>Other blocks</li>
<li>FIFOs</li>
<li>External modules</li>
</ul>
<p>Blocks interact with their instantiations via <code>InstantiationInput</code> and
<code>InstantiationOutput</code> operations, which bind a value to a named port on the
instantiation.</p>
<p>A block elaboration has an instance for each instantiation and builds maps from
parent→child and child→parent ports or instantiation input/output ops.</p>
<h3 id="elaboration-topological-sorting">Topological Sorting</h3>
<p>Elaborated blocks can be topo sorted via <code>ElaboratedTopoSort()</code>. Each element in
the sort is a pair of <code>Node*</code> and <code>BlockInstance*</code>. This means that blocks
instantiated multiple times will have their nodes appear in the sort multiple
times (once for each instantiation).</p>
<p><code>InstantiationInput/InputPort</code> and <code>OutputPort/InstantiationOutput</code> pairs are
treated as edges in the DAG. This is in contrast to the "unelaborated"
<code>TopoSort()</code> function which only produces a topo sort for an isolated <code>Block</code>.
An example use-case of <code>ElaboratedTopoSort()</code> is evaluating IR with dependencies
that span the hierarchy.</p>
<p>Note that our implementations of <code>ElaboratedTopoSort()</code> and <code>TopoSort()</code> produce
the same order for blocks that have no instantiatiations.</p>
<h3 id="elaboration-visitors">Visitors</h3>
<p>In the same way that <code>ElaboratedTopoSort()</code> extends <code>TopoSort()</code> to elaborated
blocks, <code>ElaboratedBlockDfsVisitor</code> extends <code>DfsVisitor</code> to elaborated blocks.
The main difference is the signature for op handlers. For <code>DfsVisitor</code>, they
take the form <code>HandleNodeT(NodeT* node)</code>, but for <code>ElaboratedBlockDfsVisitor</code>
they take the form <code>HandleNodeT(NodeT* node, BlockInstance* instance)</code>.</p>
<p>Like <code>ElaboratedTopoSort()</code>, <code>InstantiationInput/InputPort</code> and
<code>OutputPort/InstantiationOutput</code> pairs are treated as edges in the DAG.</p>
<div class="footnote">
<hr />
<ol>
<li id="elaboration-fn:1">
<p>Note that elaboration is internal to the compiler, users generally don't
need to be aware of or orchestrate an elaboration.&#160;<a class="footnote-backref" href="#elaboration-fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><h1 class='nav-section-title-end'>Ended: IR</h1>
                        <h1 class='nav-section-title' id='section-dslx'>
                            DSLX <a class='headerlink' href='#section-dslx' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="dslx_reference"><h1 id="dslx_reference-dslx-reference">DSLX Reference</h1>
<h3 id="dslx_reference-overview">Overview</h3>
<p>DSLX is a domain specific, dataflow-oriented functional language used to build
hardware that can also run effectively as host software. Within the XLS project,
DSLX is also referred to as "the DSL". The DSL targets the XLS compiler (via
conversion to XLS IR) to enable flows for FPGAs and ASICs.</p>
<p>DSLX mimics Rust, while being an immutable expression-based dataflow DSL with
hardware-oriented features; e.g. arbitrary bitwidths, entirely fixed size
objects, fully analyzeable call graph, etc. To avoid arbitrary new
syntax/semantics choices, the DSL mimics Rust where it is reasonably possible;
for example, integer conversions all follow the same semantics as Rust.</p>
<p>Note: There are <em>some</em> unnecessary differences today from Rust syntax due to
early experimentation, but they are quickly being removed to converge on Rust
syntax.</p>
<p>Note that other frontends to XLS core functionality will become available in the
future; e.g. <a href="https://github.com/google/xls/tree/main/xls/contrib/xlscc">xlscc</a>, for users
familiar with the C++-and-pragma style of HLS computation. XLS team develops the
DSL as part of the XLS project because we believe it can offer significant
advantages over the C++-with-pragmas approach.</p>
<p>Dataflow DSLs are a good fit for describing hardware, compared to languages
whose design assumes
<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">von Neumann style computation</a>
(global mutable state, sequential mutation by a sequential thread of control).
Using a Domain Specific Language (DSL) provides a more hardware-oriented
representation of a given computation that matches XLS compiler (IR) constructs
closely. The DSL also allows an exploration of HLS without being encumbered by
C++ language or compiler limitations such as non-portable pragmas, magic macros,
or semantically important syntactic conventions. The language is still
experimental and likely to change, but it is already useful for experimentation
and exploration.</p>
<p>This document provides a reference for DSLX, mostly by example. Before perusing
it in detail, we recommend you first read the
<a href="#tutorials">DSLX tutorials</a>
to understand the broad strokes of the language.</p>
<p>In this document we use the function to compute a CRC32 checksum to describe
language features. The full code is in
<a href="https://github.com/google/xls/tree/main/xls/examples/dslx_intro/crc32_one_byte.x"><code>examples/dslx_intro/crc32_one_byte.x</code></a>.</p>
<h3 id="dslx_reference-comments">Comments</h3>
<p>Just as in languages like Rust/C++, comments start with <code>//</code> and last through
the end of the line.</p>
<h3 id="dslx_reference-identifiers">Identifiers</h3>
<p>All identifiers, eg., for function names, parameters, and values, follow the
typical naming rules of other languages. The identifiers can start with a
character or an underscore, and can then contain more characters, underscores,
or numbers. Valid examples are:</p>
<div class="highlight"><pre><span></span><code>a                 // valid
CamelCase         // valid
like_under_scores // valid
__also_ok         // valid
_Ok123_321        // valid
_                 // valid

2ab               // not valid
&amp;ade              // not valid
</code></pre></div>
<p>However, we suggest the following <strong>DSLX style rules</strong>, which mirror the
<a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust naming conventions</a>.</p>
<ul>
<li>Functions are <code>written_like_this</code></li>
</ul>
<ul>
<li>User-defined data types are <code>NamesLikeThis</code></li>
</ul>
<ul>
<li>Constant bindings are <code>NAMES_LIKE_THIS</code></li>
</ul>
<ul>
<li><code>_</code> is the "black hole" identifier -- a name that you can bind to but should
    never read from, akin to Rust's wildcard pattern match or Python's "unused
    identifier" convention. It should never be referred to in an expression
    except as a "sink".</li>
</ul>
<p>NOTE Since mutable locals are not supported, there is also
<a href="https://github.com/google/xls/issues/212">support for "tick identifiers"</a>,
where a ' character may appear anywhere after the first character of an
identifier to indicate "prime"; e.g. <code>let state' = update(state);</code>. By
convention ticks usually come at the end of an identifier. Since this is not
part of Rust's syntax, it is considered experimental at this time.</p>
<h4 id="dslx_reference-unused-bindings">Unused Bindings</h4>
<p>If you bind a name and do not use it, a warning will be flagged, and warnings
are errors by default; e.g. this will flag an unused warning:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">my_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// Not used!</span>
<span class="p">}</span>
</code></pre></div>
<p>For cases where it's more readable to <em>keep</em> a name, even though it's unused,
you can prefix the name with a leading underscore, like so:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">my_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">thing_one</span><span class="p">,</span><span class="w"> </span><span class="n">_thing_two</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open_crate</span><span class="p">();</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">thing_one</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that <code>_thing_two</code> is unused, but a warning is not flagged because we
indicated via a leading underscore that it was ok for the variable to go unused,
because we felt it enhanced readability.</p>
<h2 id="dslx_reference-functions">Functions</h2>
<p>Function definitions begin with the keyword <code>fn</code>, followed by the function name,
a parameter list to the function in parenthesis, followed by an <code>-&gt;</code> and the
return type of the function. After this, curly braces denote the begin and end
of the function body.</p>
<p>The list of parameters can be empty.</p>
<p>A single input file can contain many functions.</p>
<p>Simple examples:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">ret3</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="w">   </span><span class="c1">// This function always returns 3.</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">add1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="w">  </span><span class="c1">// Returns x + 1, but you knew that!</span>
<span class="p">}</span>
</code></pre></div>
<p>Functions return the result of their last computed expression as their return
value. There are no explicit return statements. By implication, functions return
exactly one expression; they can't return multiple expressions (but this may
change in the future as we migrate towards some Rust semantics).</p>
<p>Tuples should be returned if a function needs to return multiple values.</p>
<h3 id="dslx_reference-parameters">Parameters</h3>
<p>Parameters are written as pairs <code>name</code> followed by a colon <code>:</code> followed by the
<code>type</code> of that parameter. Each parameter needs to declare its own type.</p>
<p>Examples:</p>
<div class="highlight"><pre><span></span><code>// a simple parameter x of type u32
   x: u32

// t is a tuple with 2 elements.
//   the 1st element is of type u32
//   the 2nd element is a tuple with 3 elements
//       the 1st element is of type u8
//       the 2nd element is another tuple with 1 element of type u16
//       the 3rd element is of type u8
   t: (u32, (u8, (u16,), u8))
</code></pre></div>
<h3 id="dslx_reference-parametric-functions">Parametric Functions</h3>
<p>DSLX functions can be parameterized in terms of the types of its arguments and
in terms of types derived from other parametric values. For instance:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">double</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">self_append</span><span class="o">&lt;</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">double</span><span class="p">(</span><span class="n">A</span><span class="p">)}</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">B</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="o">++</span><span class="n">x</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">self_append</span><span class="p">(</span><span class="n">u5</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>In <code>self_append(bits[5]:1)</code>, we see that <code>A = 5</code> based off of formal argument
instantiation. Using that value, we can evaluate <code>B = double(A=5)</code>. This derived
expression is analogous to C++'s constexpr – a simple expression that can be
evaluated at that point in compilation. Note that the expression must be wrapped
in <code>{}</code> curly braces.</p>
<p>See
<a href="#dslx_reference-advanced-understanding-parametricity-constraints-and-unification">advanced understanding</a>
for more information on parametricity.</p>
<h4 id="dslx_reference-explicit-parametric-instantiation">Explicit parametric instantiation</h4>
<p>In some cases, parametric values cannot be inferred from function arguments,
such as in the
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/explicit_parametric_simple.x"><code>explicit_parametric_simple.x</code></a>
test:</p>
<div class="highlight"><pre><span></span><code>fn add_one&lt;E:u32, F:u32, G:u32 = E+F&gt;(lhs: bits[E]) -&gt; bits[G] { ... }
</code></pre></div>
<p>For this call to instantiable, both <code>E</code> and <code>F</code> must be specified. Since <code>F</code>
can't be inferred from an argument, we must rely on <em>explicit parametrics</em>:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">add_one</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>This invocation will bind <code>1</code> to <code>E</code>, <code>5</code> to <code>F</code>, and <code>6</code> to <code>G</code>. Note the curly
braces around the expression-defined parametric: simple literals and constant
references do not need braces (but they <em>can</em> have them), but any other
expression requires them.</p>
<h5 id="dslx_reference-expression-ambiguity">Expression ambiguity</h5>
<p>Without curly braces, explicit parametric expressions could be ambiguous;
consider the following, slightly changed from the previous example:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">add_one</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>Is the statement above computing <code>add_one&lt;1, (2 &gt; 3)&gt;(1)</code>, or is it computing
<code>(add_one&lt;1, 2&gt;(3)) &gt; 1)</code>? Without additional (and subtle and perhaps
surprising) contextual precedence rules, this would be ambiguous and could lead
to a parse error or, even worse, unexpected behavior.</p>
<p>Fortunately, we can look to Rust for inspiration. Rust's const generics RPF
introduced the <code>{ }</code> syntax for disambiguating just this case in generic
specifications. With this, any expressions present in a parametric specification
must be contained within curly braces, as in the original example.</p>
<p>At present, if the braces are omitted, some unpredictable error will occur. Work
to improve this is tracked in
<a href="https://github.com/google/xls/issues/321">XLS GitHub issue #321</a>.</p>
<h3 id="dslx_reference-function-calls">Function Calls</h3>
<p>Function calls are expressions and look and feel just like one would expect from
other languages. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">callee</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">caller</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">callee</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>If more than one value should be returned by a function, a tuple type should be
returned.</p>
<h3 id="dslx_reference-built-in-functions-and-standard-library">Built-In Functions and Standard Library</h3>
<p>The DSL has several built-in functions and standard library modules. For details
on the available functions to invoke, see
<a href="#dslx_std">DSLX Built-In Functions and Standard Library</a>.</p>
<h2 id="dslx_reference-types">Types</h2>
<h3 id="dslx_reference-bit-type">Bit Type</h3>
<p>The most fundamental type in DSLX is a variable length bit type denoted as
<code>bits[n]</code>, where <code>n</code> is a constant. For example:</p>
<div class="highlight"><pre><span></span><code>bits[1]   // a single bit
uN[1]     // explicitly noting single bit is unsigned
u1        // convenient shorthand for bits[1]

bits[8]   // an 8-bit datatype, yes, a byte
u8        // convenient shorthand for bits[8]
bits[32]  // a 32-bit datatype
u32       // convenient shorthand for bits[32]
bits[256] // a 256-bit datatype

bits[0]   // possible, but, don&#39;t do that
</code></pre></div>
<p>DSLX introduces aliases for commonly used types, such as <code>u8</code> for an 8-wide bit
type, or <code>u32</code> for a 32-bit wide bit type. These are defined up to <code>u64</code>.</p>
<p>All <code>u*</code>, <code>uN[*]</code>, and <code>bits[*]</code> types are interpreted as unsigned integers.
Signed integers are specified via <code>s*</code> and <code>sN[*]</code>. Similarly to unsigned
numbers, the <code>s*</code> shorthands are defined up to <code>s64</code>. For example:</p>
<div class="highlight"><pre><span></span><code>sN[1]
s1

sN[64]
s64

sN[256]

sN[0]
s0
</code></pre></div>
<p>Signed numbers differ in their behavior from unsigned numbers primarily via
operations like comparisons, (variable width) multiplications, and divisions.</p>
<h4 id="dslx_reference-bit-type-attributes">Bit Type Attributes</h4>
<p>Bit types have helpful type-level attributes that provide limit values, similar
to <code>std::numeric_limits</code> in C++. For example:</p>
<div class="highlight"><pre><span></span><code><span class="n">u3</span><span class="p">::</span><span class="n">MAX</span><span class="w">   </span><span class="c1">// u3:0b111 the &quot;fill with ones&quot; value</span>
<span class="n">s3</span><span class="p">::</span><span class="n">MAX</span><span class="w">   </span><span class="c1">// s3:0b011 the &quot;maximum signed&quot; value</span>

<span class="n">u3</span><span class="p">::</span><span class="n">ZERO</span><span class="w">  </span><span class="c1">// u3:0b000 the &quot;fill with zeros&quot; value</span>
<span class="n">s3</span><span class="p">::</span><span class="n">ZERO</span><span class="w">  </span><span class="c1">// s3:0b000 the &quot;fill with zeros&quot; value</span>
</code></pre></div>
<h4 id="dslx_reference-character-constants">Character Constants</h4>
<p>Characters are a special case of bits types: they are implicitly-type as u8.
Characters can be used just as traditional bits:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">add_to_null</span><span class="p">(</span><span class="n">input</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">null</span><span class="p">:</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">null</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">add_to_null</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>DSLX character constants support the
<a href="https://doc.rust-lang.org/reference/tokens.html">full Rust set of escape sequences</a>
with the exception of unicode.</p>
<h3 id="dslx_reference-enum-types">Enum Types</h3>
<p>DSLX supports enumerations as a way of defining a group of related, scoped,
named constants that do not pollute the module namespace. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="nc">Opcode</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FIRE_THE_MISSILES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">BE_TIRED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">TAKE_A_NAP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">get_my_favorite_opcode</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Opcode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Opcode</span><span class="p">::</span><span class="n">FIRE_THE_MISSILES</span>
<span class="p">}</span>
</code></pre></div>
<p>Note the use of the double-colon to reference the enum value. This code
specifies that the enum behaves like a <code>u3</code>: its storage and extension (via
casting) behavior are defined to be those of a <code>u3</code>. Attempts to define an enum
value outside of the representable <code>u3</code> range will produce a compile time error.</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="nc">Opcode</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="c1">// Causes compile time error!</span>
<span class="p">}</span>
</code></pre></div>
<p>Enums can be compared for equality/inequality, but they do not permit arithmetic
operations, they must be cast to numerical types in order to perform arithmetic:</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="nc">Opcode</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NOP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">ADD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">same_opcode</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Opcode</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w">  </span><span class="c1">// ok</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">next_in_sequence</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Opcode</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// x+1 == y // does not work, arithmetic!</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="p">)</span><span class="w">  </span><span class="c1">// ok, casted first</span>
<span class="p">}</span>
</code></pre></div>
<p>As mentioned above, casting of enum-values works with the same casting/extension
rules that apply to the underlying enum type definition. For example, this cast
will sign extend because the source type for the enum is signed. (See
<a href="#dslx_reference-numerical-conversions">numerical conversions</a> for the full description of
extension/truncation behavior.)</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="nc">MySignedEnum</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">s3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">LOW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">HIGH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">extend_to_32b</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">MySignedEnum</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w">  </span><span class="c1">// Sign-extends because the source type is signed.</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_extend_to_32b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">extend_to_32b</span><span class="p">(</span><span class="n">MySignedEnum</span><span class="p">::</span><span class="n">LOW</span><span class="p">),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xffffffff</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Casting <em>to</em> an enum is also permitted. However, in most cases errors from
invalid casting can only be found at runtime, e.g., in the DSL interpreter or
flagging a fatal error from hardware. Because of that, it is recommended to
avoid such casts as much as possible.</p>
<h3 id="dslx_reference-tuple-type">Tuple Type</h3>
<p>A tuple is a fixed-size ordered set, containing elements of heterogeneous types.
Tuples elements can be any type, e.g. bits, arrays, structs, tuples. Tuples may
be empty (an empty tuple is also known as the unit type), or contain one or more
types.</p>
<p>Examples of tuple values:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The unit type, carries no information.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span>

<span class="c1">// A tuple containing two bits-typed elements.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">u4</span><span class="p">:</span><span class="mb">0b1101</span><span class="p">);</span>
</code></pre></div>
<p>Example of a tuple type:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The type of a tuple with 2 elements.</span>
<span class="c1">//   the 1st element is of type u32</span>
<span class="c1">//   the 2nd element is a tuple with 3 elements</span>
<span class="c1">//       the 1st element is of type u8</span>
<span class="c1">//       the 2nd element is another tuple with 1 element of type u16</span>
<span class="c1">//       the 3rd element is of type u8</span>
<span class="k">type</span><span class="w"> </span><span class="nc">MyTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,),</span><span class="w"> </span><span class="kt">u8</span><span class="p">));</span>
</code></pre></div>
<p>To access individual tuple elements use simple indices, starting at 0. For
example, to access the second element of a tuple (index 1):</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_tuple_access</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Such indices can only be numeric literals; parametric symbols are not allowed.</p>
<p>Tuples can be "destructured", similarly to how pattern matching works in <code>match</code>
expressions, which provides a convenient syntax to name elements of a tuple for
subsequent use. See <code>a</code> and <code>b</code> in the following:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_tuple_destructure</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Just as values can be discarded in a <code>let</code> by using the "black hole identifier"
<code>_</code>, don't-care values can also be discarded when destructuring a tuple:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_black_hole</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-struct-types">Struct Types</h3>
<p>Structures are similar to tuples, but provide two additional capabilities: we
name the slots (i.e. struct fields have names while tuple elements only have
positions), and we introduce a new type.</p>
<p>The following syntax is used to define a struct:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span>
<span class="p">}</span>
</code></pre></div>
<p>Once a struct is defined it can be constructed by naming the fields in any
order:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_struct_equality</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>There is a simple syntax when creating a struct whose field names match the
names of in-scope values:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_struct_equality</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Struct fields can also be accessed with "dot" syntax:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">f</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="w"> </span><span class="p">})</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">106</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that structs cannot be mutated "in place", the user must construct new
values by extracting the fields of the original struct mixed together with new
field values, as in the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">update_y</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">Point3</span><span class="p">,</span><span class="w"> </span><span class="n">new_y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">new_y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">256</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">update_y</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">128</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">256</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">want</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dslx_reference-struct-update-syntax">Struct Update Syntax</h4>
<p>The DSL has syntax for conveniently producing a new value with a subset of
fields updated to reduce verbosity. The "struct update" syntax is:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">update_y</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">Point3</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">update_x_and_y</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">Point3</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Point3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dslx_reference-parametric-structs">Parametric Structs</h4>
<p>DSLX also supports parametric structs. For more information on how
type-parametricity works, see the <a href="#dslx_reference-parametric-functions">parametric functions</a>
section.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">double</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">double</span><span class="p">(</span><span class="n">N</span><span class="p">)}</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">],</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">M</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">make_point</span><span class="o">&lt;</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">B</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Point</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_struct_construction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_point</span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dslx_reference-understanding-nominal-typing">Understanding Nominal Typing</h4>
<p>As mentioned above, a struct definition introduces a new type. Structs are
nominally typed, as opposed to structurally typed (note that tuples are
structurally typed). This means that structs with different names have different
types, regardless of whether those structs have the same structure (i.e. even
when all the fields of two structures are identical, those structures are a
different type when they have a different name).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Coordinate</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_ok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">106</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_type_checker_error</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">Coordinate</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">106</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-array-type">Array Type</h3>
<p>Arrays can be constructed via bracket notation. All values that make up the
array must have the same type. Arrays can be indexed with indexing notation
(<code>a[i]</code>) to retrieve a single element.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Make an array with &quot;bracket notation&quot;.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">my_array</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">];</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Because arrays with repeated trailing elements are common, the DSL supports
ellipsis (<code>...</code>) at the end of an array to fill the remainder of the array with
the last noted element. Because the compiler must know how many elements to
fill, in order to use the ellipsis the type must be annotated explicitly as
shown.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">make_array</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.]</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_make_array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">],</span><span class="w"> </span><span class="n">make_array</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">],</span><span class="w"> </span><span class="n">make_array</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>Note <a href="https://github.com/google/xls/issues/917">google/xls#917</a>: arrays with
length zero will typecheck, but fail to work in most circumstances. Eventually,
XLS should support them but they can't be used currently.</p>
<p>TODO(meheff): Explain arrays and the intricacies of our bits type interpretation
and how it affects arrays of bits etc.</p>
<h4 id="dslx_reference-character-string-constants">Character String Constants</h4>
<p>Character strings are a special case of array types, being implicitly-sized
arrays of u8 elements. String constants can be used just as traditional arrays:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">add_one</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="n">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">}(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="s">&quot;bcdef&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">add_one</span><span class="p">(</span><span class="s">&quot;abcde&quot;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>DSLX string constants support the
<a href="https://doc.rust-lang.org/reference/tokens.html">full Rust set of escape sequences</a> -
note that unicode escapes get encoded to their UTF-8 byte sequence. In other
words, the sequence <code>\u{10CB2F}</code> will result in an array with hexadecimal values
<code>F4 8C AC AF</code>.</p>
<p>Moreover, string can be composed of <a href="#dslx_reference-character-constants">characters</a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">string_composed_characters</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[</span><span class="sc">&#39;X&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;L&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;S&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;r&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;k&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;s&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;!&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="s">&quot;XLS rocks!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">string_composed_characters</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-type-aliases">Type Aliases</h3>
<p>DLSX supports the definition of type aliases.</p>
<p>Type aliases can be used to provide a more human-readable name for an existing
type. The new name is on the left, the existing name on the right:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span><span class="p">;</span>
</code></pre></div>
<p>We can create an alias for an imported type:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Note: this imports an external file in the codebase.</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="p">;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">MyEnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod_imported</span><span class="p">::</span><span class="n">MyEnum</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">MyEnum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">MyEnum</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="n">MyEnum</span><span class="p">::</span><span class="n">FOO</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">64</span><span class="p">),</span><span class="w"> </span><span class="n">MyEnum</span><span class="p">::</span><span class="n">BAR</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Type aliases can also provide a descriptive name for a tuple type (which is
otherwise anonymous). For example, to define a tuple type that represents a
float number with a sign bit, an 8-bit mantissa, and a 23-bit mantissa, one
would write:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">F32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">u23</span><span class="p">);</span>
</code></pre></div>
<p>After this definition, the <code>F32</code> may be used as a type annotation
interchangeably with <code>(u1, u8, u23)</code>.</p>
<p>Note, however, that structs are generally preferred for this purpose, as they
are more readable and users do not need to rely on tuple elements having a
stable order in the future (i.e., they are resilient to refactoring).</p>
<h3 id="dslx_reference-type-casting">Type Casting</h3>
<p>Bit types can be cast from one bit-width to another with the <code>as</code> keyword. Types
can be widened (increasing bit-width), narrowed (decreasing bit-width) and/or
changed between signed and unsigned. Some examples are found below. See
<a href="#dslx_reference-numerical-conversions">Numerical Conversions</a> for a description of the
semantics.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_narrow_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">twelve</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u4</span><span class="p">:</span><span class="mb">0b1100</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">twelve</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_widen_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">three</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u4</span><span class="p">,</span><span class="w"> </span><span class="n">u4</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_narrow_signed_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">negative_seven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s4</span><span class="p">:</span><span class="mb">0b1001</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">negative_seven</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_widen_signed_cast</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">negative_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">negative_one</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_widen_to_unsigned</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">negative_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">negative_one</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mb">0b111</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_widen_to_signed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">three</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mb">0b011</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-type-checking-and-inference">Type Checking and Inference</h3>
<p>DSLX performs type checking and produces an error if types in an expression
don't match up.</p>
<p><code>let</code> expressions also perform type inference, which is quite convenient. For
example, instead of writing:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ch</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
</code></pre></div>
<p>one can write the following, as long as the types can be properly inferred:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
</code></pre></div>
<p>Note that type annotations can still be added and be used for program
understanding, as they they will be checked by DSLX.</p>
<h3 id="dslx_reference-type-inference-details">Type Inference Details</h3>
<h4 id="dslx_reference-type-inference-background">Type Inference Background</h4>
<p>All expressions in the language's expression grammar have a deductive type
inference rule. The types must be known for inputs to an
operator/function<sup id="dslx_reference-fnref:usebeforedef"><a class="footnote-ref" href="#dslx_reference-fn:usebeforedef">1</a></sup> and every expression has a way to determine its
type from its operand expressions.</p>
<p>DSLX uses deductive type inference to check the types present in the program.
Deductive type inference is a set of (typically straight-forward) deduction
rules: Hindley-Milner style deductive type inference determines the result type
of a function with a rule that only observes the input types to that function.
(Note that operators like '+' are just slightly special functions in that they
have pre-defined special-syntax-rule names.)</p>
<h4 id="dslx_reference-bindings-and-environment">Bindings and Environment</h4>
<p>In DSLX code, the "environment" where names are bound (sometimes also referred
to as a symbol table) is called the
<a href="https://github.com/google/xls/tree/main/xls/dslx/frontend/bindings.h"><code>Bindings</code></a> -- it
maps identifiers to the AST node that defines the name (<code>{string: AstNode}</code>),
which can be combined with a mapping from AST node to its deduced type
(<code>{AstNode: ConcreteType}</code>) to resolve the type of an identifier in the program.
<code>Let</code> is one of the key nodes that populates these <code>Bindings</code>, but anything that
creates a bound name does as well (e.g. parameters, for loop induction
variables, etc.).</p>
<h4 id="dslx_reference-operator-example">Operator Example</h4>
<p>For example, consider the binary (meaning takes two operands) / infix (meaning
it syntactically is placed in the center of its operands) '+' operator. The
simple deductive type inference rule for '+' is:</p>
<p><code>(T, T) -&gt; T</code></p>
<p>Meaning that the left hand side operand to the '+' operator is of some type
(call it T), the right hand side operand to the '+' operator must be of that
same type, T, and the result of that operator is then (deduced) to be of the
same type as its operands, T.</p>
<p>Let's instantiate this rule in a function:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">add_wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</code></pre></div>
<p>This function wraps the '+' operator. It presents two arguments to the '+'
operator and then checks that the annotated return type on <code>add_wrapper</code> matches
the deduced type for the body of that function; that is, we ask the following
question of the '+' operator (since the type of the operands must be known at
the point the add is performed):</p>
<p><code>(bits[2], bits[2]) -&gt; ?</code></p>
<p>To resolve the '?' the following procedure is being used:</p>
<ul>
<li>Pattern match the rule given above <code>(T, T) -&gt; T</code> to determine the type T:
    the left hand side operand is <code>bits[2]</code>, called T.</li>
<li>Check that the right hand side is also that same T, which it is: another
    <code>bits[2]</code>.</li>
<li>Deduce that the result type is that same type T: <code>bits[2]</code>.</li>
<li>That becomes the return type of the body of the function. Check that it is
    the same type as the annotated return type for the function, and it is!</li>
</ul>
<p>The function is annotated to return <code>bits[2]</code>, and the deduced type of the body
is also <code>bits[2]</code>. Qed.</p>
<h4 id="dslx_reference-type-errors">Type errors</h4>
<p>A <strong>type error</strong> would occur in the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">add_wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</code></pre></div>
<p>Applying the type deduction rule for '+' finds an inconsistency. The left hand
side operand has type <code>bits[2]</code>, called T, but the right hand side is <code>bits[3]</code>,
which is not the same as T. Because the deductive type inference rule does not
say what to do when the operand types are different, it results in a type error
which is flagged at this point in the program.</p>
<h4 id="dslx_reference-let-bindings-names-and-the-environment">Let Bindings, Names, and the Environment</h4>
<p>In the DSL, <code>let</code> is an expression. It may not seem obvious at a glance, but it
is! As a primer see the <a href="#dslx_reference-type-inference-background">type inference background</a>
and how <a href="#dslx_reference-bindings-and-environment">names are resolved in an environment</a>.</p>
<p>"let" expressions are of the (Rust-inspired) form:</p>
<p><code>let $name: $annotated_type = $expr; $subexpr</code></p>
<p><code>$name</code> gets "bound" to a value of type <code>$annotated_type</code>. The <code>let</code> typecheck
rule must <strong>both</strong> check that <code>$expr</code> is of type <code>$annotated_type</code>, as well as
determine the type of <code>$subexpr</code>, which is the type of the overall "let
expression".</p>
<p>In this example, the result of the <code>let</code> expression is the return value --
<code>$subexpr</code> (<code>x+x</code>) can use the <code>$name</code> (<code>x</code>) which was "bound":</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span>
<span class="w">  </span><span class="n">x</span><span class="o">+</span><span class="n">x</span>
<span class="p">}</span>
</code></pre></div>
<p>If we invoke <code>main(u32:2)</code> we will the evaluate <code>let</code> expression -- it creates a
binding of <code>x</code> to the value <code>u64:2</code>, and then evaluates the expression <code>x+x</code> in
that environment, so the result of the <code>let</code> expression's <code>$subexpr</code> is <code>u64:4</code>.</p>
<h2 id="dslx_reference-statements">Statements</h2>
<h3 id="dslx_reference-imports">Imports</h3>
<p>DSLX modules can import other modules via the <code>import</code> keyword. Circular imports
are not permitted (the dependencies among DSLX modules must form a DAG, as in
languages like Go).</p>
<p>The import statement takes the following form:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">std</span><span class="p">;</span>
</code></pre></div>
<p>The standard library modules (such as <code>std</code>) live in a special location known
the DSL as built-in paths to look for modules -- imports of "normal"
(user-written) modules take full paths relative to the root of execution and
DSLX path.</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span><span class="p">;</span>
</code></pre></div>
<p>With that statement, the module will be accessible as (the trailing identifier
after the last dot) <code>imported_module</code>; e.g. the program can refer to
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code>.</p>
<p>NOTE Imports are relative to the Bazel "depot root" -- for external use of the
tools a <code>DSLX_PATH</code> will be exposed, akin to a <code>PYTHONPATH</code>, for users to
indicate paths where were should attempt module discovery.</p>
<p>NOTE Importing <strong>does not</strong> introduce any names into the current file other than
the one referred to by the import statement. That is, if <code>imported_module</code> had a
constant defined in it <code>FOO</code>, this is referred to via <code>imported_module::FOO</code>,
<code>FOO</code> does not "magically" get put in the current scope. This is analogous to
how wildcard imports are discouraged in other languages (e.g. <code>from import *</code> in
Python) on account of leading to "namespace pollution" and needing to specify
what happens when names conflict.</p>
<p>If you want to change the name of the imported module (for reference inside of
the importing file) you can use the <code>as</code> keyword:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">im</span><span class="p">;</span>
</code></pre></div>
<p>Just using the above construct,
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code> is <em>not</em> valid, only
<code>im::IMPORTED_MODULE_PUBLIC_CONSTANT</code>. However, both statements can be used on
different lines:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span><span class="p">;</span>
<span class="n">import</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to</span><span class="p">.</span><span class="n">my</span><span class="p">.</span><span class="n">imported_module</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">im</span><span class="p">;</span>
</code></pre></div>
<p>In this case, either <code>im::IMPORTED_MODULE_PUBLIC_CONSTANT</code> or
<code>imported_module::IMPORTED_MODULE_PUBLIC_CONSTANT</code> can be used to refer to the
same thing.</p>
<p>Here is an example using the same function via two different aliases for the
same module:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Note: this imports an external file in the codebase under two different</span>
<span class="c1">// names.</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="p">;</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">mi</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mod_imported</span><span class="p">::</span><span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mi</span><span class="p">::</span><span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-public-module-members">Public module members</h3>
<p>Module members are private by default and not accessible from any importing
module. To make a member public/visible to importing modules, the <code>pub</code> keyword
must be added as a prefix; e.g.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span><span class="w">      </span><span class="c1">// Not accessible to importing modules.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">64</span><span class="p">;</span><span class="w">  </span><span class="c1">// Accessible to importing modules.</span>
</code></pre></div>
<p>This applies to other things defined at module scope as well: functions, enums,
type aliases, etc.</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="p">;</span>
<span class="n">import</span><span class="w"> </span><span class="n">xls</span><span class="p">.</span><span class="n">dslx</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">mod_imported</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">mi</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mod_imported</span><span class="p">::</span><span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mi</span><span class="p">::</span><span class="n">my_lsb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-module-attributes">Module attributes</h3>
<p>A limited number of attributes are able to be applied at module scope (currently
just one), using the following syntax, which is conventionally placed at the top
of the module (<code>.x</code> file):</p>
<div class="highlight"><pre><span></span><code><span class="cp">#![allow(nonstandard_constant_naming)]</span>

<span class="c1">// .. rest of the module ..</span>
</code></pre></div>
<p>This disables the warning that is usually produced for non-standard constant
names -- typically DSLX warns if they are not <code>SCREAMING_SNAKE_CASE</code> as per the
Rust style guide. (This is useful for things like automatically generated files
where perhaps we'd prefer not to rewrite names vs leaving them in some other,
nonstandard, identifier form.)</p>
<h3 id="dslx_reference-const">Const</h3>
<p>The <code>const</code> keyword is used to define module-level constant values. Named
constants should be usable anywhere a literal value can be used:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">match_const</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_match_const_not_binding</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">match_const</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">match_const</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">match_const</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">h</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">FOO</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_match_nested</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">))));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">))));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">))));</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="dslx_reference-expressions">Expressions</h2>
<h3 id="dslx_reference-literals">Literals</h3>
<p>DSLX supports construction of literals using the syntax <code>Type:Value</code>. For
example <code>u16:1</code> is a 16-wide bit array with its least significant bit set to
one. Similarly <code>s8:12</code> is an 8-wide bit array with its least significant four
bits set to <code>1100</code>.</p>
<p>DSLX supports initializing using binary, hex or decimal syntax. So</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_literal_initialization</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mb">0b00001100</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mh">0x0c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>When constructing literals DSLX will trigger an error if the constant will not
fit in a bit array of the annotated sized, so for example trying to construct
the literal <code>u8:256</code> will trigger an error of the form:</p>
<p><code>TypeInferenceError: uN[8] Value '256' does not fit in the bitwidth of a uN[8]
(8)</code></p>
<p>But what about <code>s8:128</code> ? This is a valid literal, even though a signed 8-bit
integer cannot represent it. The following code offers a clue.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_signed_literal_initialization</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span><span class="p">:</span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span><span class="p">:</span><span class="o">-</span><span class="mi">128</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span><span class="p">:</span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span><span class="p">:</span><span class="mb">0b10000000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>What is happening here is that, 128 is being used as a bit pattern rather than
as the number 128 to initialize the literal. It is only when the bit pattern
cannot fit in the width of the literal that an error is triggered.</p>
<p><strong>Note that behaviour is different from Rust, where it will trigger an error,
and the fact that DSLX considers this valid may change in the
<a href="https://github.com/google/xls/issues/471">future</a>.</strong></p>
<h3 id="dslx_reference-grouping-expression">Grouping Expression</h3>
<p>As in mathematical notation and many programming languages, an expression can be
surrounded with an opening and closing parenthesis to make it the highest
precedence (or simply for readability). For example, this expression evaluates
to <code>u32:9</code>: <code>(u32:1 + u32:2) * u32:3</code>.</p>
<h3 id="dslx_reference-unary-expressions">Unary Expressions</h3>
<p>DSLX supports two types of unary expressions with type signature <code>(xN[N]) -&gt;
xN[N]</code>:</p>
<ul>
<li>bit-wise not (the <code>!</code> operator)</li>
<li>negate (the <code>-</code> operator, computes the two's complement negation)</li>
</ul>
<h3 id="dslx_reference-binary-expressions">Binary Expressions</h3>
<p>DSLX supports a familiar set of binary expressions. There are two categories of
binary expressions. A category where both operands to the expression must be of
the same bit type (i.e., not arrays or tuples), and a category where the
operands can be of arbitrary bit types (i.e. shift expressions).</p>
<h4 id="dslx_reference-expressions-with-operands-of-the-same-type">Expressions with operands of the same type.</h4>
<p>The following expressions have type signature <code>(xN[N], xN[N]) -&gt; xN[N]</code>.</p>
<ul>
<li>bit-wise or (<code>|</code>)</li>
<li>bit-wise and (<code>&amp;</code>)</li>
<li>bit-wise xor (<code>^</code>)</li>
<li>add (<code>+</code>)</li>
<li>subtract (<code>-</code>)</li>
<li>multiply (<code>*</code>)</li>
</ul>
<p>Things like
<a href="https://github.com/search?q=repo%3Agoogle%2Fxls+path%3Axls%2Fdslx/stdlib/std.x%20%22fn+smul%22"><code>std::smul</code></a>
are convenient helpers when you are working with mixed widths. Because these
expressions return the same type as the operands, if you want a carry you need
to widen the inputs (e.g.
<a href="https://github.com/search?q=repo%3Agoogle%2Fxls+path%3Axls%2Fdslx/stdlib/std.x%20%22fn+uadd_with_overflow%22"><code>std::uadd_with_overflow</code></a>
). The optimizer will narrow the operands and produce efficient hardware,
especially with trivial zero-/sign-extended operands like <code>std::smul</code> and
<code>std::uadd_with_overflow</code>.</p>
<h4 id="dslx_reference-logical-expressions">Logical Expressions</h4>
<ul>
<li>logical or (<code>||</code>)</li>
<li>logical and (<code>&amp;&amp;</code>)</li>
</ul>
<p>These are binary operations that are of the type <code>(bool, bool) -&gt; bool</code>. (Note
that <code>bool</code> is equivalent to <code>u1</code>.)</p>
<h4 id="dslx_reference-shift-expressions">Shift Expressions</h4>
<p>Shift expressions include:</p>
<ul>
<li>shift-right logical (<code>&gt;&gt;</code>)</li>
<li>shift-left (<code>&lt;&lt;</code>)</li>
</ul>
<p>These are binary operations that don't require the same type on the left and
right hand side. The right hand side must be unsigned, but it does not need to
be the same type or width as the left hand side, i.e. the type signature for
these operations is: <code>(xN[M], uN[N]) -&gt; xN[M]</code>. If the right hand side is a
literal value it does not need to be type annotated. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">shr_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">s32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that, as in Rust, the semantics of the shift-right (<code>&gt;&gt;</code>) operation depends
on the signedness of the left hand side. For a signed-type left hand side, the
shift-right (<code>&gt;&gt;</code>) operation performs a shift-right arithmetic and, for a
unsigned-type left hand side, the shift-right (<code>&gt;&gt;</code>) operation performs a
shift-right (logical).</p>
<h3 id="dslx_reference-comparison-expressions">Comparison Expressions</h3>
<p>For comparison expressions the types of both operands must match. However these
operations return a result of type <code>bits[1]</code>, aka <code>bool</code>.</p>
<ul>
<li>equal (<code>==</code>)</li>
<li>not-equal (<code>!=</code>)</li>
<li>greater-equal (<code>&gt;=</code>)</li>
<li>greater (<code>&gt;</code>)</li>
<li>less-equal (<code>&lt;=</code>)</li>
<li>less (<code>&lt;</code>)</li>
</ul>
<h3 id="dslx_reference-concat-expression">Concat Expression</h3>
<p>Bitwise concatenation is performed with the <code>++</code> operator. The value on the left
hand side becomes the most significant bits, the value on the right hand side
becomes the least significant bits. Both of the operands must be unsigned (see
<a href="#dslx_reference-numerical-conversions">numerical conversions</a> for details on converting signed
numbers to unsigned).</p>
<p>Concatenation operations may be chained together as shown:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_bits_concat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mb">0b11000000</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u6</span><span class="p">:</span><span class="mb">0b000000</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mb">0b00000111</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u6</span><span class="p">:</span><span class="mb">0b000111</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u6</span><span class="p">:</span><span class="mb">0b100111</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mb">0b111</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u6</span><span class="p">:</span><span class="mb">0b001000</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mb">0b000</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xdeadbeef</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">:</span><span class="mh">0xdead</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="kt">u16</span><span class="p">:</span><span class="mh">0xbeef</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-block-expressions">Block Expressions</h3>
<p>Block expressions enable subordinate scopes to be defined, e.g.:</p>
<div class="highlight"><pre><span></span><code>let a = {
  let b = u32:1;
  b + u32:3
};
</code></pre></div>
<p>Above, <code>a</code> is equal to <code>4</code>.</p>
<p>The value of a block expression is that of its last contained expression, or (),
if a final expression is omitted:</p>
<div class="highlight"><pre><span></span><code>let a = { let b = u32:1; };
</code></pre></div>
<p>In the above case, <code>a</code> is equal to <code>()</code>.</p>
<p>Since DSLX does not currently have the concept of lifetimes, and since names can
be rebound (i.e., this is valid: <code>let a = u32:0; let a = u32:1;</code>), blocks have
the following uses:</p>
<ul>
<li>to syntactically form the body of functions and loops</li>
<li>to limit the scope of variables</li>
<li>to increase readability</li>
</ul>
<h3 id="dslx_reference-match-expression">Match Expression</h3>
<p>Match expressions permit "pattern matching" on data, like a souped-up switch
statement. It can both test for values (like a conditional guard) and bind
values to identifiers for subsequent use. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="kt">u32</span><span class="p">:</span><span class="mi">77</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>If the first member of the tuple is the value is <code>42</code>, we pass the second tuple
member back as-is from the function. Otherwise, we add <code>77</code> to the value and
return that. The <code>_</code> symbolizes "I don't care about this value".</p>
<p>Just like literal constants, pattern matching can also match via named
constants; For example, consider this variation on the above:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">MY_FAVORITE_NUMBER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">MY_FAVORITE_NUMBER</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="kt">u32</span><span class="p">:</span><span class="mi">77</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This also works with nested tuples; for example:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">MY_FAVORITE_NUMBER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">MY_FAVORITE_NUMBER</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">7</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Here we use a "catch all" wildcard pattern in the last match arm to ensure the
match expression always matches the input somehow.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This "catch all" (i.e. an
<a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">irrefutable pattern</a>)
is <a href="https://github.com/google/xls/issues/204">currently required</a> in <strong>all</strong>
match expressions, even if the other match arms form an exhaustive set of
refutable patterns (e.g. matching against fully specified enumerators).</p>
</div>
<p>We can also match on ranges of values using the range syntax:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Note: the limit of the range syntax is exclusive.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dslx_reference-redundant-patterns">Redundant Patterns</h4>
<p><code>match</code> will flag an error if a <em>syntactically identical</em> pattern is typed
twice; e.g.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// Identical pattern!</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Only the first pattern will ever match, so it is fully redundant (and therefore
likely a user error they'd like to be informed of). Note that <em>equivalent</em> but
not <em>syntactically identical</em> patterns will not be flagged in this way.</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">BAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// Compares `==` to `FOO`.</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FOO</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">BAR</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// _Equivalent_ pattern, but not syntactically identical.</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-let-expression"><code>let</code> Expression</h3>
<p>let expressions work the same way as let expressions in other functional
languages (such as the ML family languages). let expressions provide a nested,
lexically-scoped, list of binding definitions. The scope of the binding is the
expression on the right hand side of the declaration. For example:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">;</span>
<span class="n">b</span>
</code></pre></div>
<p>would bind (and return as a value) the value <code>6</code> which corresponds to <code>b</code> when
evaluated. In effect there is little difference to other languages like C/C++ or
Python, where the same result would be achieved with code similar to this:</p>
<div class="highlight"><pre><span></span><code><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">return</span> <span class="n">b</span>
</code></pre></div>
<p>However, <code>let</code> expressions are lexically scoped. In above example, the value <code>3</code>
is bound to <code>a</code> only during the combined let expression sequence. There is no
other type of scoping in DSLX.</p>
<h3 id="dslx_reference-if-expression">If Expression</h3>
<p>DSLX offers an <code>if</code> expression, which is very similar to the Rust <code>if</code>
expression. Blueprint:</p>
<div class="highlight"><pre><span></span><code>if condition { consequent } else { alternate }
</code></pre></div>
<p>This corresponds to the C/C++ ternary <code>?:</code> operator:</p>
<div class="highlight"><pre><span></span><code>condition ? consequent : alternate
</code></pre></div>
<p>Note: both the <code>if</code> and <code>else</code> are <em>required</em> to be present, as with the <code>?:</code>
operator, unlike a C++ <code>if</code> statement. This is because it is an <em>expression</em>
that <em>produces</em> a result value, not a <em>statement</em> that causes a mutating effect.</p>
<p>Furthermore, you can have multiple branches via <code>else if</code>:</p>
<div class="highlight"><pre><span></span><code>if condition0 { consequent0 } else if condition1 { consequent1 } else { alternate }
</code></pre></div>
<p>which corresponds to the C/C++:</p>
<div class="highlight"><pre><span></span><code>condition0 ? consequent0 : (contition1 ? consequent1 : alternate)
</code></pre></div>
<p>Note: a <code>match</code> expression can often be a better choice than having a long
<code>if/else if/.../else</code> chain.</p>
<p>For example, in the FP adder module (modules/fp32_add_2.x), there is code like
the following:</p>
<div class="highlight"><pre><span></span><code>[...]
let result_fraction = if wide_exponent &lt; u9:255 { result_fraction } else { u23:0 };
let result_exponent = if wide_exponent &lt; u9:255 { wide_exponent as u8 } else { u8:255 };
</code></pre></div>
<h3 id="dslx_reference-iterable-expression">Iterable Expression</h3>
<p>Iterable expressions are used in counted for loops. DSLX currently supports two
types of iterable expressions, <code>range</code> and <code>enumerate</code>.</p>
<p>The range expression <code>m..n</code> represents a range of values from m to n-1. This
example will run from 0 to 4 (exclusive):</p>
<div class="highlight"><pre><span></span><code>for (i, accum): (u32, u32) in u32:0..u32:4 {
</code></pre></div>
<p>There also exists a <code>range()</code> builtin function that performs the same operation.</p>
<p><code>enumerate</code> iterates over the elements of an array type and produces pairs of
<code>(index, value)</code>, similar to enumeration constructs in languages like Python or
Go.</p>
<p>In the example below, the loop will iterate 8 times, following the array
dimension of <code>x</code>. Each iteration produces a tuple with the current index (<code>i</code>
ranging from 0 to 7) and the value at the index (<code>e = x[i]</code>).</p>
<div class="highlight"><pre><span></span><code>fn prefix_scan_eq(x: u32[8]) -&gt; bits[8,3] {
  let (_, _, result) =
    for ((i, e), (prior, count, result)): ((u32, u32), (u32, u3, bits[8,3]))
        in enumerate(x) {...
</code></pre></div>
<h3 id="dslx_reference-for-expression">for Expression</h3>
<p>DSLX currently supports synthesis of "counted" for loops (loops that have a
clear upper bound on their number of iterations). These loops are capable of
being generated as unrolled pipeline stages: when generating a pipeline, the XLS
compiler will unroll and specialize the iterations.</p>
<p>NOTE In the future support for loops with an unbounded number of iterations may
be permitted, but will only be possible to synthesize as a time-multiplexed
implementation, since pipelines cannot be unrolled indefinitely.</p>
<h4 id="dslx_reference-blueprint">Blueprint</h4>
<div class="highlight"><pre><span></span><code>for (index, accumulator): (type-of-index, type-of-accumulator) in iterable {
   body-expression
} (initial-accumulator-value)
</code></pre></div>
<p>The type annotation in the above "blueprint" is optional, but often helpful to
include for increased clarity.</p>
<p>Because DSLX is a pure dataflow description, a for loop is an expression that
produces a value. As a result, you grab the output of a for loop just like any
other expression:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">final_accum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">new_accum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">accum</span><span class="p">);</span>
<span class="w">  </span><span class="n">new_accum</span>
<span class="p">}(</span><span class="n">init_accum</span><span class="p">);</span>
</code></pre></div>
<p>Conceptually the for loop "evolves" the accumulator as it iterates, and
ultimately pops it out as the result of its evaluation.</p>
<h4 id="dslx_reference-examples">Examples</h4>
<p>Add up all values from 0 to 4 (exclusive). Note that we pass the accumulator's
initial value in as a parameter to this expression.</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span>
<span class="p">}(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>To add up values from 7 to 11 (exclusive), one would write:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">7</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span>
<span class="p">}(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>"Loop invariant" values (values that do not change as the loop runs) can be used
in the loop body, for example, note the use of <code>outer_thing</code> below:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">outer_thing</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">accum</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">outer_thing</span>
<span class="p">}(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>Both the index and accumulator can be of any valid type, in particular, the
accumulator can be a tuple type, which is useful for evolving a bunch of values.
For example, this for loop "evolves" two arrays:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">ys</span><span class="p">)):</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">..</span><span class="p">.</span>
<span class="p">}((</span><span class="n">init_xs</span><span class="p">,</span><span class="w"> </span><span class="n">init_ys</span><span class="p">))</span>
</code></pre></div>
<p>Note in the above example arrays are dataflow values just like anything else. To
conditionally update an array every other iteration:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">u4</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">..</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Update every other cell with the square of the index.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">}</span>
<span class="p">}(</span><span class="n">u4</span><span class="p">[</span><span class="mi">8</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.]);</span>
</code></pre></div>
<h3 id="dslx_reference-numerical-conversions">Numerical Conversions</h3>
<p>DSLX adopts the
<a href="https://doc.rust-lang.org/1.30.0/book/first-edition/casting-between-types.html">Rust rules</a>
for semantics of numeric casts:</p>
<ul>
<li>Casting from <strong>larger bit-widths to smaller bit-widths</strong> will truncate (to
    the LSbs).
    *   This means that <strong>truncating signed values does not preserve the
        previous value of the sign bit</strong>.</li>
<li>Casting from a smaller bit-width to a larger bit-width will zero-extend if
    the source is unsigned, sign-extend if the source is signed.</li>
<li>Casting from a bit-width to its own bit-width, between signed/unsigned, is a
    no-op.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_numerical_conversions</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s8</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mh">0xfe</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Sign extension (source type is signed, and we widen it).</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s32</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xfffffffe</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s16</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s16</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mh">0xfffe</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Zero extension (source type is unsigned, and we widen it).</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s32</span><span class="p">:</span><span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s32</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Nop (bitwidth is unchanged).</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s8</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">s8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s8</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">u8_m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-array-conversions">Array Conversions</h3>
<p>Casting to an array takes bits from the MSb to the LSb; that is, the group of
bits including the MSb ends up as element 0, the next group ends up as element
1, and so on.</p>
<p>Casting from an array to bits performs the inverse operation: element 0 becomes
the MSbs of the resulting value.</p>
<p>All casts between arrays and bits must have the same total bit count.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">cast_to_array</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">u6</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">cast_from_array</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u6</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u6</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">concat_arrays</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">b</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_cast_to_array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a_value</span><span class="p">:</span><span class="w"> </span><span class="nc">u6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span><span class="p">:</span><span class="mb">0b011011</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_to_array</span><span class="p">(</span><span class="n">a_value</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a_array</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Note: converting back from array to bits gives the original value.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="n">cast_from_array</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b_value</span><span class="p">:</span><span class="w"> </span><span class="nc">u6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span><span class="p">:</span><span class="mb">0b111001</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b_array</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_to_array</span><span class="p">(</span><span class="n">b_value</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">b_array</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">b_value</span><span class="p">,</span><span class="w"> </span><span class="n">cast_from_array</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Concatenation of bits is analogous to concatenation of their converted</span>
<span class="w">  </span><span class="c1">// arrays. That is:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">//  convert(concat(a, b)) == concat(convert(a), convert(b))</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">concat_value</span><span class="p">:</span><span class="w"> </span><span class="nc">u12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_value</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">b_value</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">concat_array</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concat_value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u2</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">concat_array</span><span class="p">,</span><span class="w"> </span><span class="n">concat_arrays</span><span class="p">(</span><span class="n">a_array</span><span class="p">,</span><span class="w"> </span><span class="n">b_array</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Show a few classic &quot;endianness&quot; example using 8-bit array values.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xdeadbeef</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">4</span><span class="p">]:[</span><span class="mh">0xde</span><span class="p">,</span><span class="w"> </span><span class="mh">0xad</span><span class="p">,</span><span class="w"> </span><span class="mh">0xbe</span><span class="p">,</span><span class="w"> </span><span class="mh">0xef</span><span class="p">]);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u16</span><span class="p">:</span><span class="mh">0xbeef</span><span class="p">;</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">2</span><span class="p">]:[</span><span class="mh">0xbe</span><span class="p">,</span><span class="w"> </span><span class="mh">0xef</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-bit-slice-expressions">Bit Slice Expressions</h3>
<p>DSLX supports Python-style bit slicing over <em>unsigned</em> bits types. Note that
bits are numbered 0..N starting "from the right (as you would write it on
paper)" -- least significant bit, AKA LSb -- for example, for the value
<code>u7:0b100_0111</code>:</p>
<div class="highlight"><pre><span></span><code>    Bit    6 5 4 3 2 1 0
  Value    1 0 0 0 1 1 1
</code></pre></div>
<p>A slice expression <code>[N:M]</code> means to get from bit <code>N</code> (inclusive) to bit <code>M</code>
exclusive. The start and limit in the slice expression must be signed integral
values.</p>
<p>Aside: This can be confusing, because the <code>N</code> stands to the left of <code>M</code> in the
expression, but bit <code>N</code> would be to the 'right' of <code>M</code> in the classical bit
numbering. Additionally, this is not the case in the classical array
visualization, where element 0 is usually drawn on the left.</p>
<p>For example, the expression <code>[0:2]</code> would yield:</p>
<div class="highlight"><pre><span></span><code>    Bit    6 5 4 3 2 1 0
  Value    1 0 0 0 1 1 1
                     ^ ^  included
                   ^      excluded

  Result:  0b11
</code></pre></div>
<p>Note that, as of now, the indices for this <code>[N:M]</code> form must be literal numbers
(so the compiler can determine the width of the result). To perform a slice with
a non-literal-number start position, see the <code>+:</code> form described below.</p>
<p>The slicing operation also support the python style slices with offsets from
start or end. To visualize, one can think of <code>x[ : -1]</code> as the equivalent of
<code>x[from the start : bitwidth - 1]</code>. Correspondingly, <code>x[-1 : ]</code> can be
visualized as <code>[ bitwidth - 1 : to the end]</code>.</p>
<p>For example, to get all bits, <em>except</em> the MSb (from the beginning, until the
top element minus 1):</p>
<div class="highlight"><pre><span></span><code><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>
<p>Or to get the two most significant bits:</p>
<div class="highlight"><pre><span></span><code><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
</code></pre></div>
<p>This results in the nice property that a the original complete value can be
sliced into complementary slices such as <code>:-2</code> (all but the two most significant
bits) and <code>-2:</code> (the two most significant bits):</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">slice_into_two_pieces</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u5</span><span class="p">:</span><span class="mb">0b11000</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="w"> </span><span class="n">hi</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="n">u3</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mb">0b000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dslx_reference-width-slice">Width Slice</h4>
<p>There is also a "width slice" form <code>x[start +: bits[N]]</code> - starting from a
specified bit, slice out the next <code>N</code> bits. This is equivalent to:
<code>bits[N]:(x &gt;&gt; start)</code>. The type can be specified as either signed or unsigned;
e.g. <code>[start +: s8]</code> will produce an 8-bit signed value starting at <code>start</code>,
whereas <code>[start +: u4]</code> will produce a 4-bit unsigned number starting at
<code>start</code>.</p>
<p><a href="https://github.com/google/xls/tree/main/xls/dslx/tests/bit_slice_syntax.x">Here are many more examples</a>:</p>
<h4 id="dslx_reference-bit-slice-examples">Bit Slice Examples</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// Identity function helper.</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">id</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_bit_slice_syntax</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u6</span><span class="p">:</span><span class="mb">0b100111</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Slice out two bits.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice out three bits.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b011</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice out from the end.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u4</span><span class="p">:</span><span class="mb">0b1001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u4</span><span class="p">:</span><span class="mb">0b1001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice both relative to the end (MSb).</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice out from the beginning (LSb).</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u5</span><span class="p">:</span><span class="mb">0b00111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u4</span><span class="p">:</span><span class="mb">0b0111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b111</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slicing past the end just means we hit the end (as in Python).</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mb">0b1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">6</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice of a slice.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b11</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[:</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Slice of an invocation.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Explicit-width slices.</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="p">:</span><span class="nc">u2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="p">:</span><span class="nc">s3</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="o">+</span><span class="p">:</span><span class="nc">u3</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_reference-advanced-understanding-parametricity-constraints-and-unification">Advanced Understanding: Parametricity, Constraints, and Unification</h3>
<p>An infamous wrinkle is introduced for parametric functions: consider the
following function:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// (Note: DSLX does not currently support the `T: type` construct shown here,</span>
<span class="c1">// it is for example purposes only.)</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">add_wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nc">type</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">:</span><span class="w"> </span><span class="nc">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>
</code></pre></div>
<p>Based on the inference rule, we know that '+' can only type check when the
operand types are the same. This means we can conclude that type <code>T</code> is the same
as type <code>U</code>. Once we determine this, we need to make sure anywhere <code>U</code> is used
it is consistent with the fact it is the same as <code>T</code>. In a sense the + operator
is "adding a constraint" that <code>T</code> is equivalent to <code>U</code>, and trying to check that
fact is valid is under the purview of type inference. The fact that the
constraint is added that <code>T</code> and <code>U</code> are the same type is referred to as
"unification", as what was previously two entities with potentially different
constraints now has a single set of constraints that comes from the union of its
operand types.</p>
<p>DSLX's typechecker will go through the body of parametric functions per
invocation. As such, the typechecker will always have the invocation's
parametric values for use in asserting type consistency against "constraints"
such as derived parametric expressions, body vs. annotated return type equality,
and expression inference rules.</p>
<h3 id="dslx_reference-operator-precedence">Operator Precedence</h3>
<p>DSLX's operator precedence matches Rust's. Listed below are DSLX's operators in
descending precedence order. Binary operators at the same level share the same
associativity and will be grouped accordingly.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(...)</code></td>
<td>n/a</td>
</tr>
<tr>
<td>unary <code>-</code> <code>!</code></td>
<td>n/a</td>
</tr>
<tr>
<td><code>as</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>+</code> <code>-</code> <code>++</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>\|</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>Left to right</td>
</tr>
</tbody>
</table>
<h2 id="dslx_reference-testing-and-debugging">Testing and Debugging</h2>
<p>DSLX allows specifying tests right in the implementation file via the <code>test</code> and
<code>quickcheck</code> directives.</p>
<p>Having key test code in the implementation file serves two purposes. It helps to
ensure the code behaves as expected. Additionally it serves as 'executable'
documentation, similar in spirit to Python doc strings.</p>
<h3 id="dslx_reference-unit-tests">Unit Tests</h3>
<p>Unit tests are specified by the <code>test</code> directive, as seen below:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_reverse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>The DSLX interpreter will execute all functions that are proceeded by a <code>test</code>
directive. These functions should be non-parametric, take no arguments, and
should return a unit-type.</p>
<p>Unless otherwise specified in the implementation's build configs, functions
called by unit tests are also converted to XLS IR and run through the
toolchain's LLVM JIT. The resulting values from the DSLX interpreter and the
LLVM JIT are compared against each other to assert equality. This is to ensure
DSLX implementations are IR-convertible and that IR translation is correct.</p>
<h4 id="dslx_reference-test-filtering">Test Filtering</h4>
<p>The DSLX main (runner) binary can also filter what tests are run from a file via
the <code>--test_filter=REGEXP</code> flag.</p>
<p>Unit tests run via Bazel can also be filtered via the typical Bazel
<code>--test_filter</code> flag; i.e.</p>
<div class="highlight"><pre><span></span><code>bazel test -c opt //xls/dslx/stdlib:apfloat_dslx_test --test_output=streamed
</code></pre></div>
<p>vs selecting one test:</p>
<div class="highlight"><pre><span></span><code>bazel test -c opt //xls/dslx/stdlib:apfloat_dslx_test --test_output=streamed --test_filter=one_x_one_plus_one_f32
</code></pre></div>
<p>vs selecting multiple tests to run via regular expression:</p>
<div class="highlight"><pre><span></span><code>bazel test -c opt //xls/dslx/stdlib:apfloat_dslx_test --test_output=streamed --test_filter=.*f32.*
</code></pre></div>
<h3 id="dslx_reference-quickcheck">QuickCheck</h3>
<p>QuickCheck is a <a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">testing framework concept</a> founded on
property-based testing. Instead of specifying expected and test values,
QuickCheck asks for properties of the implementation that should hold true
against any input of the specified type(s). In DSLX, we use the <code>quickcheck</code>
directive to designate functions to be run via the toolchain's QuickCheck
framework. Here is an example that complements the unit testing of DSLX's <code>rev</code>
implementation from above:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Reversing a value twice gets you the original value.</span>

<span class="cp">#[quickcheck]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">prop_double_reverse</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">rev</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>The DSLX interpreter will also execute all functions that are proceeded by a
<code>quickcheck</code> directive. These functions should be non-parametric and return a
<code>bool</code>. The framework will provide randomized input based on the types of the
arguments to the function (e.g. above, the framework will provided randomized
<code>u32</code>'s as <code>x</code>).</p>
<p>By default, the framework will run the function against 1000 sets of randomized
inputs. This default may be changed by specifying the <code>test_count</code> key in the
<code>quickcheck</code> directive before a particular test:</p>
<div class="highlight"><pre><span></span><code>#[quickcheck(test_count=50000)]
</code></pre></div>
<p>The framework also allows programmers to specify a seed to use in generating the
random inputs, as opposed to letting the framework pick one. The seed chosen for
production can be found in the execution log.</p>
<p>For determinism, the DSLX interpreter should be run with the <code>seed</code> flag:
<code>./interpreter_main --seed=1234 &lt;DSLX source file&gt;</code></p>
<h2 id="dslx_reference-communicating-sequential-processes-aka-procs">Communicating Sequential Processes (AKA procs)</h2>
<p>Functions conceptually exist independent of "time". They describe "feed forward"
dataflow computation; i.e. they cannot describe carrying a value forward over
"time steps", and don't have the ability to send messages to other functions
that are also iterating in time.</p>
<p>XLS has a more powerful construct for exactly this additional set of
capabilities, called <code>proc</code>s, short for "communicating process", in the
tradition of
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a>,
similar to those seen in Go, Erlang, and various other "actor model" programming
environments.</p>
<p>This is a simple proc:</p>
<div class="highlight"><pre><span></span><code><span class="n">proc</span><span class="w"> </span><span class="n">CountUp</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">output_channel</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Initial value for the state.</span>
<span class="w">    </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Configuration -- we get the output channel when we&#39;re configured by an external `spawn`.</span>
<span class="w">    </span><span class="c1">// The last statement in a `config` should be a tuple that is used to initialize the proc</span>
<span class="w">    </span><span class="c1">// members; e.g. we give a single value in a tuple that initializes the `output_channel`</span>
<span class="w">    </span><span class="c1">// declared above.</span>
<span class="w">    </span><span class="n">config</span><span class="p">(</span><span class="n">output_channel</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">output_channel</span><span class="p">,)</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// &quot;Iterate in time&quot; -- takes a state, does some work, and produces a new state.</span>
<span class="w">    </span><span class="n">next</span><span class="p">(</span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Send our state to the outside world via the channel.</span>
<span class="w">        </span><span class="n">send</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">output_channel</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Calculate our new state.</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This proc counts a 32-bit value upwards and sends it out on a channel. To do
things in time, beyond what functions do, you need some connections that work
for sending and receiving messages over time (<code>chan</code>) and some state that you
can carry over the course of time (<code>state</code>).</p>
<h3 id="dslx_reference-proc-syntax-template">Proc Syntax Template</h3>
<p>Procs are shaped as follows, generalizing what we saw in the <code>CountUp</code> proc
above:</p>
<div class="highlight"><pre><span></span><code>proc $NAME [$PARAMETRICS] {
    [MEMBER | CONST_ASSERT | TYPE_ALIAS]*

    init { $INIT_VALUE }

    // Note: config can contain `spawn`s of other `proc`s.
    config($CHAN_OR_ARG, ...) {
        $CONFIG_BODY
        ($MEMBER, ...)
    }

    next(state: $STATE_TYPE) {
        $NEXT_BODY
        $NEW_STATE
    }
}
</code></pre></div>
<p>Note that procs can be parameterized, similar to
<a href="#dslx_reference-parametric-functions">functions</a>, and that the proc scope can contain
<code>const_assert!</code>s and type aliases, which can be convenient to define within the
parameterized scope for all of the <code>init</code>/<code>config</code>/<code>next</code> function definitions.</p>
<p>Note that the <code>config</code> function is all evaluated at compile time (i.e. it is all
"constexpr" evaluated) -- this "configuration time" is a form of elaboration
where channels are connected and the communicating process hierarchy is created.</p>
<p>A proc can create a sub-proc via the <code>spawn</code> keyword, and this "spawning"
happens at configuration time, whereas <code>next</code> reflects the "runtime" execution;
e.g.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Though DSLX organizes procs into a tree based on <code>spawn</code>s the
underlying IR does not (yet) do so. This will be added with
<a href="#design_docs-proc_scoped_channels">proc-scoped channels</a>
but until then a proc is only considered to be connected to another proc if
there is some path of channel <code>recv</code>s and <code>send</code>s through which the two procs
communicate within their respective <code>next</code>s.</p>
<p>This means that 'spawner-procs' - procs which exist only to <code>spawn</code> a network
of other procs with no channels of their own - have somewhat strange
interactions with optimization. This most often causes spawned procs
to be removed from opt-ir outputs. This can be worked around by manually
setting top to a spawned procs. See below for more information.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If one wishes to spawn procs one may use an empty proc with only spawns in
the <code>config</code>, however one must manually set the <code>dslx_top</code> to the mangled name
of the spawned proc and have a separate <code>xls_ir_opt_ir</code> target for each spawned
proc independent group of procs. This can be used to instantiate a proc with
template parameters. For example see the
<a href="https://github.com/google/xls/tree/main/xls/examples/proc_iota.x">proc_iota.x</a> program and
the
<a href="https://github.com/google/xls/tree/main/xls/examples/BUILD;l=377">associated build targets</a>.
Note how the procs <code>spawn</code>ed by main are manually <code>opt_ir</code>d using the mangled
identifiers in the build-files instead of simply using the existing 'main' proc
to spawn them both. In almost all cases simply picking any random proc
instantiated in the proc-tree of the true <code>top</code> to act as <code>dslx_top</code> is
sufficient.</p>
</div>
<div class="highlight"><pre><span></span><code><span class="n">proc</span><span class="w"> </span><span class="n">Top</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Channel where we&#39;ll receive values from `CountUp`.</span>
<span class="w">    </span><span class="n">from_count_up</span><span class="p">:</span><span class="w"> </span><span class="nc">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">in</span><span class="p">;</span>

<span class="w">    </span><span class="n">init</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">config</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The &quot;chan&quot; constructor provides send (`out`) and receive (`in`)</span>
<span class="w">        </span><span class="c1">// port halves.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;my_chan&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Instantiate the `CountUp` proc which will talk to us using this channel half.</span>
<span class="w">        </span><span class="n">spawn</span><span class="w"> </span><span class="n">CountUp</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Initialize our member using the receive half of the channel we created.</span>
<span class="w">        </span><span class="p">(</span><span class="n">r</span><span class="p">,)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Receive the values sent from the `CountUp` proc we instantiated in</span>
<span class="w">    </span><span class="c1">// `config` and trace them out to logging.</span>
<span class="w">    </span><span class="n">next</span><span class="p">(</span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tok</span><span class="p">,</span><span class="w"> </span><span class="n">got</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">join</span><span class="p">(),</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">        </span><span class="n">trace_fmt</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;CountUp gave: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">got</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="footnote">
<hr />
<ol>
<li id="dslx_reference-fn:usebeforedef">
<p>Otherwise there'd be a use-before-definition error.&#160;<a class="footnote-backref" href="#dslx_reference-fnref:usebeforedef" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><section class="print-page" id="dslx_std"><h1 id="dslx_std-dslx-built-in-functions-and-standard-library">DSLX Built-In Functions and Standard Library</h1>
<p>This page documents the DSLX <strong>built-in functions</strong> (i.e. functions that don't
require an import and are available in the top level namespace) and <strong>standard
library modules</strong> (i.e. which are imported with an unqualified name like <code>import
std</code>).</p>
<p>Generally built-in functions have some capabilities that cannot be easily done
in a user-defined function, and thus do not live in the standard library.</p>
<div class="toc">
<ul>
<li><a href="#dslx_std-dslx-built-in-functions-and-standard-library">DSLX Built-In Functions and Standard Library</a><ul>
<li><a href="#dslx_std-built-ins">Built-ins</a><ul>
<li><a href="#dslx_std-add_with_carry">add_with_carry</a></li>
<li><a href="#dslx_std-array_size">array_size</a></li>
<li><a href="#dslx_std-widening_cast-and-checked_cast">widening_cast and checked_cast</a></li>
<li><a href="#dslx_std-smulp-and-umulp">smulp and umulp</a></li>
<li><a href="#dslx_std-map">map</a></li>
<li><a href="#dslx_std-zip">zip</a></li>
<li><a href="#dslx_std-array_rev">array_rev</a></li>
<li><a href="#dslx_std-const_assert">const_assert!</a></li>
<li><a href="#dslx_std-clz-ctz">clz, ctz</a></li>
<li><a href="#dslx_std-decode">decode</a></li>
<li><a href="#dslx_std-encode">encode</a></li>
<li><a href="#dslx_std-enumerate">enumerate</a></li>
<li><a href="#dslx_std-one_hot">one_hot</a></li>
<li><a href="#dslx_std-one_hot_sel">one_hot_sel</a></li>
<li><a href="#dslx_std-priority_sel">priority_sel</a></li>
<li><a href="#dslx_std-range">range</a></li>
<li><a href="#dslx_std-signex">signex</a></li>
<li><a href="#dslx_std-slice">slice</a></li>
<li><a href="#dslx_std-rev">rev</a></li>
<li><a href="#dslx_std-bit_slice_update">bit_slice_update</a></li>
<li><a href="#dslx_std-bit-wise-reductions-and_reduce-or_reduce-xor_reduce">bit-wise reductions: and_reduce, or_reduce, xor_reduce</a></li>
<li><a href="#dslx_std-update">update</a></li>
<li><a href="#dslx_std-assert_eq-assert_lt">assert_eq, assert_lt</a></li>
<li><a href="#dslx_std-zerot">zero!&lt;T&gt;</a></li>
<li><a href="#dslx_std-all_onest">all_ones!&lt;T&gt;</a></li>
<li><a href="#dslx_std-trace_fmt">trace_fmt!</a></li>
<li><a href="#dslx_std-fail-assert-assertion-failure">fail! / assert!: assertion failure</a></li>
<li><a href="#dslx_std-cover">cover!</a></li>
<li><a href="#dslx_std-gate">gate!</a></li>
</ul>
</li>
<li><a href="#dslx_std-proc-related-builtins-communicating-sequential-processes">proc-related builtins (Communicating Sequential Processes)</a><ul>
<li><a href="#dslx_std-join-sequencing-io-tokens">join: sequencing I/O tokens</a></li>
<li><a href="#dslx_std-send-send-a-value-on-a-channel">send: send a value on a channel</a></li>
<li><a href="#dslx_std-send_if-conditionally-send-a-value-on-a-channel">send_if: conditionally send a value on a channel</a></li>
<li><a href="#dslx_std-recv-blocking-receive-of-a-value-from-a-channel">recv: (blocking) receive of a value from a channel</a></li>
<li><a href="#dslx_std-recv_if-conditional-blocking-receive-of-a-value-from-a-channel">recv_if: conditional (blocking) receive of a value from a channel</a></li>
<li><a href="#dslx_std-recv_non_blocking-non-blocking-receive-of-a-value-from-a-channel">recv_non_blocking: non-blocking receive of a value from a channel</a></li>
<li><a href="#dslx_std-recv_if_non_blocking-conditional-non-blocking-receive-of-a-value-from-a-channel">recv_if_non_blocking: conditional non-blocking receive of a value from a channel</a></li>
</ul>
</li>
<li><a href="#dslx_std-import-std-dslx-standard-library-routines">import std: DSLX standard library routines</a><ul>
<li><a href="#dslx_std-bits-type-properties">Bits Type Properties</a><ul>
<li><a href="#dslx_std-std_min_value">std::?_min_value</a></li>
<li><a href="#dslx_std-std_max_value">std::?_max_value</a></li>
<li><a href="#dslx_std-stdsizeof">std::sizeof</a></li>
</ul>
</li>
<li><a href="#dslx_std-bit-manipulation-functions">Bit Manipulation Functions</a><ul>
<li><a href="#dslx_std-stdto_signed-stdto_unsigned">std::to_signed &amp; std::to_unsigned</a></li>
<li><a href="#dslx_std-stdlsb">std::lsb</a></li>
<li><a href="#dslx_std-stdmsb">std::msb</a></li>
<li><a href="#dslx_std-stdconvert_to_bits_msb0">std::convert_to_bits_msb0</a></li>
<li><a href="#dslx_std-stdconvert_to_bools_lsb0">std::convert_to_bools_lsb0</a></li>
<li><a href="#dslx_std-stdmask_bits">std::mask_bits</a></li>
<li><a href="#dslx_std-stdconcat3">std::concat3</a></li>
<li><a href="#dslx_std-stdrrot">std::rrot</a></li>
<li><a href="#dslx_std-stdpopcount">std::popcount</a></li>
<li><a href="#dslx_std-stdextract_bits">std::extract_bits</a></li>
<li><a href="#dslx_std-stdvslice">std::vslice</a></li>
</ul>
</li>
<li><a href="#dslx_std-mathematical-functions">Mathematical Functions</a><ul>
<li><a href="#dslx_std-stdbounded_minus_1">std::bounded_minus_1</a></li>
<li><a href="#dslx_std-stdabs">std::abs</a></li>
<li><a href="#dslx_std-stdis_pow2">std::is_pow2</a></li>
<li><a href="#dslx_std-stdadd">std::?add</a></li>
<li><a href="#dslx_std-stdmul">std::?mul</a></li>
<li><a href="#dslx_std-stditerative_div">std::iterative_div</a></li>
<li><a href="#dslx_std-stddiv_pow2">std::div_pow2</a></li>
<li><a href="#dslx_std-stdmod_pow2">std::mod_pow2</a></li>
<li><a href="#dslx_std-stdceil_div">std::ceil_div</a></li>
<li><a href="#dslx_std-stdround_up_to_nearest">std::round_up_to_nearest</a></li>
<li><a href="#dslx_std-stdround_up_to_nearest_pow2_">std::round_up_to_nearest_pow2_?</a></li>
<li><a href="#dslx_std-stdpow">std::?pow</a></li>
<li><a href="#dslx_std-stdclog2">std::clog2</a></li>
<li><a href="#dslx_std-stdflog2">std:flog2</a></li>
<li><a href="#dslx_std-stdmax">std::?max</a></li>
<li><a href="#dslx_std-stdmin">std::?min</a></li>
<li><a href="#dslx_std-stduadd_with_overflow">std::uadd_with_overflow</a></li>
<li><a href="#dslx_std-stdumul_with_overflow">std::umul_with_overflow</a></li>
</ul>
</li>
<li><a href="#dslx_std-misc-functions">Misc Functions</a><ul>
<li><a href="#dslx_std-signed-comparison-stdsge-sgt-sle-slt">Signed comparison - std::{sge, sgt, sle, slt}</a></li>
<li><a href="#dslx_std-stdfind_index">std::find_index</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dslx_std-import-acm_random">import acm_random</a><ul>
<li><a href="#dslx_std-acm_randomrng_deterministic_seed">acm_random::rng_deterministic_seed</a></li>
<li><a href="#dslx_std-acm_randomrng_new">acm_random::rng_new</a></li>
<li><a href="#dslx_std-acm_randomrng_next">acm_random::rng_next</a></li>
<li><a href="#dslx_std-acm_randomrng_next64">acm_random::rng_next64</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="dslx_std-built-ins">Built-ins</h2>
<p>This section describes the built-in functions provided for use in the DSL that
do not need to be explicitly imported.</p>
<p>Some of the built-ins have exlamation marks at the end; e.g. <code>assert!</code> --
exclamation marks in DSLX indicate built-in functions that have special
facilities that normal functions are not capable of. This is intended to help
the user discern when they're calling "something that will behave like a normal
function" versus "something that has special abilities beyond normal functions,
e.g. special side-effects".</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A brief note on "Parallel Primitives": the DSL is expected to grow
additional support for use of high-level parallel primitives over time, adding
operators for order-insensitive reductions, scans, groupings, and similar. By
making these operations known to the compiler in their high level form, we
potentially enable optimizations and analyses on their higher level ("lifted")
form. As of now, <code>map</code> is the sole parallel-primitive-oriented built-in.</p>
</div>
<h3 id="dslx_std-add_with_carry"><code>add_with_carry</code></h3>
<p>Operation that produces the result of the add, as well as the carry bit as an
output. The binary add operators works similar to software programming
languages, preserving the length of the input operands, so this built-in can
assist when easy access to the carry out value is desired. Has the following
signature:</p>
<div class="highlight"><pre><span></span><code>fn add_with_carry&lt;N&gt;(x: uN[N], y: uN[N]) -&gt; (u1, uN[N])
</code></pre></div>
<h3 id="dslx_std-array_size"><code>array_size</code></h3>
<p><code>array_size</code> returns the number of elements in a given array-typed argument.</p>
<div class="highlight"><pre><span></span><code>fn array_size&lt;T: type, N: u32&gt;(x: T[N]) -&gt; u32
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_array_size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_size</span><span class="p">(</span><span class="kt">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_size</span><span class="p">(</span><span class="kt">u8</span><span class="p">[</span><span class="mi">1</span><span class="p">]:[</span><span class="mi">42</span><span class="p">]),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-widening_cast-and-checked_cast"><code>widening_cast</code> and <code>checked_cast</code></h3>
<p><code>widening_cast</code> and <code>checked_cast</code> cast bits-type values to bits-type values
with additional checks compared to casting with <code>as</code>.</p>
<p><code>widening_cast</code> will report a static error if the type casted to is unable to
respresent all values of the type casted from (ex. <code>widening_cast&lt;u5&gt;(s3:0)</code>
will fail because s3:-1 cannot be respresented as an unsigned number).</p>
<p><code>checked_cast</code> will cause a runtime error during dslx interpretation if the
value being casted is unable to fit within the type casted to (ex.
<code>checked_cast&lt;u5&gt;(s3:0)</code> will succeed while <code>checked_cast&lt;u5&gt;(s3:-1)</code> will cause
the dslx interpreter to fail.</p>
<p>Currently both <code>widening_cast</code> and <code>checked_cast</code> will lower into a normal IR
cast and will not generate additional assertions at the IR or Verilog level.</p>
<div class="highlight"><pre><span></span><code>fn widening_cast&lt;sN[N]&gt;(value: uN[M]) -&gt; sN[N]; where N &gt; M
fn widening_cast&lt;sN[N]&gt;(value: sN[M]) -&gt; sN[N]; where N &gt;= M
fn widening_cast&lt;uN[N]&gt;(value: uN[M]) -&gt; uN[N]; where N &gt;= M

fn checked_cast&lt;xN[M]&gt;(value: uN[N]) -&gt; xN[M]
fn checked_cast&lt;xN[M]&gt;(value: sN[N]) -&gt; xN[M]
</code></pre></div>
<h3 id="dslx_std-smulp-and-umulp"><code>smulp</code> and <code>umulp</code></h3>
<p><code>smulp</code> and <code>umulp</code> perform signed and unsigned partial multiplications. These
operations return a two-element tuple with the property that the sum of the two
elements is equal to the product of the original inputs. Performing a partial
multiplication allows for a pipeline stage in the middle of a multiply. These
operations have the following signatures:</p>
<div class="highlight"><pre><span></span><code>fn smulp&lt;N&gt;(lhs: sN[N], rhs: sN[N]) -&gt; (sN[N], sN[N])
fn umulp&lt;N&gt;(lhs: uN[N], rhs: uN[N]) -&gt; (uN[N], uN[N])
</code></pre></div>
<h3 id="dslx_std-map"><code>map</code></h3>
<p><code>map</code>, similarly to other languages, executes a transformation function on all
the elements of an original array to produce the resulting "mapped' array.
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/map_of_stdlib_parametric.x">For example</a>:
taking the absolute value of each element in an input array:</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">std</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">abs</span><span class="p">);</span>
<span class="w">  </span><span class="n">y</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">main_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">got</span><span class="p">:</span><span class="w"> </span><span class="nc">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">got</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that map is special, in that we can pass it a callee <em>as if</em> it were a
value. As a function that "takes" a function as an argument, <code>map</code> is a special
built-in -- in language implementor parlance it is a <em>higher order function</em>.</p>
<p>Implementation note: Functions are not first class values in the DSL, so the
name of the function must be referred to directly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Novel higher order functions (e.g. if a user wanted to write their own
<code>map</code>) cannot currently be written in user-level DSL code.</p>
</div>
<h3 id="dslx_std-zip"><code>zip</code></h3>
<p><code>zip</code> places elements of two same-sized arrays together in an array of 2-tuples.</p>
<p>Its signature is: <code>zip(lhs: T[N], rhs: U[N]) -&gt; (T, U)[N]</code>.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_zip_array_size_1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">LHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">1</span><span class="p">]:[</span><span class="mi">42</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u16</span><span class="p">[</span><span class="mi">1</span><span class="p">]:[</span><span class="mi">64</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">WANT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">:</span><span class="mi">64</span><span class="p">)];</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">zip</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">),</span><span class="w"> </span><span class="n">WANT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_zip_array_size_2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">zip</span><span class="p">(</span><span class="kt">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">]:[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="kt">u64</span><span class="p">[</span><span class="mi">2</span><span class="p">]:[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">]),</span><span class="w"> </span><span class="p">[(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">:</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">:</span><span class="mi">11</span><span class="p">)]);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-array_rev"><code>array_rev</code></h3>
<p><code>array_rev</code> reverses the elements of an array.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_array_rev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_rev</span><span class="p">(</span><span class="kt">u8</span><span class="p">[</span><span class="mi">1</span><span class="p">]:[</span><span class="mi">42</span><span class="p">]),</span><span class="w"> </span><span class="kt">u8</span><span class="p">[</span><span class="mi">1</span><span class="p">]:[</span><span class="mi">42</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_rev</span><span class="p">(</span><span class="n">u3</span><span class="p">[</span><span class="mi">2</span><span class="p">]:[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]),</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">2</span><span class="p">]:[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_rev</span><span class="p">(</span><span class="n">u3</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]),</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_rev</span><span class="p">(</span><span class="n">u4</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mh">0xf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="n">u4</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">array_rev</span><span class="p">(</span><span class="n">u3</span><span class="p">[</span><span class="mi">0</span><span class="p">]:[]),</span><span class="w"> </span><span class="n">u3</span><span class="p">[</span><span class="mi">0</span><span class="p">]:[]);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-const_assert"><code>const_assert!</code></h3>
<p>Performs a check on a constant expression that only fails at compile-time (not
at runtime).</p>
<p>Note that this can only be applied to compile-time-constant expressions.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_const_assert</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="n">const_assert</span><span class="o">!</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Keep in mind that all <code>const_assert!</code>s in a function evaluate, similar to
<code>static_assert</code> in C++ -- they are effectively part of the type system, so you
cannot suppress them by putting them in a conditional:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">const_assert</span><span class="o">!</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">  </span><span class="c1">// &lt;-- still fails even inside the &quot;if false&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-clz-ctz"><code>clz</code>, <code>ctz</code></h3>
<p>DSLX provides the common "count leading zeroes" and "count trailing zeroes"
functions:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0x0FFFFFF8</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clz</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctz</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span>
</code></pre></div>
<h3 id="dslx_std-decode"><code>decode</code></h3>
<p>Converts a binary-encoded value into a one-hot value. For an operand value of
<code>n``interpreted as an unsigned number, the</code>n<code>-th result bit and only the</code>n`-th
result bit is set. Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn decode&lt;uN[W]&gt;(x: uN[N]) -&gt; uN[W]
</code></pre></div>
<p>The width of the decode operation may be less than the maximum value expressible
by the input (<code>2**N - 1</code>). If the encoded operand value is larger than the
number of bits of the result, the result is zero.</p>
<p>Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/decode.x"><code>dslx/tests/decode.x</code></a>.</p>
<p>See also the
<a href="#ir_semantics-decode">IR semantics for the <code>decode</code> op</a>.</p>
<h3 id="dslx_std-encode"><code>encode</code></h3>
<p>Converts a one-hot value to a binary-encoded value of the "hot" bit of the
input. If the <code>n</code>-th bit and only the <code>n</code>-th bit of the operand is set, the
result is equal to the value <code>n</code> as an unsigned number. Has the following
signature:</p>
<div class="highlight"><pre><span></span><code>fn encode(x: uN[N]) -&gt; uN[ceil(log2(N))]
</code></pre></div>
<p>If multiple bits of the input are set, the result is equal to the logical or of
the results produced by the input bits individually. For example, if bit 3 and
bit 5 of an encode input are set the result is equal to <code>3 | 5 = 7</code>.</p>
<p>Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/encode.x"><code>dslx/tests/encode.x</code></a>.</p>
<p>See also the
<a href="#ir_semantics-encode">IR semantics for the <code>encode</code> op</a>.</p>
<h3 id="dslx_std-enumerate"><code>enumerate</code></h3>
<p>Decorates elements of an array with indices. Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn enumerate&lt;T: type, N: u32&gt;(x: T[N]) -&gt; (u32, T)[N]
</code></pre></div>
<h3 id="dslx_std-one_hot"><code>one_hot</code></h3>
<p>Converts a value to one-hot form. Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn one_hot&lt;N: u32, NP1:u32={N+1}&gt;(x: uN[N], lsb_is_prio: bool) -&gt; uN[NP1]
</code></pre></div>
<p>When <code>lsb_is_prio</code> is true, the least significant bit that is set becomes the
one-hot bit in the result. When it is false, the most significant bit that is
set becomes the one-hot bit in the result.</p>
<p>When all bits in the input are unset, the additional bit present in the output
value (MSb) becomes set.</p>
<p>Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/one_hot.x"><code>dslx/tests/one_hot.x</code></a>.</p>
<p>See also the
<a href="#ir_semantics-one_hot">IR semantics for the <code>one_hot</code> op</a>.</p>
<h3 id="dslx_std-one_hot_sel"><code>one_hot_sel</code></h3>
<p>Produces the result of 'or'-ing all case values for which the corresponding bit
of the selector is enabled. In cases where the selector has exactly one bit set
(it is in one-hot form) this is equivalent to a match.</p>
<div class="highlight"><pre><span></span><code>fn one_hot_sel(selector: uN[N], cases: xN[N][M]) -&gt; uN[N]
</code></pre></div>
<p>Evaluates each case value and <code>or</code>s each case together if the corresponding bit
in the selector is set. The first element of <code>cases</code> is included if the LSB is
set, the second if the next least significant bit and so on. If no selector bits
are set this evaluates to zero. This function is not generally used directly
though the compiler will when possible synthesize the equivalent code from a
<code>match</code> expression.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is included largely for testing purposes and for bespoke
'intrinsic-style programming' use cases.</p>
</div>
<h3 id="dslx_std-priority_sel"><code>priority_sel</code></h3>
<p>Implements a priority selector. Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn priority_sel(selector: uN[N], cases: xN[S][M][N]) -&gt; xN[S][M]
</code></pre></div>
<p>That is, the selector is <code>N</code> bits, and we give <code>N</code> cases to choose from of
<code>M</code>-bit values of arbitrary signedness.</p>
<p>If the selector is zero, the zero-value (of the result type) is returned.</p>
<p>Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/priority_sel.x"><code>dslx/tests/priority_sel.x</code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator is only defined for bits types because other types do not
have defined or-operators, and conceptually <code>priority_sel</code> desugars to a masked
or-reduction, which is why it produces the zero value when nothing is selected.</p>
</div>
<h3 id="dslx_std-range"><code>range</code></h3>
<p>Returns an array filled with the sequence from inclusive <code>START</code> to exclusive
<code>LIMIT</code>. Note that <code>START</code> and <code>LIMIT</code> must be compile-time-constant values (AKA
"constexpr"). It is compile-time-checked by the type system that <code>LIMIT &gt;=
START</code>.</p>
<div class="highlight"><pre><span></span><code>fn range(START: const uN, LIMIT: const uN) -&gt; uN[{LIMIT-START}]
</code></pre></div>
<h3 id="dslx_std-signex"><code>signex</code></h3>
<p>Casting has well-defined extension rules, but in some cases it is necessary to
be explicit about sign-extensions, if just for code readability. For this, there
is the <code>signex</code> built-in.</p>
<p>To invoke the <code>signex</code> built-in, provide it with the operand to sign extend
(lhs), as well as the target type to extend to: these operands may be either
signed or unsigned. Note that the <em>value</em> of the right hand side is ignored,
only its type is used to determine the result type of the sign extension.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_signex</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="nc">s32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">s32</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">u</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that both <code>s</code> and <code>u</code> contain the same bits in the above example.</p>
<h3 id="dslx_std-slice"><code>slice</code></h3>
<p>Array-slice built-in operation. Note that the "want" argument is <em>not</em> used as a
value, but is just used to reflect the desired slice type. (Prior to constexprs
being passed to built-in functions, this was the canonical way to reflect a
constexpr in the type system.) Has the following signature:</p>
<div class="highlight"><pre><span></span><code>fn slice&lt;T: type, N, M, S&gt;(xs: T[N], start: uN[M], want: T[S]) -&gt; T[S]
</code></pre></div>
<h3 id="dslx_std-rev"><code>rev</code></h3>
<p><code>rev</code> is used to reverse the bits in an unsigned bits value. The LSb in the
input becomes the MSb in the result, the 2nd LSb becomes the 2nd MSb in the
result, and so on.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// (Dummy) wrapper around reverse.</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">wrapper</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rev</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Target for IR conversion that works on u3s.</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u3</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Reverse examples.</span>
<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_reverse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b10</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b01</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">u2</span><span class="p">:</span><span class="mb">0b00</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-bit_slice_update"><code>bit_slice_update</code></h3>
<p><code>bit_slice_update(subject, start, value)</code> returns a copy of the bits-typed value
<code>subject</code> where the contiguous bits starting at index <code>start</code> (where 0 is the
least-significant bit) are replaced with <code>value</code>. The bit-width of the returned
value is the same as the bit-width of <code>subject</code>. Any updated bit indices which
are out of bounds (if <code>start + bit-width(value) &gt;= bit-width(subject)</code>) are
ignored. Example usage:
<a href="https://github.com/google/xls/tree/main/xls/dslx/tests/bit_slice_update.x"><code>dslx/tests/bit_slice_update.x</code></a>.</p>
<h3 id="dslx_std-bit-wise-reductions-and_reduce-or_reduce-xor_reduce">bit-wise reductions: <code>and_reduce</code>, <code>or_reduce</code>, <code>xor_reduce</code></h3>
<p>These are unary reduction operations applied to a bits-typed value:</p>
<ul>
<li><code>and_reduce</code>: evaluates to bool:1 if all bits of the input are set, and 0
    otherwise.</li>
<li><code>or_reduce</code>: evaluates to bool:1 if any bit of the input is set, and 0
    otherwise.</li>
<li><code>xor_reduce</code>: evaluates to bool:1 if there is an odd number of bits set in
    the input, and 0 otherwise.</li>
</ul>
<p>These functions return the identity element of the respective operation for
trivial (0 bit wide) inputs:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_trivial_reduce</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">and_reduce</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">or_reduce</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">xor_reduce</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-update"><code>update</code></h3>
<p><code>update(array, index, new_value)</code> returns a copy of <code>array</code> where <code>array[index]</code>
has been replaced with <code>new_value</code>, and all other elements are unchanged.
<code>index</code> can either be a scalar index or a tuple when updating nested element(s)
of multi-dimensional array. Note that this is <em>not</em> an in-place update of the
array, it is an "evolution" of <code>array</code>. It is the compiler's responsibility to
optimize by using mutation instead of copying, when it's safe to do. The
compiler makes a best effort to do this, but can't guarantee the optimization is
always made.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_update</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">update</span><span class="p">([</span><span class="kt">u8</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">]);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">update</span><span class="p">([[</span><span class="kt">u8</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">4</span><span class="p">]],</span>
<span class="w">                   </span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="p">[[</span><span class="kt">u8</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">4</span><span class="p">]]);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-assert_eq-assert_lt"><code>assert_eq</code>, <code>assert_lt</code></h3>
<p>In a unit test pseudo function all valid DSLX code is allowed. To evaluate test
results DSLX provides the <code>assert_eq</code> primitive (we'll add more of those in the
future). Here is an example of a <code>divceil</code> implementation with its corresponding
tests:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">divceil</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_divceil</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">divceil</span><span class="p">(</span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p><code>assert_eq</code> cannot currently be synthesized into equivalent Verilog. Because of
that it is recommended to use it within <code>test</code> constructs (interpretation) only.</p>
<h3 id="dslx_std-zerot"><code>zero!&lt;T&gt;</code></h3>
<p>DSLX has a macro for easy creation of zero values, even from aggregate types.
Invoke the macro with the type parameter as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">MyPoint</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MyEnum</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_zero_macro</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">zero</span><span class="o">!&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">zero</span><span class="o">!&lt;</span><span class="n">MyPoint</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">MyPoint</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">});</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">zero</span><span class="o">!&lt;</span><span class="n">MyEnum</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">MyEnum</span><span class="p">::</span><span class="n">ZERO</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>zero!&lt;T&gt;</code> macro can also be used with the struct update syntax to
initialize a subset of fields to zero. In the example below all fields except
<code>foo</code> are initialized to zero in the struct returned by <code>f</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">foo</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bar</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">,</span>
<span class="w">  </span><span class="n">baz</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">,</span>
<span class="w">  </span><span class="n">bat</span><span class="p">:</span><span class="w"> </span><span class="nc">u4</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyStruct</span><span class="p">{</span><span class="n">foo</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="n">zero</span><span class="o">!&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span><span class="p">()}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-all_onest"><code>all_ones!&lt;T&gt;</code></h3>
<p>Similar to <code>zero!&lt;T&gt;</code>, DSLX has a macro for easy creation of all-ones values,
even from aggregate types. Invoke the macro with the type parameter as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">MyPoint</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MyEnum</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">THREE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_all_ones_macro</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">all_ones</span><span class="o">!&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xFFFFFFFF</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">all_ones</span><span class="o">!&lt;</span><span class="n">MyPoint</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">MyPoint</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0xFFFFFFFF</span><span class="p">});</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">all_ones</span><span class="o">!&lt;</span><span class="n">MyEnum</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">MyEnum</span><span class="p">::</span><span class="n">THREE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>all_ones!&lt;T&gt;</code> macro can also be used with the struct update syntax to
initialize a subset of fields to zero. In the example below all fields except
<code>foo</code> are initialized to zero in the struct returned by <code>f</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">foo</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">,</span>
<span class="w">  </span><span class="n">bar</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="p">,</span>
<span class="w">  </span><span class="n">baz</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">,</span>
<span class="w">  </span><span class="n">bat</span><span class="p">:</span><span class="w"> </span><span class="nc">u4</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyStruct</span><span class="p">{</span><span class="n">foo</span><span class="p">:</span><span class="w"> </span><span class="nc">u1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="n">all_ones</span><span class="o">!&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span><span class="p">()}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_std-trace_fmt"><code>trace_fmt!</code></h3>
<p>DSLX supports printf-style debugging via the <code>trace_fmt!</code> builtin, which allows
dumping of current values to stdout. For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Note: to see `trace_fmt!` output you need to be seeing `INFO` level logging,</span>
<span class="c1">// enabled by adding the &#39;--alsologtostderr&#39; flag to the command line (among</span>
<span class="c1">// other means). For example:</span>
<span class="c1">// bazel run -c opt //xls/dslx:interpreter_main  /path/to/dslx/file.x -- --alsologtostderr</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">shifty</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">u3</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">trace_fmt</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;x: {:x} y: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Note: y looks different as a negative number when the high bit is set.</span>
<span class="w">  </span><span class="n">trace_fmt</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;y as s8: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_shifty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">shifty</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mh">0x20</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">shifty</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>would produce the following output, with each trace being annotated with its
corresponding source position:</p>
<div class="highlight"><pre><span></span><code>[...]
[ RUN UNITTEST  ] test_shifty
I0607 10:11:02.897455  810431 shifty.x:6] x: 42 y: 4
I0607 10:11:02.897462  810431 shifty.x:8] y as s8: 0
I0607 10:11:02.908182  810431 shifty.x:6] x: 42 y: 7
I0607 10:11:02.908208  810431 shifty.x:8] y as s8: -1
[            OK ]
[...]
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>trace!</code> currently exists as a builtin but is in the process of being
removed, as it provided the user with only a "global flag" way of specifying the
desired format for output values -- <code>trace_fmt!</code> is more powerful.</p>
</div>
<h3 id="dslx_std-fail-assert-assertion-failure"><code>fail!</code> / <code>assert!</code>: assertion failure</h3>
<p>The <code>fail!</code> builtin indicates a path that should not be reachable in practice.
Its general signature is:</p>
<div class="highlight"><pre><span></span><code>fail!(label: u8[N], fallback_value: T) -&gt; T
</code></pre></div>
<p>The <code>assert!</code> builtin is similar to fail, but takes a predicate, and does not
produce a value:</p>
<div class="highlight"><pre><span></span><code>assert!(predicate: bool, label: u8[N]) -&gt; ()
</code></pre></div>
<p>These can be thought of as "fatal assertions", and convert to
Verilog/SytemVerilog assertions in generated code.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>XLS hopes to permit users to optionally insert fatal-error-signaling
hardware that correspond to these operations. See
https://github.com/google/xls/issues/1352</p>
</div>
<p><code>fail!</code> indicates a <strong>control path that should not be reachable</strong>, <code>assert!</code>
gives a <strong>predicate that should always be true</strong> when the statement is reached.</p>
<p>If triggered, these raise a fatal error in simulation (e.g. via a JIT-execution
failure status or a Verilog assertion when running in RTL simulation).</p>
<p>Assuming <code>fail!</code> will not be triggered minimizes its cost in synthesized form.
In this situation, <strong>when it is "erased", it acts as the identity function</strong>,
providing the <code>fallback_value</code>. This allows XLS to keep well defined semantics
even when fatal assertion hardware is not present.</p>
<p><strong>Example <code>assert!</code>:</strong> if there is a function that should never be invoked with
the value <code>42</code> as a precondition:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="fm">assert!</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x_never_forty_two&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Example <code>fail!</code>:</strong> if only these two enum values shown should be possible
(say, as a documented <a href="https://en.wikipedia.org/wiki/Precondition">precondition</a>
for <code>main</code>):</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="nc">EnumType</span><span class="p">:</span><span class="w"> </span><span class="nc">u2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FIRST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">SECOND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">EnumType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EnumType</span><span class="p">::</span><span class="n">FIRST</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">EnumType</span><span class="p">::</span><span class="n">SECOND</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// This should not be reachable.</span>
<span class="w">    </span><span class="c1">// But, if we synthesize hardware, under this condition the function is</span>
<span class="w">    </span><span class="c1">// well-defined to give back zero.</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fail</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;unknown_EnumType&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="p">),</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>fail!("unknown_EnumType", u32:0)</code> above indicates that a) that match arm
<em>should</em> not be reached (and if it is in the JIT or RTL simulation it will cause
an error status or assertion failure respectively), but b) provides a fallback
value to use (of the appropriate type) in case it were to happen in synthesized
gates which did not insert fatal-error-indicating hardware.</p>
<p>The associated label (e.g. the first argument to <code>fail!</code>) must be a valid
Verilog identifier and is used for identifying the failure when lowered to
SystemVerilog. At higher levels in the stack, it's unused.</p>
<h3 id="dslx_std-cover"><code>cover!</code></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, <code>cover!</code> has no effect in RTL simulators supported in XLS open
source (i.e. iverilog). See
<a href="https://github.com/google/xls/issues/436">google/xls#436</a>.</p>
</div>
<p>The <code>cover!</code> builtin tracks how often some condition is satisfied. It desugars
into SystemVerilog cover points. Its signature is:</p>
<div class="highlight"><pre><span></span><code>cover!(&lt;name&gt;, &lt;condition&gt;);
</code></pre></div>
<p>Where <code>name</code> is a function-unique literal string identifying the coverpoint and
<code>condition</code> is a boolean element. When <code>condition</code> is true, a counter with the
given name is incremented that can be inspected upon program termination.
Coverpoints can be used to give an indication of code "coverage", i.e. to see
what paths of a design are exercised in practice. The name of the coverpoint
must begin with either a letter or underscore, and its remainder must consist of
letters, digits, underscores, or dollar signs.</p>
<h3 id="dslx_std-gate"><code>gate!</code></h3>
<p>The <code>gate!</code> built-in is used for operand gating, of the form:</p>
<div class="highlight"><pre><span></span><code>let gated_value = gate!(&lt;pass_value&gt;, &lt;value&gt;);
</code></pre></div>
<p>This will generally use a special Verilog macro to avoid the underlying
synthesis tool doing boolean optimization, and will turn <code>gated_value</code> to <code>0</code>
when the predicate <code>pass_value</code> is <code>false</code>. This can be used in attempts to
manually avoid toggles based on the gating predicate.</p>
<p>It is expected that XLS will grow facilities to inserting gating ops
automatically, but manual user insertion is a practical step in this direction.
Additionally, it is expected that if, in the resulting Verilog, gating occurs on
a value that originates from a flip flop, the operand gating may be promoted to
register-based load-enable gating.</p>
<h2 id="dslx_std-proc-related-builtins-communicating-sequential-processes"><code>proc</code>-related builtins (Communicating Sequential Processes)</h2>
<h3 id="dslx_std-join-sequencing-io-tokens"><code>join</code>: sequencing I/O tokens</h3>
<p>The <code>join</code> builtin "joins together" a variable number of tokens into one
token -- this resulting token represents that an I/O operation happens "no
earlier than" all the given tokens. That is, it establishes a <code>&gt;=</code> event
ordering with respect to all the parameter tokens.</p>
<div class="highlight"><pre><span></span><code>join(token...) -&gt; token
</code></pre></div>
<p>This is useful to a user that wants to sequence their I/O operations, e.g.
ensuring that two earlier I/O operations happen before a later I/O operation can
begin.</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">token0</span><span class="p">,</span><span class="w"> </span><span class="n">value0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">chan0</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">token1</span><span class="p">,</span><span class="w"> </span><span class="n">value1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">chan1</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">joined</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">token0</span><span class="p">,</span><span class="w"> </span><span class="n">token1</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">token2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span><span class="w"> </span><span class="n">chan2</span><span class="p">,</span><span class="w"> </span><span class="n">another_value</span><span class="p">);</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this routine can only be used in the body of a <code>proc</code>.</p>
</div>
<h3 id="dslx_std-send-send-a-value-on-a-channel"><code>send</code>: send a value on a channel</h3>
<p>The <code>send</code> builtin sends a value on a channel, taking an I/O sequencing token
and producing a new I/O sequencing token (which can be used to order
communication events).</p>
<div class="highlight"><pre><span></span><code>send(tok: token, chan&lt;T&gt; out, value: T) -&gt; token
</code></pre></div>
<h3 id="dslx_std-send_if-conditionally-send-a-value-on-a-channel"><code>send_if</code>: conditionally send a value on a channel</h3>
<div class="highlight"><pre><span></span><code>send_if(tok: token, chan&lt;T&gt; out, predicate: bool, value: T) -&gt; token
</code></pre></div>
<p>The <code>send_if</code> builtin does a send on a channel as described in [<code>send</code>][#send],
but only attempts to do so if the given predicate is true.</p>
<h3 id="dslx_std-recv-blocking-receive-of-a-value-from-a-channel"><code>recv</code>: (blocking) receive of a value from a channel</h3>
<p>The <code>recv</code> builtin does a "blocking" <code>recv</code> of a value from a channel -- it is
blocking in the sense that the current activation of the <code>proc</code> cannot complete
until the <code>recv</code> has been performed. The token that the <code>recv</code> produces can be
used to force a sequencing of the <code>recv</code> with respect to other I/O operations.</p>
<div class="highlight"><pre><span></span><code>recv(tok: token, c: chan&lt;T&gt; in) -&gt; (token, T)
</code></pre></div>
<h3 id="dslx_std-recv_if-conditional-blocking-receive-of-a-value-from-a-channel"><code>recv_if</code>: conditional (blocking) receive of a value from a channel</h3>
<p>The <code>recv_if</code> builtin does a blocking receive as described in [<code>recv</code>][#recv],
but only attempts to do so if the given predicate is true.</p>
<div class="highlight"><pre><span></span><code>recv_if(tok: token, c: chan&lt;T&gt; in, predicate: bool, default_value: T) -&gt; (token, T)
</code></pre></div>
<h3 id="dslx_std-recv_non_blocking-non-blocking-receive-of-a-value-from-a-channel"><code>recv_non_blocking</code>: non-blocking receive of a value from a channel</h3>
<p>Performs a non-blocking receive from channel <code>c</code> -- if the channel is empty the
<code>default_value</code> is returned as the result, and the <code>bool</code> in the result
indicates whether the value originated from the channel (i.e. <code>true</code> means the
value came from the channel).</p>
<div class="highlight"><pre><span></span><code>recv_non_blocking(tok: token, c: chan&lt;T&gt; in, default_value: T) -&gt; (token, T, bool)
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>non-blocking operations make a block latency sensitive and can no longer
be described as pure "Kahn Process Networks", which means that the design's
correctness is more sensitive to the chosen schedule, and thus design
verification should occur on the scheduled design.</p>
</div>
<h3 id="dslx_std-recv_if_non_blocking-conditional-non-blocking-receive-of-a-value-from-a-channel"><code>recv_if_non_blocking</code>: conditional non-blocking receive of a value from a channel</h3>
<p>As <code>recv_non_blocking</code> is above, but with an additional predicate that indicates
whether we should attempt to do the nonblocking receive from the channel. If
this predicate is false, the default value will be provided and the returned
boolean will be false.</p>
<div class="highlight"><pre><span></span><code>recv_if_non_blocking(tok: token, c: chan&lt;T&gt; in, predicate: bool, default_value: T) -&gt; (token, T, bool)
</code></pre></div>
<h2 id="dslx_std-import-std-dslx-standard-library-routines"><code>import std</code>: DSLX standard library routines</h2>
<h3 id="dslx_std-bits-type-properties">Bits Type Properties</h3>
<h4 id="dslx_std-std_min_value"><code>std::?_min_value</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">unsigned_min_value</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">signed_min_value</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns the minimum signed or unsigned value contained in N bits.</p>
<h4 id="dslx_std-std_max_value"><code>std::?_max_value</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">unsigned_max_value</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">signed_max_value</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</code></pre></div>
<p>Returns the maximum signed or unsigned value contained in N bits.</p>
<h4 id="dslx_std-stdsizeof"><code>std::sizeof</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sizeof</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">xN</span><span class="p">[</span><span class="n">S</span><span class="p">][</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span>
</code></pre></div>
<p>Returns the number of bits (<code>sizeof</code>) of unsigned or signed bit value. The
signature above is parameterized on the signedness of the input type.</p>
<h3 id="dslx_std-bit-manipulation-functions">Bit Manipulation Functions</h3>
<h4 id="dslx_std-stdto_signed-stdto_unsigned"><code>std::to_signed</code> &amp; <code>std::to_unsigned</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_signed</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_unsigned</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>Convenience helper that converts an unsigned bits argument to its same-sized
signed type, or visa-versa. This is morally equivalent to (but slightly more
convenient than) a pattern like:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">sN</span><span class="p">[</span><span class="n">std</span><span class="p">::</span><span class="n">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
</code></pre></div>
<h4 id="dslx_std-stdlsb"><code>std::lsb</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">lsb</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u1</span>
</code></pre></div>
<p>Extracts the LSb (Least Significant bit) from the value <code>x</code> and returns it.</p>
<h4 id="dslx_std-stdmsb"><code>std::msb</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">msb</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u1</span>
</code></pre></div>
<p>Extracts the MSb (Most Significant bit) from the value <code>x</code> and returns it.</p>
<h4 id="dslx_std-stdconvert_to_bits_msb0"><code>std::convert_to_bits_msb0</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">convert_to_bits_msb0</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Converts an array of <code>N</code> bools to a <code>bits[N]</code> value.</p>
<p><strong>Note well:</strong> the boolean value at <strong>index 0</strong> of the array becomes the <strong>most
significant bit</strong> in the resulting bit value. Similarly, the last index of the
array becomes the <strong>least significant bit</strong> in the resulting bit value.</p>
<div class="highlight"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">std</span><span class="p">;</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">convert_to_bits_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b001</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">convert_to_bits_msb0</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">]));</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">u3</span><span class="p">:</span><span class="mb">0b100</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">convert_to_bits_msb0</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">3</span><span class="p">]:[</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></div>
<p>There's always a source of confusion in these orderings:</p>
<ul>
<li>Mathematically we often indicate the least significant digit as "digit 0"</li>
<li><em>But</em>, in a number as we write the digits from left-to-right on a piece of
  paper, if you made an array from the written characters, the digit at "array
  index 0" would be the most significant bit.</li>
</ul>
<p>So, it's somewhat ambiguous whether "index 0" in the array would become the
least significant bit or the most significant bit. This routine uses the "as it
looks on paper" conversion; e.g. <code>[true, false, false]</code> becomes <code>0b100</code>.</p>
<h4 id="dslx_std-stdconvert_to_bools_lsb0"><code>std::convert_to_bools_lsb0</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fn</span><span class="w"> </span><span class="n">convert_to_bools_lsb0</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Convert a "word" of bits to a corresponding array of booleans.</p>
<p><strong>Note well:</strong> The least significant bit of the word becomes index 0 in the
array.</p>
<h4 id="dslx_std-stdmask_bits"><code>std::mask_bits</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">mask_bits</span><span class="o">&lt;</span><span class="n">X</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">X</span><span class="p">]</span>
</code></pre></div>
<p>Returns a value with X bits set (of type bits[X]).</p>
<h4 id="dslx_std-stdconcat3"><code>std::concat3</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">concat3</span><span class="o">&lt;</span><span class="n">X</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">Z</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Z</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">X</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">Z</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
</code></pre></div>
<p>Concatenates 3 values of arbitrary bitwidths to a single value.</p>
<h4 id="dslx_std-stdrrot"><code>std::rrot</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rrot</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Rotate <code>x</code> right by <code>y</code> bits.</p>
<h4 id="dslx_std-stdpopcount"><code>std::popcount</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">popcount</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Counts the number of bits in <code>x</code> that are '1'.</p>
<h4 id="dslx_std-stdextract_bits"><code>std::extract_bits</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">extract_bits</span><span class="o">&lt;</span><span class="n">from_inclusive</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">to_exclusive</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">fixed_shift</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">                    </span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">std</span><span class="p">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">to_exclusive</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">from_inclusive</span><span class="p">)]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x_extended</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">max</span><span class="p">(</span><span class="n">unsigned_sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fixed_shift</span><span class="p">,</span><span class="w"> </span><span class="n">to_exclusive</span><span class="p">)];</span>
<span class="w">    </span><span class="p">(</span><span class="n">x_extended</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fixed_shift</span><span class="p">)[</span><span class="n">from_inclusive</span><span class="p">:</span><span class="nc">to_exclusive</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>
<p>Extracts a bit-slice from x shifted left by fixed_shift.  This function behaves as-if x as
resonably infinite precision so that the shift does not drop any bits and that the bit slice
will be in-range.</p>
<p>If <code>to_exclusive &lt;= from_excsuive</code>, the result will be a zero-bit <code>bits[0]</code>.</p>
<h4 id="dslx_std-stdvslice"><code>std::vslice</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">vslice</span><span class="o">&lt;</span><span class="n">MSB</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">LSB</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">IN</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">OUT</span><span class="p">]</span>
</code></pre></div>
<p>Similar to <code>extract_bits</code> above, but corresponds directly to the "part-select"
Verilog syntax. That is:</p>
<div class="highlight"><pre><span></span><code><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span>
</code></pre></div>
<p>Corresponds to:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">u4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vslice</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>
<p>This is useful when porting code literally as a way to avoid transcription
errors. For new code the
<a href="https://google.github.io/xls/dslx_reference/#bit-slice-expressions">DSLX first-class slicing syntax</a>
(either range-slicing or width-slicing) is preferred.</p>
<h3 id="dslx_std-mathematical-functions">Mathematical Functions</h3>
<h4 id="dslx_std-stdbounded_minus_1"><code>std::bounded_minus_1</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">bounded_minus_1</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns the value of <code>x - 1</code> with saturation at <code>0</code>.</p>
<h4 id="dslx_std-stdabs"><code>std::abs</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">abs</span><span class="o">&lt;</span><span class="n">BITS</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">BITS</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">BITS</span><span class="p">]</span>
</code></pre></div>
<p>Returns the absolute value of <code>x</code> as a signed number.</p>
<h4 id="dslx_std-stdis_pow2"><code>std::is_pow2</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_pow2</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns true when x is a non-zero power-of-two.</p>
<h4 id="dslx_std-stdadd"><code>std::?add</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">uadd</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">umax</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sadd</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">umax</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
</code></pre></div>
<p>Returns sum of <code>x</code> (<code>N</code> bits) and <code>y</code> (<code>M</code> bits) as a <code>umax(N,M)+1</code> bit value.</p>
<h4 id="dslx_std-stdmul"><code>std::?mul</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">umul</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">smul</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
</code></pre></div>
<p>Returns product of <code>x</code> (<code>N</code> bits) and <code>y</code> (<code>M</code> bits) as an <code>N+M</code> bit value.</p>
<h4 id="dslx_std-stditerative_div"><code>std::iterative_div</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">iterative_div</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">DN</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Calculate <code>x / y</code> one bit at a time. This is an alternative to using the
division operator '/' which may not synthesize nicely.</p>
<h4 id="dslx_std-stddiv_pow2"><code>std::div_pow2</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">div_pow2</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns <code>x / y</code> where <code>y</code> must be a non-zero power-of-two.</p>
<h4 id="dslx_std-stdmod_pow2"><code>std::mod_pow2</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">mod_pow2</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns <code>x % y</code> where <code>y</code> must be a non-zero power-of-two.</p>
<h4 id="dslx_std-stdceil_div"><code>std::ceil_div</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">ceil_div</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns the ceiling of (x divided by y).</p>
<h4 id="dslx_std-stdround_up_to_nearest"><code>std::round_up_to_nearest</code></h4>
<div class="highlight"><pre><span></span><code>pub fn round_up_to_nearest(x: u32, y: u32) -&gt; u32
</code></pre></div>
<p>Returns <code>x</code> rounded up to the nearest multiple of <code>y</code>.</p>
<h4 id="dslx_std-stdround_up_to_nearest_pow2_">std::round_up_to_nearest_pow2_?</h4>
<p>Returns <code>x</code> rounded up to the nearest multiple of <code>y</code>, where <code>y</code> is a known
positive power of 2. This functionality is the same as <code>std::round_up_to_nearest</code>
but optimized when <code>y</code> is a power of 2.</p>
<h4 id="dslx_std-stdpow"><code>std::?pow</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">upow</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">spow</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Performs integer exponentiation as in Hacker's Delight, Section 11-3. Only
non-negative exponents are allowed, hence the uN parameter for spow.</p>
<h4 id="dslx_std-stdclog2"><code>std::clog2</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">clog2</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns <code>ceiling(log2(x))</code>, with one exception: When <code>x = 0</code>, this function
differs from the true mathematical function: <code>clog2(0) = 0</code> where as
<code>ceil(log2(0)) = -infinity</code></p>
<p>This function is frequently used to calculate the number of bits required to
represent <code>x</code> possibilities. With this interpretation, it is sensible to define
<code>clog2(0) = 0</code>.</p>
<p>Example: <code>clog2(7) = 3</code>.</p>
<h4 id="dslx_std-stdflog2"><code>std:flog2</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">flog2</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns <code>floor(log2(x))</code>, with one exception:</p>
<p>When x=0, this function differs from the true mathematical function: <code>flog2(0) =
0</code> where as <code>floor(log2(0)) = -infinity</code></p>
<p>This function is frequently used to calculate the number of bits required to
represent an unsigned integer <code>n</code> to define <code>flog2(0) = 0</code>, so that <code>flog(n)+1</code>
represents the number of bits needed to represent the <code>n</code>.</p>
<p>Example: <code>flog2(7) = 2</code>, <code>flog2(8) = 3</code>.</p>
<h4 id="dslx_std-stdmax"><code>std::?max</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">smax</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">umax</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns the maximum of two integers.</p>
<h4 id="dslx_std-stdmin"><code>std::?min</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">smin</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">umin</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
</code></pre></div>
<p>Returns the minimum of two unsigned integers.</p>
<h4 id="dslx_std-stduadd_with_overflow"><code>std::uadd_with_overflow</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">uadd_with_overflow</span><span class="o">&lt;</span><span class="n">V</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">V</span><span class="p">])</span>
</code></pre></div>
<p>Returns a 2-tuple indicating overflow (boolean) and a sum <code>(x + y) as uN[V]</code>.
An overflow occurs if the result does not fit within a <code>uN[V]</code>.</p>
<h4 id="dslx_std-stdumul_with_overflow"><code>std::umul_with_overflow</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">umul_with_overflow</span><span class="o">&lt;</span><span class="n">V</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">V</span><span class="p">])</span>
</code></pre></div>
<p>Returns a 2-tuple indicating overflow (boolean) and a product <code>(x * y) as uN[V]</code>.
An overflow occurs if the result does not fit within a <code>uN[V]</code>.</p>
<h3 id="dslx_std-misc-functions">Misc Functions</h3>
<h4 id="dslx_std-signed-comparison-stdsge-sgt-sle-slt"><code>Signed comparison - std::{sge, sgt, sle, slt}</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sge</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
<span class="nc">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sgt</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
<span class="nc">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sle</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
<span class="nc">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">slt</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p><strong>Explicit signed comparison</strong> helpers for working with unsigned values, can be
a bit more convenient and a bit more explicit intent than doing casting of left
hand side and right hand side.</p>
<h4 id="dslx_std-stdfind_index"><code>std::find_index</code></h4>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">find_index</span><span class="o">&lt;</span><span class="n">BITS</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">ELEMS</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">array</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">BITS</span><span class="p">][</span><span class="n">ELEMS</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">BITS</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span>
</code></pre></div>
<p>Returns (<code>found</code>, <code>index</code>) given an array and the element to find within the
array.</p>
<p>Note that when <code>found</code> is false, the <code>index</code> is <code>0</code> -- <code>0</code> is provided instead
of a value like <code>-1</code> to prevent out-of-bounds accesses from occurring if the
index is used in a match expression (which will eagerly evaluate all of its
arms), to prevent it from creating an error at simulation time if the value is
ultimately discarded from the unselected match arm.</p>
<h2 id="dslx_std-import-acm_random"><code>import acm_random</code></h2>
<p>Port of
<a href="https://github.com/google/or-tools/blob/66b8d230798f9b8a3c98c26a997daf04974400b8/ortools/base/random.cc#L35">ACM random</a>
number generator to DSLX.</p>
<p>DO NOT use <code>acm_random.x</code> for any application where security -- unpredictability
of subsequent output and previous output -- is needed. ACMRandom is in <em>NO</em>
<em>WAY</em> a cryptographically secure pseudorandom number generator, and using it
where recipients of its output may wish to guess earlier/later output values
would be very bad.</p>
<h3 id="dslx_std-acm_randomrng_deterministic_seed"><code>acm_random::rng_deterministic_seed</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rng_deterministic_seed</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span>
</code></pre></div>
<p>Returns a fixed seed for use in the random number generator.</p>
<h3 id="dslx_std-acm_randomrng_new"><code>acm_random::rng_new</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rng_new</span><span class="p">(</span><span class="n">seed</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span>
</code></pre></div>
<p>Create the state for a new random number generator using the given seed.</p>
<h3 id="dslx_std-acm_randomrng_next"><code>acm_random::rng_next</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rng_next</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span>
</code></pre></div>
<p>Returns a pseudo-random number in the range <code>[1, 2^31-2]</code>.</p>
<p>Note that this is one number short on both ends of the full range of
non-negative 32-bit integers, which range from <code>0</code> to <code>2^31-1</code>.</p>
<h3 id="dslx_std-acm_randomrng_next64"><code>acm_random::rng_next64</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rng_next</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span>
</code></pre></div>
<p>Returns a pseudo random number in the range <code>[1, (2^31-2)^2]</code>.</p>
<p>Note that this does not cover all non-negative values of int64, which range from
<code>0</code> to <code>2^63-1</code>. <strong>The top two bits are ALWAYS ZERO</strong>.</p></section><section class="print-page" id="floating_point"><h1 id="floating_point-floating-point-routines">Floating-point routines</h1>
<p>XLS provides implementations of several floating-point operations and may add
more at any time. Here are listed notable details of our implementations or of
floating-point operations in general. Unless otherwise specified, not possible
or out-of-scope, all operations and types should be IEEE-754 compliant.</p>
<p>For example, floating-point exceptions have not been implemented; they're
outside our current scope. The numeric results of multiplication, on the other
hand, should <em>exactly</em> match those of any other compliant implementation.</p>
<h2 id="floating_point-apfloat">APFloat</h2>
<p>Floating-point operations are, in general, defined by the same sequence of steps
regardless of their underlying bit widths: fractional parts must be expanded
then aligned, then an operation (add, multiply, etc.) must be performed,
interpreting the fractions as integral types, followed by rounding, special case
handling, and reconstructing an output FP type.</p>
<p>This observation leads to the possibility of <em>generic</em> floating-point routines:
a fully parameterized add, for example, which can be instantiated with and 8-bit
exponent and 23-bit fractional part for binary32 types, and an 11-bit exponent
and 52-bit fractional part for binary64 types. Even more interesting, a
hypothetical bfloat32 type could <em>immediately</em> be supported by, say,
instantiating that adder with, say, 15 exponent bits and 16 fractional ones.</p>
<p>As much as possible, XLS implements FP operations in terms of its
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/apfloat.x"><code>APFloat</code></a>
(arbitrary-precision floating-point) type. <code>APFloat</code> is a parameterized
floating-point structure with a fixed one-bit sign and specifiable exponent and
fractional part size. For ease of use, common types, such as
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/float32.x"><code>float32</code></a>, are
defined in terms of those <code>APFloat</code> types.</p>
<p>For example, the generic "is X infinite" operation is defined in <code>apfloat.x</code> as:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Returns whether or not the given APFloat represents an infinite quantity.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_inf</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">bexp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">mask_bits</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">fraction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">bits</span><span class="p">[</span><span class="n">FRACTION_SZ</span><span class="p">]:</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Whereas in <code>float32.x</code>, <code>F32</code> is defined as:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">F32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloat</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">23</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>and <code>is_inf</code> is exposed as:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_inf</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">F32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">is_inf</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">23</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>In this way, users can refer to <code>F32</code> types and can use them as and with
<code>float32::is_inf(f)</code>, giving them simplified access to a generic operation.</p>
<h2 id="floating_point-supported-operations">Supported operations</h2>
<p>Here are listed the routines so far implemented in XLS. Unless otherwise
specified, operations are implemented in terms of <code>APFloat</code>s such that they can
support any precisions (aside from corner cases, such as a zero-byte fractional
part).</p>
<h3 id="floating_point-apfloattag"><code>apfloat::tag</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">tag</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input_float</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloatTag</span>
</code></pre></div>
<p>Returns the type of float as one of <code>APFloatTag::ZERO</code>, <code>APFloatTag::SUBNORMAL</code>,
<code>APFloatTag::INFINITY</code>, <code>APFloatTag::NAN</code> and <code>APFloatTag::NORMAL</code>.</p>
<h3 id="floating_point-apfloatqnan"><code>apfloat::qnan</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">qnan</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns a <a href="https://en.wikipedia.org/wiki/NaN#Quiet_NaN"><code>quiet NaN</code></a>.</p>
<h3 id="floating_point-apfloatis_nan"><code>apfloat::is_nan</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_nan</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns whether or not the given <code>APFloat</code> represents <code>NaN</code>.</p>
<h3 id="floating_point-apfloatinf"><code>apfloat::inf</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">inf</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns a positive or a negative infinity depending upon the given sign
parameter.</p>
<h3 id="floating_point-apfloatis_inf"><code>apfloat::is_inf</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_inf</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns whether or not the given <code>APFloat</code> represents an infinite quantity.</p>
<h3 id="floating_point-apfloatis_pos_inf"><code>apfloat::is_pos_inf</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_pos_inf</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns whether or not the given <code>APFloat</code> represents a positive infinite quantity.</p>
<h3 id="floating_point-apfloatis_neg_inf"><code>apfloat::is_neg_inf</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_neg_inf</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns whether or not the given <code>APFloat</code> represents a negative infinite quantity.</p>
<h3 id="floating_point-apfloatzero"><code>apfloat::zero</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">zero</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns a positive or negative zero depending upon the given sign parameter.</p>
<h3 id="floating_point-apfloatone"><code>apfloat::one</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">one</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns one or minus one depending upon the given sign parameter.</p>
<h3 id="floating_point-apfloatnegate"><code>apfloat::negate</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">negate</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns the negative of <code>x</code> unless it is a <code>NaN</code>, in which case it will change it
from a quiet to signaling <code>NaN</code> or from signaling to a quiet <code>NaN</code>.</p>
<h3 id="floating_point-apfloatmax_normal_exp"><code>apfloat::max_normal_exp</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">max_normal_exp</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">]</span>
</code></pre></div>
<p>Maximum value of the exponent for normal numbers with EXP_SZ bits in the
exponent field. For single precision floats this value is 127.</p>
<h3 id="floating_point-apfloatmin_normal_exp"><code>apfloat::min_normal_exp</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">min_normal_exp</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">]</span>
</code></pre></div>
<p>Minimum value of the exponent for normal numbers with EXP_SZ bits in the
exponent field. For single precision floats this value is -126.</p>
<h3 id="floating_point-apfloatunbiased_exponent"><code>apfloat::unbiased_exponent</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">unbiased_exponent</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">]</span>
</code></pre></div>
<p>Returns the unbiased exponent. For normal numbers it is <code>bexp - 2^EXP_SZ +
1``and for subnormals it is,</code>2 - 2^EXP_SZ<code>. For infinity and `NaN</code>, there are
no guarantees, as the unbiased exponent has no meaning in that case.</p>
<p>For example, for single precision normal numbers the unbiased exponent is
<code>bexp - 127``and for subnormal numbers it is</code>-126`.</p>
<h3 id="floating_point-apfloatbias"><code>apfloat::bias</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">bias</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">unbiased_exponent</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">]</span>
</code></pre></div>
<p>Returns the biased exponent which is equal to <code>unbiased_exponent + 2^EXP_SZ - 1</code></p>
<p>Since the function only takes as input the unbiased exponent, it cannot
distinguish between normal and subnormal numbers, as a result it assumes that
the input is the exponent for a normal number.</p>
<h3 id="floating_point-apfloatflatten"><code>apfloat::flatten</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">flatten</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span>
<span class="w">               </span><span class="n">TOTAL_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="n">EXP_SZ</span><span class="o">+</span><span class="n">FRACTION_SZ</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">               </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">TOTAL_SZ</span><span class="p">]</span>
</code></pre></div>
<p>Returns a bit string of size <code>1 + EXP_SZ + FRACTION_SZ</code> where the first bit is
the sign bit, the next <code>EXP_SZ</code> bit encode the biased exponent and the last
<code>FRACTION_SZ</code> are the significand without the hidden bit.</p>
<h3 id="floating_point-apfloatunflatten"><code>apfloat::unflatten</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">unflatten</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span>
<span class="w">                 </span><span class="n">TOTAL_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="n">EXP_SZ</span><span class="o">+</span><span class="n">FRACTION_SZ</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">TOTAL_SZ</span><span class="p">])</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns a <code>APFloat</code> struct whose flattened version would be the input string
<code>x</code>.</p>
<h3 id="floating_point-apfloatldexp"><code>apfloat:ldexp</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">ldexp</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">             </span><span class="n">fraction</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">             </span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="nc">s32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p><code>ldexp</code> (load exponent) computes <code>fraction * 2^exp</code>. Note that:</p>
<ul>
<li>Input denormals are treated as/flushed to 0. (denormals-are-zero / DAZ).
   Similarly, denormal results are flushed to 0.</li>
<li>No exception flags are raised/reported.</li>
<li>We emit a single, canonical representation for NaN (qnan) but accept all
   <code>NaN</code> representations as input.</li>
</ul>
<h3 id="floating_point-apfloatcast_from_fixed_using_rne"><code>apfloat::cast_from_fixed_using_rne</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">cast_from_fixed_using_rne</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_SRC_BITS</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                                 </span><span class="n">to_cast</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">NUM_SRC_BITS</span><span class="p">])</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>Casts the fixed point number to a floating point number using RNE (Round to
Nearest Even) as the <a href="https://en.wikipedia.org/wiki/Rounding">rounding mode</a>.</p>
<h3 id="floating_point-apfloatcast_from_fixed_using_rz"><code>apfloat::cast_from_fixed_using_rz</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">cast_from_fixed_using_rz</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_SRC_BITS</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                                 </span><span class="n">to_cast</span><span class="p">:</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">NUM_SRC_BITS</span><span class="p">])</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>Casts the fixed point number to a floating point number using RZ (Round to Zero)
as the <a href="https://en.wikipedia.org/wiki/Rounding">rounding mode</a>.</p>
<h3 id="floating_point-apfloatupcast"><code>apfloat::upcast</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">upcast</span><span class="o">&lt;</span><span class="n">TO_EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">TO_FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FROM_EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FROM_FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">FROM_EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FROM_FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">TO_EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">TO_FRACTION_SZ</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>Upcast the given apfloat to another (larger) apfloat representation. Note:
denormal inputs get flushed to zero.</p>
<h3 id="floating_point-apfloatnormalize"><code>apfloat::normalize</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">normalize</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span>
<span class="w">                 </span><span class="n">WIDE_FRACTION</span><span class="p">:</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">FRACTION_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                 </span><span class="n">sign</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">EXP_SZ</span><span class="p">],</span>
<span class="w">                 </span><span class="n">fraction_with_hidden</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">WIDE_FRACTION</span><span class="p">])</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns a normalized APFloat with the given components. <code>fraction_with_hidden</code>
is the fraction (including the hidden bit). This function only normalizes in the
direction of decreasing the exponent. Input must be a normal number or zero.
Subnormals/Denormals are flushed to zero in the result.</p>
<h3 id="floating_point-apfloatis_zero_or_subnormal"><code>apfloat::is_zero_or_subnormal</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_zero_or_subnormal</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                            </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns <code>true</code> if <code>x == 0</code> or <code>x</code> is a subnormal number.</p>
<h3 id="floating_point-apfloatcast_to_fixed"><code>apfloat::cast_to_fixed</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">cast_to_fixed</span><span class="o">&lt;</span><span class="n">NUM_DST_BITS</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                     </span><span class="n">to_cast</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">NUM_DST_BITS</span><span class="p">]</span>
</code></pre></div>
<p>Casts the floating point number to a fixed point number. Unrepresentable numbers
are cast to the minimum representable number (largest magnitude negative
number).</p>
<h3 id="floating_point-apfloateq_2"><code>apfloat::eq_2</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">eq_2</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">            </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">            </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns <code>true</code> if <code>x == y</code>. Denormals are Zero (DAZ). Always returns <code>false</code> if
<code>x</code> or <code>y</code> is <code>NaN</code>.</p>
<h3 id="floating_point-apfloatgt_2"><code>apfloat::gt_2</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">gt_2</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">            </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">            </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns <code>true</code> if <code>x &gt; y</code>. Denormals are Zero (DAZ). Always returns <code>false</code> if
<code>x</code> or <code>y</code> is <code>NaN</code>.</p>
<h3 id="floating_point-apfloatgte_2"><code>apfloat::gte_2</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">gte_2</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">             </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">             </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns <code>true</code> if <code>x &gt;= y</code>. Denormals are Zero (DAZ). Always returns <code>false</code> if
<code>x</code> or <code>y</code> is <code>NaN</code>.</p>
<h3 id="floating_point-apfloatlte_2"><code>apfloat::lte_2</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">lte_2</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">             </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">             </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns <code>true</code> if <code>x &lt;= y</code>. Denormals are Zero (DAZ). Always returns <code>false</code> if
<code>x</code> or <code>y</code> is <code>NaN</code>.</p>
<h3 id="floating_point-apfloatlt_2"><code>apfloat::lt_2</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">lt_2</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">            </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">            </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>Returns <code>true</code> if <code>x &lt; y</code>. Denormals are Zero (DAZ). Always returns <code>false</code> if
<code>x</code> or <code>y</code> is <code>NaN</code>.</p>
<h3 id="floating_point-apfloatround_towards_zero"><code>apfloat::round_towards_zero</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">round_towards_zero</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">                          </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns an <code>APFloat</code> with all its bits past the decimal point set to <code>0</code>.</p>
<h3 id="floating_point-apfloatto_int"><code>apfloat::to_int</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_int</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">RESULT_SZ</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">              </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">sN</span><span class="p">[</span><span class="n">RESULT_SZ</span><span class="p">]</span>
</code></pre></div>
<p>Returns the signed integer part of the input float, truncating any fractional
bits if necessary.</p>
<h3 id="floating_point-apfloataddsub"><code>apfloat::add/sub</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">add</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sub</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns the sum/difference of <code>x</code> and <code>y</code> based on a generalization of IEEE 754
single-precision floating-point addition, with the following exceptions:</p>
<ul>
<li>Both input and output denormals are treated as/flushed to 0.</li>
<li>Only round-to-nearest mode is supported.</li>
<li>No exception flags are raised/reported.</li>
</ul>
<p>In all other cases, results should be identical to other conforming
implementations (modulo exact fraction values in the <code>NaN</code> case.</p>
<h4 id="floating_point-implementation-details">Implementation details</h4>
<p>Floating-point addition, like any FP operation, is much more complicated than
integer addition, and has many more steps. Being the first operation described,
we'll take extra care to explain floating-point addition:</p>
<!-- mdformat off(nested lists are rendered differently in mkdocs) -->

<ol>
<li><strong>Expand fractions:</strong> Floating-point operations are computed with bits
   beyond that in their normal representations for increased precision. For
   IEEE 754 numbers, there are three extra, called the guard, rounding and
   sticky bits. The first two behave normally, but the last, the "sticky" bit,
   is special. During shift operations (below), if a "1" value is ever shifted
   into the sticky bit, it "sticks" - the bit will remain "1" through any
   further shift operations. In this step, the fractions are expanded by these
   three bits.</li>
<li>
<p><strong>Align fractions:</strong> To ensure that fractions are added with appropriate
   magnitudes, they must be aligned according to their exponents. To do so, the
   smaller significant needs to be shifted to the right (each right shift is
   equivalent to increasing the exponent by one).</p>
<ul>
<li>The extra precision bits are populated in this shift.</li>
<li>As part of this step, the leading 1 bit... and a sign bit Note: The
   sticky bit is calculated and applied in this step.</li>
</ul>
</li>
<li>
<p><strong>Sign-adjustment:</strong> if the fractions differ in sign, then the fraction with
   the smaller initial exponent needs to be (two's complement) negated.</p>
</li>
<li>
<p><strong>Add the fractions and capture the carry bit.</strong> Note that, if the signs of
   the fractions differs, then this could result in higher bits being cleared.</p>
</li>
<li>
<p><strong>Normalize the fractions:</strong> Shift the result so that the leading '1' is
   present in the proper space. This means shifting right one place if the
   result set the carry bit, and to the left some number of places if high bits
   were cleared.</p>
<ul>
<li>The sticky bit must be preserved in any of these shifts!</li>
</ul>
</li>
<li>
<p><strong>Rounding:</strong> Here, the extra precision bits are examined to determine if
   the result fraction's last bit should be rounded up. IEEE 754 supports five
   rounding modes:</p>
<ul>
<li>Round towards 0: just chop off the extra precision bits.</li>
<li>Round towards +infinity: round up if any extra precision bits are set.</li>
<li>Round towards -infinity: round down if any extra precision bits are set.</li>
<li>Round to nearest, ties away from zero: Rounds to the nearest value. In
   cases where the extra precision bits are halfway between values, i.e.,
   0b100, then the result is rounded up for positive numbers and down for
   negative ones.</li>
<li>
<p>Round to nearest, ties to even: Rounds to the nearest value. In cases
   where the extra precision bits are halfway between values, then the
   result is rounded in whichever direction causes the LSB of the result
   significant to be 0.</p>
<ul>
<li>This is the most commonly-used rounding mode.</li>
<li>This is [currently] the only supported mode by the DSLX implementation.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Special case handling:</strong> The results are examined for special cases such
   as NaNs, infinities, or (optionally) subnormals.</p>
</li>
</ol>
<!-- mdformat on -->

<h5 id="floating_point-result-sign-determination">Result sign determination</h5>
<p>The sign of the result will normally be the same as the sign of the operand with
the greater exponent, but there are two extra cases to consider. If the operands
have the same exponent, then the sign will be that of the greater fraction, and
if the result is 0, then we favor positive 0 vs. negative 0 (types are as for a
C <code>float</code> implementation):</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">addend_x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s29</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">addend_y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">s29</span><span class="p">);</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">fraction_is_zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s29</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result_sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">fraction_is_zero</span><span class="p">,</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s29</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">!</span><span class="n">greater_exp</span><span class="p">.</span><span class="n">sign</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">greater_exp</span><span class="p">.</span><span class="n">sign</span><span class="p">,</span>
<span class="w">  </span><span class="p">};</span>
</code></pre></div>
<h5 id="floating_point-rounding">Rounding</h5>
<p>As complicated as rounding is to describe, its implementation is relatively
straightforward (types are as for a C <code>float</code> implementation):</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">normal_chunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shifted_fraction</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">half_way_chunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shifted_fraction</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">];</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">do_round_up</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">normal_chunk</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">u3</span><span class="p">:</span><span class="mh">0x4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">half_way_chunk</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="mh">0x3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">u1</span><span class="p">:</span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// We again need an extra bit for carry.</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">rounded_fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">do_round_up</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">shifted_fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u28</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u28</span><span class="p">:</span><span class="mh">0x8</span><span class="w"> </span><span class="p">}</span>
<span class="w">                         </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">shifted_fraction</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">u28</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">rounding_carry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rounded_fraction</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:];</span>
</code></pre></div>
<h3 id="floating_point-apfloatmul"><code>apfloat::mul</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">mul</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span>
</code></pre></div>
<p>Returns the product of <code>x</code> and <code>y</code>, with the following exceptions:</p>
<ul>
<li>Both input and output denormals are treated as/flushed to 0.</li>
<li>Only round-to-nearest mode is supported.</li>
<li>No exception flags are raised/reported.</li>
</ul>
<p>In all other cases, results should be identical to other conforming
implementations (modulo exact fraction values in the NaN case).</p>
<h3 id="floating_point-apfloatfma"><code>apfloat::fma</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fma</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">APFloat</span><span class="o">&lt;</span><span class="n">EXP_SZ</span><span class="p">,</span><span class="w"> </span><span class="n">FRACTION_SZ</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>Returns the Fused Multiply and Add (FMA) result of computing <code>a*b + c</code>.</p>
<p>The FMA operation is a three-operand operation that computes the product of the
first two and the sum of that with the third. The IEEE 754-2008 description of
the operation states that the operation should be performed "as if with
unbounded range and precision", limited only by rounding of the final result. In
other words, this differs from a sequence of a separate multiply followed by an
add in that there is only a single rounding step (instead of the two involved in
separate operations).</p>
<p>In practice, this means A) that the precision of an FMA is higher than
individual ops, and thus that B) an FMA requires significantly more internal
precision bits than naively expected.</p>
<p>For binary32 inputs, to achieve the standard-specified precision, the initial
mul requires the usual 48 ((23 fraction + 1 "hidden") * 2) fraction bits. When
performing the subsequent add step, though, it is necessary to maintain <em>72</em>
fraction bits ((23 fraction + 1 "hidden") * 3). Fortunately, this sum includes
the guard, round, and sticky bits (so we don't need 75). The mathematical
derivation of the exact amount will not be given here (as I've not done it), but
the same calculated size would apply for other data types (i.e., 54 * 2 = 108
and 54 * 3 = 162 for binary64).</p>
<p>Aside from determining the necessary precision bits, the FMA implementation is
rather straightforward, especially after reviewing the adder and multiplier.</p>
<h2 id="floating_point-float64">float64</h2>
<p>To help with the <code>float64</code> or
<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double precision</a>
floating point numbers, <code>float32.x</code> defines the following type aliases.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">F64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloat</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">52</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">FloatTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloatTag</span><span class="p">;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">TaggedF64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">FloatTag</span><span class="p">,</span><span class="w"> </span><span class="n">F64</span><span class="p">);</span>
</code></pre></div>
<p>Besides <code>float64</code> specializations of the functions in <code>apfloat.x</code>, the following
functions are defined just for <code>float64</code>.</p>
<h3 id="floating_point-float64to_int64"><code>float64::to_int64</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_int64</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">F64</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s64</span><span class="p">;</span>
</code></pre></div>
<p>Convert the <code>F64</code> struct into a 64 bit integer.</p>
<h2 id="floating_point-float32">float32</h2>
<p>To help with the <code>float32</code> or
<a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">single precision</a>
floating point numbers, <code>float32.x</code> defines the following type aliases.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">F32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloat</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">FloatTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloatTag</span><span class="p">;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">TaggedF32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">FloatTag</span><span class="p">,</span><span class="w"> </span><span class="n">F32</span><span class="p">);</span>
<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">F32_ONE_FLAT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mh">0x3f800000</span><span class="p">;</span>
</code></pre></div>
<p>Besides <code>float32</code> specializations of the functions in <code>apfloat.x</code>, the following
functions are defined just for <code>float32</code>.</p>
<h3 id="floating_point-float32to_int32-float32from_int32"><code>float32::to_int32</code>, <code>float32::from_int32</code></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_int32</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">F32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s32</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">from_int32</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">s32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">F32</span>
</code></pre></div>
Convert the <code>F32</code> struct to and from a 32bit integer.</p>
<h1 id="floating_point-float32fixed_fraction"><code>float32::fixed_fraction</code></h1>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fixed_fraction</span><span class="p">(</span><span class="n">input_float</span><span class="p">:</span><span class="w"> </span><span class="nc">F32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u23</span>
</code></pre></div>
<p>TBD</p>
<h1 id="floating_point-float32fast_rsqrt_config_refinementsfloat32fast_rsqrt"><code>float32::fast_rsqrt_config_refinements</code>/<code>float32::fast_rsqrt</code></h1>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fast_rsqrt_config_refinements</span><span class="o">&lt;</span><span class="n">NUM_REFINEMENTS</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">F32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">F32</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fast_rsqrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">F32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">F32</span>
</code></pre></div>
<p>Floating point (fast (approximate) inverse square root)[
https://en.wikipedia.org/wiki/Fast_inverse_square_root]. This should be able to
compute <code>1.0 / sqrt(x)</code> using fewer hardware resources than using a <code>sqrt</code> and
division module, although this hasn't been benchmarked yet. Latency is expected
to be lower as well. The tradeoff is that this offers slighlty less precision
(error is &lt; 0.2% in worst case). Note that:</p>
<ul>
<li>Input denormals are treated as/flushed to 0. (denormals-are-zero / DAZ).</li>
<li>Only round-to-nearest mode is supported.</li>
<li>No exception flags are raised/reported.</li>
<li>We emit a single, canonical representation for NaN (qnan) but accept
   all NaN respresentations as input.</li>
</ul>
<p><code>fast_rsqrt_config_refinements</code> allows the user to specify the number of
Computes an approximation of 1.0 / sqrt(x). <code>NUM_REFINEMENTS</code> can be increased
to tradeoff more hardware resources for more accuracy.</p>
<p><code>fast_rsqrt</code> does exactly one refinement.</p>
<h2 id="floating_point-bfloat16">bfloat16</h2>
<p>To help with the
<a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format"><code>bfloat16</code></a>
floating point numbers, <code>bfloat16.x</code> defines the following type aliases.</p>
<p><div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">BF16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloat</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">FloatTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apfloat</span><span class="p">::</span><span class="n">APFloatTag</span><span class="p">;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">TaggedBF16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">FloatTag</span><span class="p">,</span><span class="w"> </span><span class="n">BF16</span><span class="p">);</span>
</code></pre></div>
Besides <code>bfloat16</code> specializations of the functions in <code>apfloat.x</code>, the following
functions are defined just for <code>bfloat16</code>.</p>
<h3 id="floating_point-bfloat16to_int16"><code>bfloat16:to_int16</code></h3>
<p><div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_int16</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">BF16</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">s16</span>
</code></pre></div>
Convert the the <code>BF16</code> struct into a 16 bit integer.</p>
<h3 id="floating_point-bfloat16increment_fraction"><code>bfloat16:increment_fraction</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">increment_fraction</span><span class="p">(</span><span class="n">input</span><span class="p">:</span><span class="w"> </span><span class="nc">BF16</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">BF16</span>
</code></pre></div>
<p>Increments the fraction of the input BF16 by one and returns the normalized
result. Input must be a normal <em>non-zero</em> number.</p>
<h2 id="floating_point-testing">Testing</h2>
<p>Several different methods are used to test these routines, depending on
applicability. These are:</p>
<ul>
<li>Reference comparison: exhaustive testing</li>
<li>Reference comparison: space-sampling</li>
<li>Formal proving</li>
</ul>
<p>When comparing to a reference, a natural question is the stability of the
reference, i.e., is the reference answer the same across all versions or
environments? Will the answer given by glibc/libm on AArch64 be the same as one
given by a hardware FMA unit on a GPU? Fortunately, all "correct"
implementations will give the same results for the same inputs. <sup id="floating_point-fnref:1"><a class="footnote-ref" href="#floating_point-fn:1">1</a></sup> In
addition, POSIX has the same result-precision language. It's worth noting that
-ffast-math doesn't currently affect FMA emission/fusion/fission/etc.</p>
<p>differ between implementations due to the
<a href="https://en.wikipedia.org/wiki/Rounding"><em>table maker's dilemma</em></a>.</p>
<h3 id="floating_point-exhaustive-testing">Exhaustive testing</h3>
<p>This is the happiest case - where the input space is so small that we can
iterate over every possible input, effectively treating the input as a binary
iteration counter. Sadly, this is uncommon (except, perhaps for ML math), as
binary32 is the precision floor for most problems, and a 64-bit input space is
well beyond our current abilities. Still - if your problem <em>can</em> be exhaustively
tested (with respect to a trusted reference), it <em>should</em> be exhaustively
tested!</p>
<p>None of our current ops are tested in this way, although the bf16 cases
could/should be.</p>
<h3 id="floating_point-space-sampling">Space-sampling</h3>
<p>When the problem input space is too large for exhaustive testing, then random
samples can be tested instead. This approach can't give complete verification of
an implementation, but, given enough samples, it can yield a high degree of
confidence.</p>
<p>The existing modules are tested in this way. This could be improved by
preventing re-testing of any given sample (at the cost of memory and, perhaps,
atomic/locking costs) and by identifying interesting "corner cases" of the input
space and focusing on those.</p>
<h3 id="floating_point-formal-verification">Formal verification</h3>
<p>This sort of testing utilizes our formal solver infrastructure to prove
correctness with the solver's internal FP implementation. This is fully
described in the
<a href="#solvers">solvers documentation</a>.</p>
<div class="footnote">
<hr />
<ol>
<li id="floating_point-fn:1">
<p>There are operations for which this is not true. Transcendental ops may&#160;<a class="footnote-backref" href="#floating_point-fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><section class="print-page" id="fuzzer"><h1 id="fuzzer-xls-fuzzer">XLS Fuzzer</h1>
<div class="toc">
<ul>
<li><a href="#fuzzer-xls-fuzzer">XLS Fuzzer</a><ul>
<li><a href="#fuzzer-crashers-directory">Crashers Directory</a><ul>
<li><a href="#fuzzer-reproducers">Single-file reproducers</a></li>
</ul>
</li>
<li><a href="#fuzzer-minimization">IR minimization</a></li>
<li><a href="#fuzzer-summaries">Summaries</a></li>
<li><a href="#fuzzer-debugging">Debugging a failing sample</a><ul>
<li><a href="#fuzzer-debugging-a-tool-crash">Debugging a tool crash</a></li>
<li><a href="#fuzzer-result-miscomparison-unoptimized-ir">Result miscomparison: unoptimized IR</a></li>
<li><a href="#fuzzer-result-miscomparison-optimized-ir">Result miscomparison: optimized IR</a><ul>
<li><a href="#fuzzer-debugging-the-llvm-jit">Debugging the LLVM JIT</a><ul>
<li><a href="#fuzzer-building-llvm-tools">Building LLVM tools</a></li>
<li><a href="#fuzzer-running-the-llvm-optimization-passes">Running the LLVM optimization passes</a></li>
<li><a href="#fuzzer-running-the-instcombine-pass">Running the Instcombine pass</a></li>
<li><a href="#fuzzer-evaluating-llvm-ir">Evaluating LLVM IR</a></li>
<li><a href="#fuzzer-running-llvm-code-generation">Running LLVM code generation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fuzzer-result-miscomparison-simulated-verilog">Result miscomparison: simulated Verilog</a></li>
<li><a href="#fuzzer-filing-an-llvm-bug">Filing an LLVM bug</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>To execute the XLS fuzz driver simply run a command line like the following:</p>
<div class="highlight"><pre><span></span><code>bazel run -c opt \
  //xls/fuzzer:run_fuzz_multiprocess \
  -- --crash_path=/tmp/crashers-$(date +&#39;%Y-%m-%d&#39;) --seed=0 --duration=8h
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code>--seed=0</code> flag makes the fuzzer run from a deterministic seed, so the
same sequence of examples will be tested each time command line invocation. To
run non-deterministically, do not provide the <code>--seed</code> flag.</p>
</div>
<p>The XLS fuzzer generates a sequence of randomly generated DSLX functions and a
set of random inputs to each function often with interesting bit patterns.</p>
<p>Given that stimulus, the fuzz driver performs the following actions some of
which may be disabled/enabled via flags (run with <code>--help</code> for more details):</p>
<ul>
<li>Runs the DSLX program through the DSLX interpreter with the batch of
    arguments</li>
<li>Converts the DSLX program to IR</li>
<li>Optimizes the converted IR</li>
<li>Interprets the pre-optimized and optimized IR with the batch of arguments</li>
<li>Generates the Verilog from the IR with randomly selected codegen options</li>
<li>Simulates the generated Verilog using the batch of arguments</li>
<li>Performs a multi-way comparison of the DSLX interpreter results, the
    pre-optimized IR interpreter results, post-optimized IR interpreter results,
    and the simulator results</li>
<li>If an issue is observed, the fuzz driver attempts to minimize the IR that
    causes an issue to occur.</li>
</ul>
<p>The above actions are coordinated and run by the
<a href="https://github.com/google/xls/tree/main/xls/fuzzer/sample_runner.h">SampleRunner</a> class.
Many actions are performed by invoking a separate binary which isolates any
crashes.</p>
<p>When miscompares in results occur or the generated function crashes part of XLS,
all artifacts generated by the fuzzer for that sample are written into a
uniquely-named subdirectory under the <code>--crash_path</code> given in the command line.
The fuzzer also writes a <em>crasher</em> file which is a single file for reproducing
the issue. See <a href="#fuzzer-debugging">below</a> for instructions on debugging a failing
sample.</p>
<h2 id="fuzzer-crashers-directory">Crashers Directory</h2>
<p>The crashers directory includes a subdirectory created for each failing sample.
To avoid collisions the subdirectory is named using a hash of the DSLX code.
Each crasher subdirectory has the following contents:</p>
<div class="highlight"><pre><span></span><code>$ ls /tmp/crashers-2019-06-25/05adbd50
args.txt                   ir_converter_main.stderr   run.sh
cl.txt                     ir_minimizer.options.json  sample.ir
crasher_2020-04-23_9b05.x  ir_minimizer_test.sh       sample.ir.results
eval_ir_main.stderr        options.json               sample.x
exception.txt              opt_main.stderr            sample.x.results
</code></pre></div>
<p>The directory includes the problematic DSLX sample (<code>sample.x</code>) and the input
arguments (<code>args.txt</code>) as well as all artifacts generated and stderr output
emitted by the various utilities invoked to test the sample. Notable files
include:</p>
<ul>
<li><code>options.json</code> : Options used to run the sample.</li>
<li><code>sample.ir</code> : Unoptimized IR generated from the DSLX sample.</li>
<li><code>sample.opt.ir</code> : IR after optimizations.</li>
<li><code>sample.v</code> : Generated Verilog.</li>
<li><code>*.results</code> : The results (numeric values) produced by interpreting or
    simulating the respective input (DSLX, IR, or Verilog).</li>
<li><code>exception.txt</code> : The exception raised when running the sample. Typically
    this will indicate either a result miscomparison or a tool return non-zero
    status (for example, the IR optimizer crashed).</li>
<li><code>crasher_*.x</code>: A single file reproducer which includes the DSLX code,
    arguments, and options. See <a href="#fuzzer-reproducers">below</a> for details.</li>
</ul>
<p>Typically the exact nature of the failure can be identified by reading the file
<code>exception.txt</code> and possibly the stderr outputs of the various tools.</p>
<p>The fuzzer can optionally produce a minimized IR reproduction of the problem.
This will be written to <code>minimized.ir</code>. See <a href="#fuzzer-minimization">below</a> for details.</p>
<h3 id="fuzzer-reproducers">Single-file reproducers</h3>
<p>When the fuzzer encounters an issue it will create a single-file reproducer:</p>
<div class="highlight"><pre><span></span><code>--- Worker 14 observed an exception, noting
--- Worker 14 noted crasher #1 for sampleno 42 at /tmp/crashers/095fb405
</code></pre></div>
<p>Copying that file to the directory <code>//xls/fuzzer/crashers</code> will
automatically create a bazel test target for it and add it to the regression
suite. Tests can also be added as known failures in
<code>//xls/fuzzer/build_defs.bzl</code> as they're being triaged /
investigated like so:</p>
<div class="highlight"><pre><span></span><code>generate_crasher_regression_tests(
    srcs = glob([&quot;crashers/*&quot;]),
    prefix = &quot;xls/fuzzer&quot;,
    # TODO(xls-team): 2019-06-30 Triage and fix these.
    failing = [
        &quot;crashers/crasher_2019-06-29_129987.x&quot;,
        &quot;crashers/crasher_2019-06-29_402110.x&quot;,
    ],
)
</code></pre></div>
<p>Known-failures are marked as manual and excluded from continuous testing.</p>
<p>To run the regression suite:</p>
<div class="highlight"><pre><span></span><code>bazel test //xls/fuzzer:all
</code></pre></div>
<p>To run the regression suite including known-failures, run the regression target
directly:</p>
<div class="highlight"><pre><span></span><code>bazel test //xls/fuzzer:regression_tests
</code></pre></div>
<p>To reproduce from that single-file reproducer there is a command line tool:</p>
<div class="highlight"><pre><span></span><code>bazel run //xls/fuzzer:run_crasher -- \
  crasher_2019-06-26_3354.x
</code></pre></div>
<h2 id="fuzzer-minimization">IR minimization</h2>
<p>By default the fuzzer attempts to generate a minimal IR reproducer for the
problem identified by the DSLX sample. Starting with the unoptimized IR the
fuzzer invokes <code>ir_minimizer_main</code> to reduce the size of the input IR. It uses
various simplification strategies to minimize the number of nodes in the IR. See
the usage description in the tool source code for detailed information.</p>
<p>The minimized IR is written to a file <code>minimized.ir</code> in the crasher directory
for the sample. Note that minimization is only possible if the problem (crash,
result miscomparison, etc.) occurs <em>after</em> conversion from DSLX to XLS IR.</p>
<h2 id="fuzzer-summaries">Summaries</h2>
<p>To monitor progress of the fuzzer and to determine op coverage the fuzzer can
optionally (with <code>--summary_path</code>) write summary information to files. The
summary files are Protobuf files containing the proto <code>SampleSummaryProto</code>
defined in <code>//xls/fuzzer/sample_summary.proto</code>. The summary
information about the IR generated from the DSLX sample such as the number and
type of each IR op as well as the bit width and number of operands.</p>
<p>The summary information also includes a timing breakdown of the various
operations performed for each sample (sample generation, IR conversion, etc).
This can be used to identify performance bottlenecks in the fuzzer.</p>
<p>The summaries can be read with the tool
<code>//xls/fuzzer/read_summary_main</code>. See usage description in the code
for more details.</p>
<h2 id="fuzzer-debugging">Debugging a failing sample</h2>
<p>A generated sample can fail in one of two ways: a tool crash or a result
miscomparison. A tool crash occurred if one of the tools invoked by the fuzzer
(e.g., <code>opt_main</code> which optimizes the IR) returned a non-zero status. A result
miscomparison occurred if there is not perfect correspondence between the
results produced by various ways in which the generated function is evaluated:</p>
<ol>
<li>Interpreted DSLX</li>
<li>Evaluated unoptimized IR</li>
<li>Evaluated optimized IR</li>
<li>Simulation of the generated (System)Verilog</li>
</ol>
<p>Generally, the results produced by the interpretation of the DSLX serves are the
reference results for comparisons.</p>
<p>To identify the underlying cause of the sample failure inspect the
<code>exception.txt</code> file in the crasher directory. The file contains the text of the
exception raised in <code>SampleRunner</code> which clearly identifies the kind of failure
(result miscomparison or tool crash) and details about which evaluation resulted
in a miscompare or which tool crashed, respectively. Consult the following
sections on how to debug particular kinds of failures.</p>
<h3 id="fuzzer-debugging-a-tool-crash">Debugging a tool crash</h3>
<p>The <code>exception.txt</code> file includes the invocation of the tool for reproducing the
failure. Generally, this is a straightforward debugging process.</p>
<p>If the failing tool is the IR optimizer binary <code>opt_main</code> the particular pass
causing the failure should be in the backtrace. To retrieve the input to this
pass, run <code>opt_main</code> with <code>--ir_dump_path</code> to dump the IR between each pass. The
last IR file produced (the files are numbered sequentially) is the input to the
failing pass.</p>
<h3 id="fuzzer-result-miscomparison-unoptimized-ir">Result miscomparison: unoptimized IR</h3>
<p>The evaluation of the unoptimized IR is the first point at which result
comparison occurs (DSLX interpretation versus unoptimized IR evaluation). A
miscomparison here can indicate a bug in one of several places:</p>
<ol>
<li>DSLX interpreter</li>
<li>DSLX to IR conversion</li>
<li>IR interpreter or IR JIT. The error message in <code>exception.txt</code> indicates
    whether the JIT or the interpreter was used.</li>
</ol>
<p>To help narrow this down, the IR interpreter can be compared against the JIT
with the <code>eval_ir_main</code> tool:</p>
<div class="highlight"><pre><span></span><code>  eval_ir_main --test_llvm_jit --input_file=args.txt sample.ir
</code></pre></div>
<p>This runs both the JIT and the interpreter on the unoptimized IR file
(<code>sample.ir</code>) using the arguments in <code>args.txt</code> and compares the results. If
this is successful, then likely the IR interpreter and the JIT are correct and
problem lies earlier in the pipeline (DSLX interpretation or DSLX to IR
conversion). Otherwise, there is definitely a bug in either the interpreter or
the JIT as their results should <em>always</em> be equal.</p>
<p>If a minimized IR file exists (<code>minimized.ir</code>) this may be a better starting
point for isolating the failure.</p>
<h3 id="fuzzer-result-miscomparison-optimized-ir">Result miscomparison: optimized IR</h3>
<p>This can indicate a bug in IR evaluation (interpreter or JIT) or in the
optimizer. In this case, a comparison of the evaluation of the unoptimized IR
against the DSLX interpreter has already succeeds so DSLX interpretation or
conversion is unlikely to be the underlying cause.</p>
<p>As with miscomparison involving the <em>unoptimized</em> IR, <code>eval_ir_main</code> can be used
to compare the JIT results against the interpreter results:</p>
<div class="highlight"><pre><span></span><code>  eval_ir_main --test_llvm_jit --input_file=args.txt sample.opt.ir
</code></pre></div>
<p>If the above invocation fails there is a bug in the JIT or the interpreter.
Otherwise, there may be a bug in the optimizer. The tool <code>eval_ir_main</code> can help
isolate the problematic optimization pass by running with the options
<code>--optimize_ir</code> and <code>--eval_after_each_pass</code>. With these flags, the tool runs
the optimization pipeline on the given IR and evaluates the IR after each pass
is run. The first pass which results in a miscompare against the unoptimized
input IR is flagged. Invocation:</p>
<div class="highlight"><pre><span></span><code>  eval_ir_main --input_file=args.txt \
    --optimize_ir \
    --eval_after_each_pass \
    sample.ir
</code></pre></div>
<h4 id="fuzzer-debugging-the-llvm-jit">Debugging the LLVM JIT</h4>
<p>To help isolate bugs in the JIT, LLVM's optimization level can be set using the
<code>--llvm_opt_level</code> flag:</p>
<div class="highlight"><pre><span></span><code>  eval_ir_main --test_llvm_jit \
    --llvm_opt_level=0 \
    --input_file=args.txt sample.opt.ir
</code></pre></div>
<p>If the results match (pass) with the optimization level set to zero but fail
with the default optimization level of 3, there is likely a bug in the LLVM
optimizer or the XLS-generated LLVM program has undefined behavior.</p>
<p>Unoptimized and optimized LLVM IR are dumped by the JIT with vlog level of 2 or
higher, and the assembly is dumped at level 3 or higher. For example:</p>
<div class="highlight"><pre><span></span><code>  eval_ir_main -v=3 --logtostderr --random_inputs=1 sample.opt.ir
</code></pre></div>
<p>You can also send the optimized or unoptimized IR or asm to a file with the
<code>--llvm_jit_ir_output=&lt;file&gt;</code>, <code>--llvm_jit_opt_ir_output=&lt;file&gt;</code> and
<code>--llvm_jit_asm_output=&lt;file&gt;</code> flags.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code>  eval_ir_main --random_inputs=1 sample.opt.ir --llvm_jit_ir_output=sample.ll
</code></pre></div>
<p>A <code>main</code> function which invokes the jitted code on a particular input can be
created with the <code>--llvm_jit_main_wrapper_output=&lt;file&gt;</code> flag. If the
<code>--llvm_jit_main_wrapper_write_is_linked</code> flag is also given, the result of
invoking the xls function will be written to the stdout. This flag calls and
writes the results for the inputs in the order they are given. This main wrapper
can be <a href="https://llvm.org/docs/CommandGuide/llvm-link.html"><code>llvm-link</code></a>'d with
the ir of the function itself to generate an executable bytecode.</p>
<p>Note: LLVM can change significantly and bytecode is not always compatible
between versions. If possible, LLVM tools built at the same commit as the JIT
should be used to interact with the generated llvm bytecode. This can be done by
building the LLVM tools using <code>bazel</code> from the XLS repo.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>eval_ir_main<span class="w"> </span>--input<span class="w"> </span><span class="s1">&#39;bits[9]:0x0FA;bits[12]:0xEAB&#39;</span><span class="w">        </span><span class="se">\</span>
<span class="w">               </span>--llvm_jit_ir_output<span class="o">=</span>sample.ll<span class="w">                </span><span class="se">\</span>
<span class="w">               </span>--llvm_jit_main_wrapper_output<span class="o">=</span>sample_main.ll<span class="w"> </span><span class="se">\</span>
<span class="w">               </span>--llvm_jit_main_wrapper_write_is_linked<span class="w">       </span><span class="se">\</span>
<span class="w">               </span>sample.opt.ir
$<span class="w"> </span>llvm-link<span class="w"> </span>-S<span class="w"> </span>-o<span class="w"> </span>sample_exe.ll<span class="w"> </span>sample.ll<span class="w"> </span>sample_main.ll
$<span class="w"> </span>lli<span class="w"> </span>sample_exe.ll
</code></pre></div>
<h5 id="fuzzer-building-llvm-tools">Building LLVM tools</h5>
<p>The various LLVM tools such as <code>opt</code> and <code>lli</code> can be built with:</p>
<div class="highlight"><pre><span></span><code>  bazel build /llvm/llvm-project/llvm:all
</code></pre></div>
<p>Build in fastbuild mode to get checks and debug features in LLVM.</p>
<h5 id="fuzzer-running-the-llvm-optimization-passes">Running the LLVM optimization passes</h5>
<p>To run the LLVM IR optimizer run the following (starting with the <em>unoptimized</em>
IR):</p>
<div class="highlight"><pre><span></span><code>  opt sample.ll -O3 -S
</code></pre></div>
<p>To print the IR before and after each pass:</p>
<div class="highlight"><pre><span></span><code> opt sample.ll -S -print-after-all -print-before-all -O3
</code></pre></div>
<h5 id="fuzzer-running-the-instcombine-pass">Running the Instcombine pass</h5>
<p>Instcombine is an LLVM optimization pass which is a common source of bugs in
code generated from XLS. To run instcombine alone:</p>
<div class="highlight"><pre><span></span><code> opt /tmp/bad.ll -S -passes=instcombine
</code></pre></div>
<p>Instcombine is a large monolithic pass and it can be difficult to isolate the
exact transformation which caused the problem. Fortunately, this pass includes a
"compiler fuel" option which can be used to limit the number of transformations
performed by the pass. Example usage (fastbuild of LLVM is required):</p>
<div class="highlight"><pre><span></span><code>opt -S --instcombine sample.ll --debug-counter=instcombine-visit-skip=0,instcombine-visit-count=42
</code></pre></div>
<h5 id="fuzzer-evaluating-llvm-ir">Evaluating LLVM IR</h5>
<p>The LLVM tool <code>lli</code> evaluates LLVM IR. The tool expects the IR to include a
entry function <code>main</code>. This can be generated by <code>eval_ir_main
--llvm_jit_main_wrapper_output=&lt;file&gt; --llvm_jit_main_wrapper_write_is_linked</code>.
See the description in the <a href="#tools-jit-inspection">tools page</a> for how these
flags work.</p>
<p>Once both the main wrapper bytecode file and the function bytecode files are
created they can be linked to a single file using <code>llvm-link</code>:</p>
<div class="highlight"><pre><span></span><code>llvm-link<span class="w"> </span>-S<span class="w"> </span>-o<span class="w"> </span>sample_linked.ll<span class="w"> </span>sample.ll<span class="w"> </span>sample_main.ll
</code></pre></div>
<p>The LLVM tool <code>opt</code> optimizes the LLVM IR and can be piped to <code>lli</code> like so:</p>
<div class="highlight"><pre><span></span><code>  opt sample_linked.ll --O2 | lli
</code></pre></div>
<p>The LLVM IR can also compiled to an object file using <code>llc</code> and driven using a
generated llvm test wrapper. The directory <code>xls/fuzzer/debug</code> includes a script
and example demonstrating how to run JIT-generated LLVM IR in this manner.</p>
<h5 id="fuzzer-running-llvm-code-generation">Running LLVM code generation</h5>
<p>If the bug occurs during LLVM code generation (lowering of LLVM IR to object
code) the LLVM tool <code>llc</code> may be used to reproduce the problem. <code>llc</code> takes LLVM
IR and produces assembly or object code. Example invocation for producing object
code:</p>
<div class="highlight"><pre><span></span><code>llc sample_linked.ll -o sample.o --filetype=obj
</code></pre></div>
<p>The exact output of <code>llc</code> depends on the target machine used during compilation.
Logging in the OrcJit (at vlog level 1) will emit the exact <code>llc</code> invocation
which uses the same target machine as the JIT.</p>
<h3 id="fuzzer-result-miscomparison-simulated-verilog">Result miscomparison: simulated Verilog</h3>
<p>This can be a bug in codegen, XLS's Verilog testbench code, or the Verilog
simulator itself. Running the generated Verilog with different simulators can
help isolate the problem:</p>
<div class="highlight"><pre><span></span><code>  simulate_module_main --signature_file=module_sig.textproto \
    --args_file=args.txt \
    --verilog_simulator=iverilog \
    sample.v

  simulate_module_main --signature_file=module_sig.textproto \
    --args_file=args.txt \
    --verilog_simulator=${SIM_2} \
    sample.v
</code></pre></div>
<p>The tool outputs the results of the evaluation to stdout so diffing their
outputs is required.</p>
<h3 id="fuzzer-filing-an-llvm-bug">Filing an LLVM bug</h3>
<p>If the fuzzer problem is due to a crash or miscompile by LLVM, file an LLVM bug
<a href="https://github.com/llvm/llvm-project/issues">here</a>. Example LLVM bugs found by
the fuzzer: <a href="https://github.com/llvm/llvm-project/issues/61127">1</a>,
<a href="https://github.com/llvm/llvm-project/issues/61038">2</a>.</p>
<p>Although the internal Google mirror of LLVM is updated frequently, prior to
filing an LLVM bug it's a good idea to verify the failure against LLVM head.
Steps to build a debug build of LLVM:</p>
<div class="highlight"><pre><span></span><code>git clone https://github.com/llvm/llvm-project.git
cd llvm-project
mkdir build
cd build
cmake -G Ninja ../llvm -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD=X86
cmake --build . -- opt # or llc or other target.
</code></pre></div>
<p>Below are instructions to configure LLVM with sanitizers enabled. This can be
useful for reproducing issues found with the sanitizer-enabled fuzz tests.</p>
<div class="highlight"><pre><span></span><code># Install a version of LLVM which supports necessary sanitizer options.
sudo apt-get install lld-15 llvm-15 clang-15 libc++1-15
# In llvm-project directory:
mkdir build-asan
cd build-asan
TOOLBIN=/usr/lib/llvm-15/bin
# Below enables a particular sanitizer option `sanitize-float-cast-overflow`.
# `Address` can be used as an option instead of `Undefined` depending on the
# desired sanitizer check.
cmake ../llvm -GNinja -DCMAKE_BUILD_TYPE=RelWithDebInfo \
  -DCMAKE_CXX_COMPILER=$TOOLBIN/clang++ -DCMAKE_C_COMPILER=$TOOLBIN/clang \
  -DLLVM_USE_SANITIZER=Undefined \
  -DLLVM_UBSAN_FLAGS=&#39;-fsanitize=float-cast-overflow -fsanitize-undefined-trap-on-error&#39; \
  -DLLVM_ENABLE_LLD=On -DLLVM_TARGETS_TO_BUILD=X86
</code></pre></div>
<p>LLVM includes a test case minimizer called
<a href="https://llvm.org/docs/Bugpoint.html"><code>bugpoint</code></a> which tries to reduce the size
of an LLVM IR test case. <code>bugpoint</code> has many options but it can operate in a
similar manner to the XLS IR minimizer where a user-specified script is used to
determine whether the bug exists in the LLVM IR:</p>
<div class="highlight"><pre><span></span><code>bugpoint input.ll -compile-custom -compile-command bugpoint_test.sh
</code></pre></div>
<p>Example bugpoint test script (<code>bugpoint_test.sh</code>):</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="c1"># Create a temporary file for the test command</span>
<span class="nv">logfile</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>mktemp<span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># Run your test command (and redirect the output messages)</span>
/path/to/llc<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="w"> </span>-o<span class="w"> </span>/tmp/out.o<span class="w"> </span>-mcpu<span class="o">=</span>skylake-avx512<span class="w"> </span>--filetype<span class="o">=</span>obj<span class="w"> </span>&gt;<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">logfile</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
<span class="nv">ret</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span>

<span class="c1"># Print messages when error occurs</span>
<span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">ret</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>!<span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;test failed&quot;</span><span class="w">  </span><span class="c1"># must print something on failure</span>
<span class="w">  </span>cat<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">logfile</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="c1"># Cleanup the temporary file</span>
rm<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">logfile</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="nb">exit</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">ret</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div></section><section class="print-page" id="dslx_bytecode_interpreter"><h1 id="dslx_bytecode_interpreter-bytecode-interpreter">Bytecode interpreter</h1>
<p>DSLX provides a <a href="https://en.wikipedia.org/wiki/Bytecode">bytecode interpreter</a>
for expression evaluation. This style of interpreter can be started, stopped,
and resumed more easily than an AST-walking native interpreter, as its full
state can be captured as <code>{PC, stack}</code> instead of some traversal state
in native execution, which makes it very suitable for modeling independent
processes, such as <code>Proc</code>s.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The bytecode interpreter system is under active construction and does not
yet support the full set of DSLX functionality.</p>
</div>
<div class="toc">
<ul>
<li><a href="#dslx_bytecode_interpreter-bytecode-interpreter">Bytecode interpreter</a><ul>
<li><a href="#dslx_bytecode_interpreter-structure">Structure</a></li>
<li><a href="#dslx_bytecode_interpreter-isa">ISA</a></li>
<li><a href="#dslx_bytecode_interpreter-bytecode-generation">Bytecode generation</a></li>
<li><a href="#dslx_bytecode_interpreter-implementation-details">Implementation details</a><ul>
<li><a href="#dslx_bytecode_interpreter-map-builtin">map builtin</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="dslx_bytecode_interpreter-structure">Structure</h2>
<p><a href="https://github.com/google/xls/tree/main/xls/dslx/bytecode/bytecode_interpreter.h">The interpreter</a>
is implemented as a
<a href="https://en.wikipedia.org/wiki/Stack_machine">stack virtual machine</a>: it
consists of a program counter (PC), a stack of frames, and "slot"-based locals
within a given stack frame (<em>conceptually</em> part of the stack frame, but tracked
separately in our implementation). Both the stack and local storage hold
<a href="https://github.com/google/xls/tree/main/xls/dslx/interp_value.h"><code>InterpValues</code></a>, which
can hold all DSLX data types: bits, tuples, and arrays (and others), thus there
is no fundamental need for lower-level (i.e., byte) type representation. For the
purposes of [de]serialization, this may change in the future. Local data is
addressed by integer-typed "slots", being backed by a simple <code>std::vector</code>: in
other words, slot indices are dense. All slots must be pre-allocated to contain
all references to locals in the current function stack frame.</p>
<p>On each "tick", the interpreter reads the current instruction, as given by the
PC (conceptually, the only register in the virtual machine), executes the
described operation (usually consuming values from the stack), and places the
result on the stack.</p>
<h2 id="dslx_bytecode_interpreter-isa">ISA</h2>
<p>Each instruction consists of an opcode plus, optionally, some piece of data,
either <code>int64</code>- or <code>InterpValue</code>-typed, depending on the specific opcode.</p>
<p>The below opcodes are supported by the interpreter:</p>
<ul>
<li><code>ADD</code>: Adds the two values at the top of the stack.</li>
<li><code>CALL</code>: Invokes the function given as the optional data argument, consuming
    a number of arguments from the stack as described by the function signature.
    The N'th parameter will be present as the N'th value down the stack (such
    that the last parameter will be the value initially on top of the stack.</li>
<li><code>CREATE_TUPLE</code>: Groups together N items on the stack (given by the optional
    data argument into a single <code>InterpValue</code>.</li>
<li><code>EXPAND_TUPLE</code>: Expands the N-tuple at stack top by one level, placing
    leading elements at stack top. In other words, expanding the tuple <code>(a, (b,
    c))</code> will result in a stack of <code>(b, c), a</code>, where <code>a</code> is on top of the
    stack.</li>
<li><code>EQ</code>: Compares the two values on top of the stack for equality. Emits a
    single-bit value.</li>
<li><code>LOAD</code>: Loads the value from locals slot <code>n</code>, where <code>n</code> is given by the
    optional data argument.</li>
<li><code>LITERAL</code>: Places a literal value (given in the optional data argument) on
    top of the stack.</li>
<li><code>STORE</code>: Stores the value at stack top into slot <code>n</code> in locals storage.</li>
</ul>
<h2 id="dslx_bytecode_interpreter-bytecode-generation">Bytecode generation</h2>
<p>The
<a href="https://github.com/google/xls/tree/main/xls/dslx/bytecode/bytecode_emitter.h">bytecode emitter</a>
is responsible for converting a set of DSLX ASTs (one per function)) into a set
of linear bytecode representations. It does this via a postorder traversal of
the AST, converting XLS ops into bytecode instructions along the way, e.g.,
converting a DSLX <code>Binop</code> for adding two <code>NameRef</code>s into two <code>LOAD</code> instructions
(one for each <code>NameRef</code>) and one <code>ADD</code> instruction.</p>
<p>To do this, the emitter needs access to the full set of resolved type and import
information: in other words, it requires a fully-populated
<a href="https://github.com/google/xls/tree/main/xls/dslx/import.h"><code>ImportData</code></a> and the
top-level
<a href="https://github.com/google/xls/tree/main/xls/dslx/type_system/type_info.h"><code>TypeInfo</code></a> for
the module containing the function to convert. This places bytecode emission in
sequence after typechecking and deduction.</p>
<h2 id="dslx_bytecode_interpreter-implementation-details">Implementation details</h2>
<h3 id="dslx_bytecode_interpreter-map-builtin"><code>map</code> builtin</h3>
<p>The <code>map()</code> function built-in to DSLX accepts an array-typed value <code>x</code> and a
mapping function <code>f</code> with the signature <code>T -&gt; U</code>; that is, it accepts a single
value of type <code>T</code> and returns a single value with the type <code>U</code>. In operation,
<code>map()</code> applies the mapping function <code>f</code> to every element in <code>x</code> and returns a
new array containing the results (with element <code>i</code> in the output corresponding
to element <code>i</code> in the input).</p>
<p>Conceptually, <code>map()</code> destructures to a <code>for</code> loop over the elements in <code>x</code>, and
that's essentially what the interpreter does with these opcodes. To avoid
modifying the currently executing bytecode, the interpreter instead creates a
new BytecodeFunction consisting of just that destructured <code>for</code> loop over the
inputs, followed by a CreateArray op to collect the output(s). Finally, the
interpreter begins execution of the new function by creating a new <code>Frame</code> on
top of the execution stack.</p></section><section class="print-page" id="dslx_ffi"><h1 id="dslx_ffi-dslx-ffi-interfacing-with-verilog-modules">DSLX FFI interfacing with Verilog Modules</h1>
<p>Sometimes it might be useful to instantiate existing Verilog modules from DSLX.
This could be for various reasons; sometimes there is an existing code-base with
specific optimizations one wants to use.</p>
<p>The concept of calling an external implementation from some language is
typically referred to as Foreign Function Interface or short FFI, used below
for brevity.</p>
<p>DSLX can interface with combinational Verilog modules; <a href="https://github.com/google/xls/issues/1301">sequential FFI</a> is
planned.</p>
<h2 id="dslx_ffi-foreign-function-interface-in-dslx">Foreign Function Interface in DSLX</h2>
<p>Every external module to interface will need to have a DSLX implementation
as a function with an annotation that tells DSLX the module instantiation
at code-generation time. The DSLX implementation will be used in the interpreter
and JIT, for instance in tests.</p>
<h3 id="dslx_ffi-simple-example">Simple Example</h3>
<p>Suppose you'd like to instantiate the following Verilog module in a DSLX design:</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">myfoo</span><span class="w"> </span><span class="p">#(</span>
<span class="w">  </span><span class="k">parameter</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32</span>
<span class="p">)(</span>
<span class="w">  </span><span class="k">input</span><span class="w"> </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">out</span>
<span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="k">endmodule</span>
</code></pre></div>
<p>First, write a DSLX function, that has the relevant inputs and and return value,
as well as a implementation that is functionally equivalent. Here, there is one
<code>input</code> parameter, mapped to a function parameter, and one <code>output</code> parameter,
mapped to the return of the DSLX function:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div>
<p>You can now add an annotation <code>#[extern_verilog("...")]</code> to the DSLX function
that contains a textual template for the instantiation that should happen. There
are placeholders in <code>{...}</code>-braces that will be replaced with the actual values
at code-generation time:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[extern_verilog(</span><span class="s">&quot;</span>
<span class="s">myfoo {fn} (       // Placeholder for the instantiation name.</span>
<span class="s">   .x({a}),        // Reference to name in function parameter.</span>
<span class="s">   .out({return})  // Placeholder for the output.</span>
<span class="s">);                 // Semicolon optional, code-generation will always add one.</span>
<span class="s">&quot;</span><span class="cp">)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div>
<p>Let's look at this in detail</p>
<ul>
<li>Inside the <code>extern_verilog("...")</code>, you add the code that will be the
    Verilog instantiation of the particular module: this is just a regular
    module instantiation of the module <code>myfoo</code> that you'd like to interface
    with.</li>
<li>The <code>{fn}</code> placeholder is needed and will be expanded to the actual
    instantiation name decided at code-generation time.</li>
<li>The <code>{a}</code> placeholder references a value in the function prototype, in this
    case the parameter <code>a</code>.</li>
<li>The output parameter of the <code>myfoo</code> function is wired to the special value
    <code>{return}</code> which represents the return value of the function.</li>
<li>The types the module will receive are based on the type mentioned in the
    function prototype. Parameter <code>a</code> and the return value are both u32, so
    <code>.x()</code> and <code>.out()</code> will be connected to <code>wire [31:0]</code>'s at code generation
    time.</li>
</ul>
<h2 id="dslx_ffi-parameterization">Parameterization</h2>
<p>DSLX functions allow <a href="#dslx_reference-parametric-functions">parameterization</a> as do Verilog
modules. The same technique as above can be applied to parameters, referencing
values in the function prototype in the instantiation template in curly braces.
DSLX parameter values are const-evaluated and then provided in the textual
template under the given name. With this, you can now make full use of the
parametric properties of the Verilog module:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[extern_verilog(</span><span class="s">&quot;</span>
<span class="s">myfoo {fn} #(</span>
<span class="s">   .N({WIDTH})     // Expanded to the constant determined at compile-time.</span>
<span class="s">)(</span>
<span class="s">   .x({a}),</span>
<span class="s">   .out({return})</span>
<span class="s">)</span>
<span class="s">&quot;</span><span class="cp">)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="o">&lt;</span><span class="n">WIDTH</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="nc">bits</span><span class="p">[</span><span class="n">WIDTH</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">WIDTH</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">WIDTH</span><span class="p">]:</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div>
<p>This will now automatically parameterize the module instantiation with the same
parameter value the DSLX function is called.</p>
<h2 id="dslx_ffi-mapping-aggregate-types">Mapping Aggregate types</h2>
<p>The first example looked at a simple integer type for parameter and return
values, but it is also possible to refer to <a href="#dslx_reference-tuple-type">tuples</a>, another common way to
represent more complex data in DSLX. You can refer to values inside tuples in
the same way you'd do inside DSLX, with an index suffix:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[extern_verilog(</span><span class="s">&quot;</span>
<span class="s">mybar {fn} (</span>
<span class="s">   .x({a.0}),</span>
<span class="s">   .y({a.1}),</span>
<span class="s">   .z({b}),</span>
<span class="s">   .someout({return.0}),</span>
<span class="s">   .otherout({return.1})</span>
<span class="s">)</span>
<span class="s">&quot;</span><span class="cp">)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">:(</span><span class="n">s32</span><span class="p">,</span><span class="w"> </span><span class="n">s32</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="nc">s32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s32</span><span class="p">,</span><span class="w"> </span><span class="n">s32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>If you just access the tuple by its name (e.g. <code>a</code> in this case), the Verilog
module receives the bit-concatenated content of that tuple, <code>a.0 ++ a.1</code>.</p>
<p>In the <code>xls/examples</code> directory, you find a more complete <a href="https://github.com/google/xls/tree/main/xls/examples/ffi.x">ffi example</a>
including nested tuples (<code>{return.0.1}</code>).</p>
<h2 id="dslx_ffi-code-generation">Code Generation</h2>
<p>The code generator needs to know the critical path delay of the Verilog module
to be able to do proper scheduling and pipelining. This information can be
provided by a <a href="#codegen_options-pipelining-and-scheduling-options">codegen parameter</a> <code>--ffi_fallback_delay_ps</code> (see BUILD file in
the <a href="https://github.com/google/xls/tree/main/xls/examples/ffi.x">ffi example</a>).</p>
<p>There are plans for an automatic <a href="https://github.com/google/xls/issues/1399">ffi delay estimate</a>.</p>
<h2 id="dslx_ffi-tips-and-tricks">Tips and Tricks</h2>
<p>The following examples are technically possible right now, but it should not
necessarily be considered a supported use-case.</p>
<p>Given that the Verilog template just accepts Verilog pasted into the output, you
can use Verilog features to do some transformations directly inside the template
while accessing the parameters from the DSLX function prototype:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[extern_verilog(</span><span class="s">&quot;</span>
<span class="s">mybaz {fn} #(</span>
<span class="s">   .WIDTH($bits({a}))              // Calling system functions</span>
<span class="s">)(</span>
<span class="s">   .modify((42)&#39;({a})),            // Type casting</span>
<span class="s">   .all_the_bits({{ {b}, {c} }}),  // Concatenate; note escaped braces.</span>
<span class="s">   .out({return})</span>
<span class="s">)</span>
<span class="s">&quot;</span><span class="cp">)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">:</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="w">  </span><span class="c1">// local implementation</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that the Verilog concatenation needs to use curly braces, but since these
are 'special' characters within the textual template, they need to be escaped.
This is done by doubling them up: <code>{{...}}</code> will result in <code>{...}</code> in the
code-generated output.</p>
<p>In this particular example for the system function it would probably be a good
idea to const-evaluate expressions as part of the <a href="#dslx_reference-parametric-functions">parametric function</a>
parameters, then pass this constant.</p>
<p>Even the following will work: create a local wire and assignments that we
assemble from parameters to the template; here, we use that to adapt the <code>wire
[42:0]</code> output of <code>myquux</code> to whatever our return type is:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[extern_verilog(</span><span class="s">&quot;</span>

<span class="s">wire [42:0] {return}_adapted_to_module;</span>

<span class="s">myquux {fn} (</span>
<span class="s">   .x(a)</span>
<span class="s">   .out({return}_adapted_to_module)</span>
<span class="s">);</span>

<span class="s">assign {return} = ({RESULT_BITS})&#39;({return}_adapted_to_module);</span>
<span class="s">&quot;</span><span class="cp">)]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">quux</span><span class="o">&lt;</span><span class="n">RESULT_BITS</span><span class="p">:</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">uN</span><span class="p">[</span><span class="n">RESULT_BITS</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">uN</span><span class="p">[</span><span class="n">RESULT_BITS</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>
<p>Of course, at that point, XLS can't guarantee anymore that wire identifiers are
unique. Handle this rope with care :)</p></section><section class="print-page" id="dslx_language_server"><h1 id="dslx_language_server-dslx-language-server">DSLX Language Server</h1>
<p>Many popular editors in the modern era are speaking a common protocol in order
to understand how to display, traverse, and maniulate languages: the
<a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">"Language Server Protocol"</a>.
This allows novel languages and DSLs, like DSLX, to expose a developer
experience integrated in their preferred editors and IDEs.</p>
<p><strong>To use the language server protocol in your editor you do not need to know any
details about the language server protocol.</strong></p>
<p>Language server feedback in the editor is useful to folks who are learning DSLX
as well as those developing in it on a regular basis! The language server
currently offers functionality such as:</p>
<ul>
<li>Go-to-definition</li>
<li>Errors/warnings as you type</li>
<li>An "overview" of the symbols defined in a module</li>
</ul>
<p>For more background on what the language server protocol can do, see
<a href="https://microsoft.github.io/language-server-protocol/">the Language Server Protocol documentation and specification</a>.</p>
<h2 id="dslx_language_server-building-the-dslx-language-server-binary">Building the DSLX Language Server binary</h2>
<p>The following are instructions for building the DSLX language server binary. By
a) placing the language server binary into your <code>PATH</code> and b) configuring your
editor to handle <code>.x</code> files by using it.</p>
<p>Follow the
<a href="https://google.github.io/xls/#building-from-source">XLS build setup instructions</a>
so that the pre-requisites are available for building binaries via Bazel. Then,
build the following <code>dslx_ls</code> binary and place it in your <code>PATH</code>:</p>
<div class="highlight"><pre><span></span><code>~/xls$ bazel build -c opt //xls/dslx/lsp:dslx_ls
~/xls$ mkdir ~/bin/
~/xls$ cp -iv bazel-bin/xls/dslx/lsp/dslx_ls ~/bin/
~/xls$ export PATH=$HOME/bin:$PATH
</code></pre></div>
<p>Now that the language server binary is available in your <code>PATH</code>, you must
configure your editor to find/use it for <code>.x</code> files.</p>
<h2 id="dslx_language_server-vim">Vim</h2>
<p>First we must install <code>vim-plug</code> -- follow the latest instructions at
<code>https://github.com/junegunn/vim-plug</code>; e.g.:</p>
<div class="highlight"><pre><span></span><code>$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre></div>
<p>Add the following configuration to your <code>$HOME/.vimrc</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">call</span> plug#begin<span class="p">()</span>
Plug <span class="s1">&#39;prabirshrestha/vim-lsp&#39;</span>
Plug <span class="s1">&#39;prabirshrestha/asyncomplete-lsp.vim&#39;</span>
Plug <span class="s1">&#39;mattn/vim-lsp-settings&#39;</span>

<span class="k">call</span> plug#<span class="k">end</span><span class="p">()</span>

<span class="k">let</span> <span class="k">g</span>:lsp_log_verbose <span class="p">=</span> <span class="m">1</span>
<span class="k">let</span> <span class="k">g</span>:lsp_log_file <span class="p">=</span> expand<span class="p">(</span><span class="s1">&#39;~/vim-lsp.log&#39;</span><span class="p">)</span>

<span class="k">if</span> executable<span class="p">(</span><span class="s1">&#39;dslx_ls&#39;</span><span class="p">)</span>
    <span class="k">au</span> <span class="nb">User</span> lsp_setup <span class="k">call</span> <span class="nb">lsp</span>#register_server<span class="p">(</span>{
        \ <span class="s1">&#39;name&#39;</span>: <span class="s1">&#39;dslx_ls&#39;</span><span class="p">,</span>
        \ <span class="s1">&#39;cmd&#39;</span>: {server_info<span class="p">-&gt;</span>[<span class="s1">&#39;dslx_ls&#39;</span>]}<span class="p">,</span>
        \ <span class="s1">&#39;allowlist&#39;</span>: [<span class="s1">&#39;dslx&#39;</span><span class="p">,</span> <span class="s1">&#39;.x&#39;</span>]<span class="p">,</span>
        \ }<span class="p">)</span>
<span class="k">endif</span>

<span class="k">let</span> <span class="k">g</span>:lsp_diagnostics_echo_cursor <span class="p">=</span> <span class="m">1</span>
<span class="k">let</span> <span class="k">g</span>:lsp_diagnostics_highlights_enabled <span class="p">=</span> <span class="m">1</span>
<span class="k">let</span> <span class="k">g</span>:lsp_diagnostics_signs_enabled <span class="p">=</span> <span class="m">1</span>

<span class="k">au</span> <span class="nb">BufRead</span><span class="p">,</span><span class="nb">BufNewFile</span> *.<span class="k">x</span> <span class="k">set</span> <span class="k">filetype</span><span class="p">=</span>dslx
</code></pre></div>
<p>Run vim and execute <code>:PlugInstall</code> to get the new LSP plugins. After that
completes successfully, quit Vim (famously, via <code>:q</code>).</p>
<p>Open <code>foo.x</code> in vim and then paste the following contents:</p>
<div class="highlight"><pre><span></span><code>fn main() -&gt; u8 { u8:256 }
</code></pre></div>
<p>The following should show in the display line:</p>
<div class="highlight"><pre><span></span><code>LSP: uN[8] Value &#39;256&#39; does not fit in the bitwidth of a uN[8] (8). Valid values are [0, 255].
</code></pre></div>
<p>If not, try using <code>:LspStatus</code> To see if any diagnostics are available.</p>
<p>If you correct the <code>u8</code> value to be 255 (and thus in range) you can run:</p>
<p><code>:LspDocumentSymbol</code></p>
<p>To see the defined symbol listing -- this shows all defined symbols in the file:</p>
<div class="highlight"><pre><span></span><code>foo.x|1 col 1| method : main
</code></pre></div>
<h3 id="dslx_language_server-troubleshooting">Troubleshooting</h3>
<p>With the above <code>.vimrc</code> contents, logs should show up in <code>$HOME/vim-lsp.log</code>.</p>
<p>Issues can be filed against
<a href="https://github.com/google/xls/issues">https://github.com/google/xls/issues</a>
with associated contents/logs.</p>
<h2 id="dslx_language_server-emacs">Emacs</h2>
<p>The following <code>.emacsrc</code> snippet wires up the language server in emacs,
piggy-backing on the Rust major mode.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">which-key-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">&#39;lsp-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">&#39;auto-mode-alist</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;\\.x\\&#39;&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">rust-mode</span><span class="p">))</span>
<span class="c1">;; DSLX can make rust-mode very slow for large files due to angle bracket</span>
<span class="c1">;; matching which is inefficiently implemented. Disable the feature.</span>
<span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">rust-match-angle-brackets</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">&#39;lsp-language-id-configuration</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">rust-mode</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;dslx&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nv">lsp-register-client</span>
<span class="w"> </span><span class="p">(</span><span class="nv">make-lsp-client</span><span class="w"> </span><span class="nb">:new-connection</span><span class="w"> </span><span class="p">(</span><span class="nv">lsp-stdio-connection</span><span class="w"> </span><span class="s">&quot;~/bin/dslx_ls&quot;</span><span class="p">)</span>
<span class="w">                  </span><span class="nb">:major-modes</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">rust-mode</span><span class="p">)</span>
<span class="w">                  </span><span class="nb">:server-id</span><span class="w"> </span><span class="ss">&#39;dslx-ls</span><span class="p">))</span>
<span class="p">(</span><span class="nv">add-hook</span><span class="w"> </span><span class="ss">&#39;rust-mode-hook</span><span class="w"> </span><span class="ss">&#39;lsp</span><span class="p">)</span>
</code></pre></div>
<p>Additional details on Emacs enablement may be available in the
<a href="https://github.com/chipsalliance/verible/blob/master/verilog/tools/ls/README.md#hooking-up-to-editor">Verible editor hook-up documentation</a>.</p>
<h2 id="dslx_language_server-sublime-text">Sublime Text</h2>
<h3 id="dslx_language_server-create-a-dslx-syntax">Create a DSLX syntax</h3>
<p>Go to <code>Tools &gt; Developer &gt; New Syntax</code>, then replace values in the template:</p>
<ul>
<li>Change the <code>file_extensions</code> value to be <code>x</code></li>
<li>Change scope to be <code>source.dslx</code></li>
<li>Replace all <code>example-c</code> in the file with <code>dslx</code></li>
</ul>
<p>Now when you open a <code>.x</code> file it should show the syntax in the lower right-hand
corner as <code>dslx</code>.</p>
<h3 id="dslx_language_server-install-lsp-package">Install LSP package</h3>
<p>Instructions for installing the LSP package are given in the
<a href="https://github.com/chipsalliance/verible/blob/master/verilog/tools/ls/README.md#sublime">Verible documentation</a>.</p>
<h3 id="dslx_language_server-add-dslx-to-lsp-settings">Add DSLX to LSP settings</h3>
<p>Open the configuration via <code>Preferences &gt; Package Settings &gt; LSP &gt; Settings</code> and
add the following client:</p>
<div class="highlight"><pre><span></span><code>{
    &quot;clients&quot;: {
        &quot;dslx_ls&quot;: {
          &quot;command&quot;: [&quot;dslx_ls&quot;],
          &quot;enabled&quot;: true,
          &quot;selector&quot;: &quot;source.dslx&quot;
        }
    }
}
</code></pre></div>
<p>Now open <code>foo.x</code> and paste in:</p>
<p><code>fn main() -&gt; u8 { u8:256 }</code></p>
<p>There should be a red squiggle under the number <code>256</code> indicating that the value
is out of range for a <code>u8</code>.</p>
<h2 id="dslx_language_server-other-editors">Other Editors</h2>
<p>For non-Vim editors, see the instructions provided by
<a href="https://github.com/chipsalliance/verible/blob/master/verilog/tools/ls/README.md#hooking-up-to-editor">our sister project, Verible</a>.</p></section><section class="print-page" id="dslx_type_system"><h1 id="dslx_type_system-dslx-type-system">DSLX: Type System</h1>
<p>The DSL (frontend) performs a few primary tasks:</p>
<ol>
<li>Parsing text files to an AST representation.</li>
<li>Typechecking the AST representation.</li>
<li>Conversion of the AST to bytecode that can be interpreted.</li>
<li>Conversion of the AST to XLS IR (from which it can be interpreted or
    optimized or scheduled or code generated, etc.)</li>
</ol>
<p>Note that step #2 is an essential component for steps #3 and #4 -- the type
information computed in the type checking process is used by the bytecode
emission/evaluation and IR conversion processes.</p>
<p>(You could imagine a bytecode interpreter that did not use any pre-computed type
information and tried to derive it all dynamically, but that is not how the
system is set up -- using the type information from typechecking time avoids
redundant work and replication of similar code in a way that could get out of
sync.)</p>
<p>Aside: bytecode emission/interpretation may also be necessary for constexpr
(compile-time constant) evaluation, and so #2 and #3 will be interleaved to some
degree.</p>
<h2 id="dslx_type_system-parametric-instantiation">Parametric Instantiation</h2>
<p>The most interesting thing that happens in the type system, and one of the main
things that the DSL provides as a useful abstraction on top of XLS IR, is
<em>parametric instantiation</em>. This is where users write a parameterized function
(or proc) and instantiate it with particular concrete parmeters; e.g.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// A parametric (identity) function.</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="p">(</span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">)</span><span class="w">  </span><span class="c1">// Instantiates p with N=8</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(),</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">42</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>This allows us to write more generic code as library-style functions, which
dovetails nicely with the facilities that XLS core has to schedule and optimize
across cycles.</p>
<p>With parametric instantiation as a feature, several questions around the nature
of the parameterized definition are raised; e.g.</p>
<ul>
<li>When <code>p</code> is defined with a parametric <code>N</code>, should we check that the
    definition has no type errors "for all N"? (Note: we do not.)</li>
<li>If <code>p</code> is not instantiated anywhere, do we check that <code>p</code> has no type errors
    for "there exists some N"? (Note: we do not.)</li>
</ul>
<p>These relate to the "laziness" of parametric instantiation. As a historical
example for comparison, C++ originally had template definitions as token
substitutions, not even ensuring that the definition could parse, more akin to
syntactic macros.</p>
<h2 id="dslx_type_system-typechecked-on-instantiation">Typechecked on Instantiation</h2>
<p>In the DSL, as noted above, the definitions of parametric instances are parsed,
but not typechecked until instantiation, and errors are raised if the concrete
set of parameterized values cause a type error during instantiation. That is:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">N</span><span class="p">()</span><span class="w">  </span><span class="c1">// type error on instantiation: cannot invoke a number</span>
<span class="p">}</span>
</code></pre></div>
<p>If there is no instantiation of <code>p</code>, this definition will parse, but the type
error will go unreported, because it is never instantiated, and thus never type
checked. If another function were to instantiate it by calling <code>p</code>, however, a
type error would occur due to that instantiation.</p>
<p>Similarly, we can consider a definition that does not work "for all N", but
works "for one N", and that's the only <code>N</code> we instantiate it with.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">const_assert</span><span class="o">!</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="n">u42</span><span class="p">:</span><span class="mi">64</span>
<span class="p">}</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u42</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="o">&gt;</span><span class="p">()</span><span class="w">  </span><span class="c1">// this is fine</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="dslx_type_system-parametric-evaluation-ordering">Parametric Evaluation Ordering</h2>
<p>There are three components to parametric invocations. (Note: "binding" refers to
the assignment of a value to each named parameter.)</p>
<ol>
<li>Binding explicit values (given in angle brackets, i.e. <code>&lt;&gt;</code>) given in the
    caller</li>
<li>Binding actual arguments (passed by the caller) against the parametric
    bindings</li>
<li>Filling in any "remaining holes" in the parametric bindings using <em>default
    expressions</em> in the parametric bindings</li>
</ol>
<p>The three components are performed in that order.</p>
<h3 id="dslx_type_system-1-binding-explicit-values">1: Binding Explicit Values</h3>
<p>In this example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="n">A</span><span class="p">],</span><span class="w"> </span><span class="n">bits</span><span class="p">[</span><span class="n">B</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="n">A</span><span class="p">]:</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">bits</span><span class="p">[</span><span class="n">B</span><span class="p">]:</span><span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>The caller <code>main</code> explicitly binds the parametrics <code>A</code> and <code>B</code> by supplying
arguments in the angle brackets.</p>
<h3 id="dslx_type_system-2-binding-actual-arguments">2: Binding Actual Arguments</h3>
<p>In this example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bits</span><span class="p">[</span><span class="n">A</span><span class="p">]:</span><span class="mi">1</span>
<span class="p">}</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u13</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="p">(</span><span class="n">u13</span><span class="p">:</span><span class="mi">42</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(),</span><span class="w"> </span><span class="n">u13</span><span class="p">:</span><span class="mi">43</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><code>main</code> is implicitly saying what <code>A</code> must be by passing a <code>u13</code> -- we know that
the parameter to <code>p</code> is declared to be a <code>bits[A]</code>, so we know that <code>A</code> must be
<code>13</code> since a <code>u13</code> was passed as the "actual" argument (i.e. argument value from
the caller).</p>
<p>Note that if you contradict an explicit binding and a binding from actual
arguments, you will get a type error; e.g. this will cause a type error:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">u13</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">14</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u13</span><span class="p">:</span><span class="mi">42</span><span class="p">)</span><span class="w">  </span><span class="c1">// explicit says 14 bits, actual arg is 13 bits</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dslx_type_system-3-default-expressions">3: Default Expressions</h3>
<p>In this example:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="o">+</span><span class="n">A</span><span class="p">}</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">B</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">bits</span><span class="p">[</span><span class="n">B</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="p">(</span><span class="kt">u16</span><span class="p">:</span><span class="mi">42</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="p">:</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>main</code> is implicitly saying what <code>A</code> must be by passing a <code>u16</code>; however, <code>B</code> is
not specified; neither by an explicit parametric value (i.e. in <code>&lt;&gt;</code> in the
caller), nor implicitly by an actual arg that was passed. As a result, we go
evaluate the <em>default expression</em> for the parametric, and populate <code>B</code> with the
result of the expression <code>A+A</code>. Since <code>A</code> is <code>16</code>, <code>B</code> is <code>32</code>.</p>
<h3 id="dslx_type_system-aside-earlier-bindings-in-later-types">Aside: Earlier Bindings in Later Types</h3>
<p>Note: this is not generally necessary to know to use parametrics effectively,
but is useful in thinking through the design and power of parametric
instantiation.</p>
<p>One consequence of the ordering defined is that earlier parametric bindings can
be used to define the types of later parametric bindings; e.g.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">p</span><span class="o">&lt;</span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">bits</span><span class="p">[</span><span class="n">A</span><span class="p">]:</span><span class="mi">0</span><span class="p">}</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">bits</span><span class="p">[</span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">B</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">:</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">}</span>

<span class="cp">#[test]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="p">(</span><span class="n">main</span><span class="p">(),</span><span class="w"> </span><span class="kt">u8</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that <code>main</code> uses an explicit parametric to define <code>A</code> as <code>8</code>. Then the
<em>type</em> of <code>B</code> is defined based on the <em>value</em> of <code>A</code>; i.e. the type of B is
defined to be <code>u8</code> as a result, and the value of <code>B</code> is defined to be a <code>u8:0</code>.
This is interesting because we used an earlier parametric binding to define a
later parametric binding's type.</p></section><h1 class='nav-section-title-end'>Ended: DSLX</h1>
                        <h1 class='nav-section-title' id='section-code-generation'>
                            Code Generation <a class='headerlink' href='#section-code-generation' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="codegen_options"><h1 id="codegen_options-codegen-options">Codegen Options</h1>
<p>This document outlines some useful knobs for running codegen on an XLS design.
Codegen is the process of generating RTL from IR and is where operations are
scheduled and mapped into RTL constructs. The output of codegen is suitable for
simulation or implementation via standard tools that understand Verilog or
SystemVerilog.</p>
<div class="toc">
<ul>
<li><a href="#codegen_options-codegen-options">Codegen Options</a></li>
<li><a href="#codegen_options-input-specification">Input specification</a></li>
<li><a href="#codegen_options-output-locations">Output locations</a></li>
<li><a href="#codegen_options-pipelining-and-scheduling-options">Pipelining and Scheduling Options</a></li>
<li><a href="#codegen_options-feedback-driven-optimization-fdo-options">Feedback-driven Optimization (FDO) Options</a></li>
<li><a href="#codegen_options-naming">Naming</a></li>
<li><a href="#codegen_options-reset-signal-configuration">Reset Signal Configuration</a></li>
<li><a href="#codegen_options-codegen-mapping">Codegen Mapping</a><ul>
<li><a href="#codegen_options-format-strings">Format Strings</a></li>
</ul>
</li>
<li><a href="#codegen_options-io-behavior">I/O Behavior</a></li>
<li><a href="#codegen_options-rams-experimental">RAMs (experimental)</a></li>
<li><a href="#codegen_options-optimization">Optimization</a></li>
</ul>
</div>
<h1 id="codegen_options-input-specification">Input specification</h1>
<ul>
<li><code>&lt;input.ir&gt;</code> is a positional argument giving the path to the ir file.</li>
<li><code>--top</code> specifies the top function or proc to codegen.</li>
<li><code>--codegen_options_proto=...</code> specifies the filename of a protobuf
    containing the arguments to supply codegen other than the scheduling
    arguments. Details can be found in codegen_flags.cc</li>
<li><code>--scheduling_options_proto=...</code> specifies the filename of a protobuf
    containing the scheduling arguments. Details can be found in
    scheduling_options_flags.cc</li>
</ul>
<h1 id="codegen_options-output-locations">Output locations</h1>
<p>The following flags control where output files are put. In addition to Verilog,
codegen can generate files useful for understanding or integrating the RTL.</p>
<ul>
<li><code>--output_verilog_path</code> is the path to the output Verilog file.</li>
<li><code>--output_schedule_path</code> is the path to a textproto that shows into which
    pipeline stage the scheduler put IR ops.</li>
<li><code>--output_schedule_ir_path</code> is the path to the "IR" representation of the
    design, a post-scheduling IR that includes any optimizations or transforms
    during the scheduling pipeline.</li>
<li><code>--output_block_ir_path</code> is the path to the "block IR" representation of the
    design, a post-scheduling IR that is timed and includes registers, ports,
    etc.</li>
<li><code>--output_signature_path</code> is the path to the signature textproto. The
    signature describes the ports, channels, external memories, etc.</li>
<li><code>--output_verilog_line_map_path</code> is the path to the verilog line map
    associating lines of verilog to lines of IR.</li>
<li><code>--codegen_options_used_textproto_file</code> is the path to write a textproto
    containing the actual configuration used for codegen.</li>
</ul>
<h1 id="codegen_options-pipelining-and-scheduling-options">Pipelining and Scheduling Options</h1>
<p>The following flags control how XLS maps IR operations to RTL, and if applicable
control the scheduler.</p>
<ul>
<li><code>--generator=...</code> controls which generator to use. The options are
    <code>pipeline</code> and <code>combinational</code>. The <code>pipeline</code> generator runs a scheduler
    that partitions the IR ops into pipeline stages.</li>
<li><code>--delay_model=...</code> selects the delay model to use when scheduling. See the
    <a href="#delay_estimation">page here</a> for more detail.</li>
<li><code>--clock_period_ps=...</code> sets the target clock period. See
    <a href="#scheduling">scheduling</a> for more details on how scheduling works. Note
    that this option is optional, without specifying clock period XLS will
    estimate what the clock period should be.</li>
<li><code>--pipeline_stages=...</code> sets the number of pipeline stages to use when
    <code>--generator=pipeline</code>.</li>
<li><code>--clock_margin_percent=...</code> sets the percentage to reduce the target clock
    period before scheduling. See <a href="#scheduling">scheduling</a> for more details.</li>
<li><code>--period_relaxation_percent=...</code> sets the percentage that the computed
    minimum clock period is increased. May not be specified with
    <code>--clock_period_ps</code>.</li>
<li><code>--minimize_clock_on_error</code> is enabled by default. If enabled, when
    <code>--clock_period_ps</code> is given with an infeasible clock (in the sense that XLS
    cannot pipeline this input for this clock, even with other constraints
    relaxed), XLS will find and report the minimum feasible clock period if one
    exists. If disabled, XLS will report only that the clock period was
    infeasible, potentially saving time.</li>
<li><code>--recover_after_minimizing_clock</code> is disabled by default. If both this and
    <code>--minimize_clock_on_error</code> are enabled, when <code>--clock_period_ps</code> is given
    with an infeasible clock, XLS will print a warning, find and report the
    minimum feasible clock period (if one exists), and then continue generating
    Verilog as if this had been the specified clock period.</li>
<li><code>--minimize_worst_case_throughput</code> is disabled by default. If enabled, when
    <code>--worst_case_throughput</code> is not specified (or disabled by setting it to 0
    or a negative value), XLS will find &amp; report the best possible worst-case
    throughput of the circuit (subject to all other constraints), and then
    proceed with codegen using that worst-case throughput.<p>NOTE: If <code>--clock_period_ps</code> is not set, XLS will first optimize for clock
  speed, and then find the best possible worst-case throughput within that
  constraint.</p>
</li>
</ul>
<ul>
<li><code>--worst_case_throughput=...</code> sets the worst-case throughput bound to use
    when <code>--generator=pipeline</code>. If set, allows scheduling a pipeline with
    worst-case throughput no slower than once per N cycles (assuming no stalling
    <code>recv</code>s). If not set, defaults to 1.<p>NOTE: If set to 0 or a negative value, no throughput minimum will be
  enforced.</p>
</li>
</ul>
<ul>
<li><code>--additional_input_delay_ps=...</code> adds additional input delay to the inputs.
    This can be helpful to meet timing when integrating XLS designs with other
    RTL.</li>
</ul>
<ul>
<li><code>--ffi_fallback_delay_ps=...</code> Delay of foreign function calls if not
    otherwise specified. If there is no measurement or configuration for the
    delay of an invoked modules, this is the value used in the scheduler.</li>
</ul>
<ul>
<li><code>--io_constraints=...</code> adds constraints to the scheduler. The flag takes a
    comma-separated list of constraints of the form <code>foo:send:bar:recv:3:5</code>
    which means that sends on channel <code>foo</code> must occur between 3 and 5 cycles
    (inclusive) before receives on channel <code>bar</code>. Note that for a constraint
    like <code>foo:send:foo:send:3:5</code>, no constraint will be applied between a node
    and itself; i.e.: this means all <em>different</em> pairs of nodes sending on <code>foo</code>
    must be in cycles that differ by between 3 and 5. If the special
    minimum/maximum value <code>none</code> is used, then the minimum latency will be the
    lowest representable <code>int64_t</code>, and likewise for maximum latency. For an
    example of the use of this, see
    <a href="https://github.com/google/xls/tree/main/xls/examples/constraint.x">this example</a> and
    the associated BUILD rule.</li>
</ul>
<ul>
<li><code>explain_infeasibility</code> configures what to do if scheduling fails. If set,
    the scheduling problem is reformulated with extra slack variables in an
    attempt to explain why scheduling failed.</li>
</ul>
<ul>
<li><code>infeasible_per_state_backedge_slack_pool</code> If specified, the specified value
    must be &gt; 0. Setting this configures how the scheduling problem is
    reformulated in the case that scheduling fails. If specified, this value
    will cause the reformulated problem to include per-state backedge slack
    variables, which increases the complexity. This value scales the objective
    such that adding slack to the per-state backedge is preferred up until total
    slack reaches the pool size, after which adding slack to the shared backedge
    slack variable is preferred. Increasing this value should give more specific
    information about how much slack each failing backedge needs at the cost of
    less actionable and harder to understand output.</li>
</ul>
<ul>
<li><code>--scheduling_options_used_textproto_file</code> is the path to write a textproto
    containing the actual configuration used for scheduling.</li>
</ul>
<h1 id="codegen_options-feedback-driven-optimization-fdo-options">Feedback-driven Optimization (FDO) Options</h1>
<p>The following flags control the feedback-driven optimizations in XLS. For now,
an iterative SDC scheduling method is implemented, which can take low-level
feedbacks (typically from downstream tools, e.g., OpenROAD) to guide the delay
estimation refinements in XLS. For now, FDO is disabled by default
(<code>--use_fdo=false</code>).</p>
<ul>
<li><code>--use_fdo=true/false</code> Enable FDO. If false, then the <code>--fdo_*</code> options are
    ignored.</li>
<li><code>--fdo_iteration_number=...</code> The number of FDO iterations during the
    pipeline scheduling. Must be an integer &gt;= 2.</li>
<li><code>--fdo_delay_driven_path_number=...</code> The number of delay-driven subgraphs in
    each FDO iteration. Must be a non-negative integer.</li>
<li><code>--fdo_fanout_driven_path_number=...</code> The number of fanout-driven subgraphs
    in each FDO iteration. Must be a non-negative integer.</li>
<li><code>--fdo_refinement_stochastic_ratio=...</code> *path_number over
    refinement_stochastic_ratio paths are extracted and *path_number paths are
    randomly selected from them for synthesis in each FDO iteration. Must be a
    positive float &lt;= 1.0.</li>
<li><code>--fdo_path_evaluate_strategy=...</code> Path evaluation strategy for FDO.
    Supports path, cone, and window.</li>
<li><code>--fdo_synthesizer_name=...</code> Name of synthesis backend for FDO. Only
    supports yosys.</li>
<li><code>--fdo_yosys_path=...</code> Absolute path of yosys.</li>
<li><code>--fdo_sta_path=...</code> Absolute path of OpenSTA.</li>
<li><code>--fdo_synthesis_libraries=...</code> Synthesis and STA libraries.</li>
<li><code>--fdo_default_driver_cell=...</code> Cell to assume is driving primary inputs.</li>
<li><code>--fdo_default_load=...</code> Cell to assume is being driven by primary outputs.</li>
</ul>
<h1 id="codegen_options-naming">Naming</h1>
<p>Some names can be set at codegen via the following flags:</p>
<ul>
<li><code>--module_name=...</code> sets the name of the generated verilog module.</li>
<li><code>--output_port_name=....</code> sets the name of the output port for functions.</li>
<li>For functions, <code>--input_valid_signal=...</code> and <code>--output_valid_signal=...</code>
    adds and sets the name of valid signals when <code>--generator</code> is set to
    <code>pipeline</code>.</li>
<li><code>--manual_load_enable_signal=...</code> adds and sets the name of an input that
    sets the load-enable signals of each pipeline stage.</li>
<li>For procs, <code>--streaming_channel_data_suffix=...</code>,
    <code>--streaming_channel_valid_suffix=...</code>, and
    <code>--streaming_channel_ready_suffix=...</code> set suffixes to be used on their
    respective signals in ready/valid channels. For example,
    <code>--streaming_channel_valid_suffix=_vld</code> for a channel named <code>ABC</code> would
    result in a valid port called <code>ABC_vld</code>.</li>
</ul>
<h1 id="codegen_options-reset-signal-configuration">Reset Signal Configuration</h1>
<ul>
<li><code>--reset=...</code> sets the name of the reset signal. If not specified, no reset
    signal is used.</li>
<li><code>--reset_active_low</code> sets if the reset is active low or high. Active high by
    default.</li>
<li><code>--reset_asynchronous</code> sets if the reset is synchronous or asynchronous
    (synchronous by default).</li>
<li><code>--reset_data_path</code> sets if the datapath should also be reset. True by
    default.</li>
</ul>
<h1 id="codegen_options-codegen-mapping">Codegen Mapping</h1>
<ul>
<li><code>--use_system_verilog</code> sets if the output should use SystemVerilog
    constructs such as SystemVerilog array assignments, <code>@always_comb</code>,
    <code>@always_ff</code>, asserts, covers, etc. True by default.</li>
<li><code>--separate_lines</code> causes every subexpression to be emitted on a separate
    line. False by default.</li>
<li><code>--multi_proc</code> causes every proc to be codegen'd.</li>
<li><code>max_trace_verbosity</code> is the maximum verbosity allowed for traces. Traces
    with higher verbosity are stripped from codegen output. 0 by default.</li>
</ul>
<h2 id="codegen_options-format-strings">Format Strings</h2>
<p>For some XLS ops, flags can override their default codegen behavior via format
string. These format strings use placeholders to fill in relevant information.</p>
<ul>
<li><code>--gate_format=...</code> sets the format string for <code>gate!</code> ops. Supported
    placeholders are:<p>-   <code>{condition}</code>: Identifier (or expression) of the gate.
  -   <code>{input}</code>: Identifier (or expression) for the data input of the gate.
  -   <code>{output}</code>: Identifier for the output of the gate.
  -   <code>{width}</code>: The bit width of the gate operation.</p>
<p>For example, consider a format string which instantiates a particular custom
  AND gate for gating:</p>
<div class="highlight"><pre><span></span><code>my_and gated_{output} [{width}-1:0] (.Z({output}), .A({condition}), .B({input}))
</code></pre></div>
<p>And the IR gate operation is:</p>
<p><code>the_result: bits[32] = gate(the_cond, the_data)</code></p>
<p>This results in the following emitted Verilog:</p>
<p><code>my_and gated_the_result [32-1:0] (.Z(the_result), .A(the cond),
  .B(the_data));</code></p>
<p>To ensure valid Verilog, the instantiated template must declare a value
  named <code>{output}</code> (e.g. <code>the_result</code> in the example).</p>
</li>
</ul>
<ul>
<li><code>--assert_format=...</code> sets the format string for assert statements.
    Supported placeholders are:<p>-   <code>{message}</code>: Message of the assert operation.
  -   <code>{condition}</code>: Condition of the assert.
  -   <code>{label}</code>: Label of the assert operation. It is an error not to use the
      <code>label</code> placeholder.
  -   <code>{clk}</code>: Name of the clock signal. It is an error not to use the <code>clk</code>
      placeholder.
  -   <code>{rst}</code>: Name of the reset signal. It is an error not to use the <code>rst</code>
      placeholder.</p>
<p>For example, the format string:</p>
<p><code>{label}: `MY_ASSERT({condition}, "{message}")</code></p>
<p>could result in the following emitted Verilog:</p>
<p><code>my_label: `MY_ASSERT(foo &lt; 8'h42, "Oh noes!");</code></p>
</li>
</ul>
<ul>
<li><code>--smulp_format=...</code> and <code>--umulp_format=...</code> set the format strings for
    <code>smulp</code> and <code>umulp</code> ops respectively. These ops perform partial (or split)
    multiplies. Supported placeholders are:<p>-   <code>{input0}</code> and <code>{input1}</code>: The two inputs.
  -   <code>{input0_width}</code> and <code>{input1_width}</code>: The width of the two inputs
  -   <code>{output}</code>: Name of the output. Partial multiply IP generally produces
      two outputs with the property that the sum of the two outputs is the
      product of the inputs. <code>{output}</code> should be the concatenation of these
      two outputs.
  -   <code>{output_width}</code>: Width of the output.</p>
<p>For example, the format string:</p>
<div class="highlight"><pre><span></span><code>multp #(
    .x_width({input0_width}),
    .y_width({input1_width}),
    .z_width({output_width}&gt;&gt;1)
  ) {output}_inst (
    .x({input0}),
    .y({input1}),
    .z0({output}[({output_width}&gt;&gt;1)-1:0]),
    .z1({output}[({output_width}&gt;&gt;1)*2-1:({output_width}&gt;&gt;1)})])
  );
</code></pre></div>
<p>could result in the following emitted Verilog:</p>
<div class="highlight"><pre><span></span><code>multp #(
  .x_width(16),
  .y_width(16),
  .z_width(32&gt;&gt;1)
) multp_out_inst (
  .x(lhs),
  .y(rhs),
  .z0(multp_out[(32&gt;&gt;1)-1:0]),
  .z1(multp_out[(32&gt;&gt;1)*2-1:(32&gt;&gt;1)])
);
</code></pre></div>
<p>Note the arithmetic performed on <code>output_width</code> to make the two-output
  <code>multp</code> block fill the concatenated output expected by XLS.</p>
</li>
</ul>
<h1 id="codegen_options-io-behavior">I/O Behavior</h1>
<ul>
<li><code>--flop_inputs</code> and <code>--flop_outputs</code> control if inputs and outputs should be
    flopped respectively. These flags are only used by the pipeline generator.<p>For procs, inputs and outputs are channels with ready/valid signalling and
  have additional options controlling how inputs and outputs are registered.
  <code>--flop_inputs_kind=...</code> and <code>--flop_outputs_kind=...</code> flags control what
  the logic around the outputs and inputs look like respectively. The list
  below enumerates the possible kinds of output flopping and shows what logic
  is generated in each case.</p>
<p>-   <code>flop</code>: Adds a pipeline stage at the beginning or end of the block to
      hold inputs or outputs. This is essentially a single-element FIFO.</p>
</li>
</ul>
<p><img alt="Flop Outputs" src="../flop_outputs.svg" /></p>
<div class="highlight"><pre><span></span><code>-   `skid`: Adds a skid buffer at the inputs or outputs of the block. The
    skid buffer can hold 2 entries.
</code></pre></div>
<p><img alt="Skid Buffer" src="../skid_buffer.svg" /></p>
<div class="highlight"><pre><span></span><code>-   `zerolatency`: Adds a zero-latency buffer at the beginning or end of the
    block. This is essentially a single-element FIFO with bypass.
</code></pre></div>
<p><img alt="Zero Latency Buffer" src="../zero_latency_buffer.svg" /></p>
<ul>
<li><code>--flop_single_value_channels</code> controls if single-value channels should be
    flopped.</li>
</ul>
<ul>
<li><code>--add_idle_output</code> adds an additional output port named <code>idle</code>. <code>idle</code> is
    the NOR of:<p>1.  Pipeline registers storing the valid bit for each pipeline stage.</p>
<p>2.  All valid registers stored for the input/output buffers.</p>
<p>3.  All valid signals for the input channels.</p>
</li>
</ul>
<ul>
<li>For functions, when <code>--generator</code> is set to <code>pipeline</code>, optional 'valid'
    logic can be added by using <code>--input_valid_signal=...</code> and
    <code>--output_valid_signal=...</code>, which also set the names for the valid I/O
    signals. This logic has no 'ready' signal and thus provides no backpressure.
    See also <a href="#codegen_options-naming">Naming</a>.</li>
</ul>
<ul>
<li>See also <a href="#codegen_options-reset-signal-configuration">Reset Signal Configuration</a>.</li>
</ul>
<h1 id="codegen_options-rams-experimental">RAMs (experimental)</h1>
<p>XLS has experimental support for using proc channels to drive an external RAM.
For an example usage, see
<a href="https://github.com/google/xls/tree/main/xls/examples/delay.x">this delay</a> implemented
with a single-port RAM
(<a href="https://github.com/google/xls/tree/main/xls/examples/ram.x">modeled here</a>). Note that
receives on the response channel must be conditioned on performing a read,
otherwise there will be deadlock.</p>
<p>The codegen option <code>--ram_configurations</code> takes a comma-separated list of
configurations in the format <code>ram_name:ram_kind[:kind-specific-configuration]</code>.
For a <code>1RW</code> RAM, the format is
<code>ram_name:1RW:req_channel_name:resp_channel_name[:latency]</code>, where latency is 1
if unspecified. For a <code>1RW</code> RAM, there are several requirements these channels
must satisfy:</p>
<ul>
<li>The request channel must be a tuple type with 4 entries corresponding to
    <code>(addr, wr_data, we, re)</code>. All entries must have type <code>bits</code>, and <code>we</code> and
    <code>re</code> must be a single bit.</li>
<li>The response channel must be a tuple type with a single entry corresponding
    to <code>(rd_data)</code>. <code>rd_data</code> must have the same width as <code>wr_data</code>.</li>
</ul>
<p>Instead of the normal channel ports, the codegen option will produce the
following ports:</p>
<ul>
<li><code>{ram_name}_addr</code></li>
<li><code>{ram_name}_wr_data</code></li>
<li><code>{ram_name}_we</code></li>
<li><code>{ram_name}_re</code></li>
<li><code>{ram_name}_rd_data</code></li>
</ul>
<p>Note that there are no ready/valid signals as RAMs have fixed latency. There is
an internal buffer to catch the response and apply backpressure on requests if
needed.</p>
<p>When using <code>--ram_configurations</code>, you should generally add a scheduling
constraint via <code>--io_constraints</code> to ensure the request-send and
response-receive are scheduled to match the RAM's latency.</p>
<h1 id="codegen_options-optimization">Optimization</h1>
<ul>
<li><code>--gate_recvs</code> emits logic to gate the data value of a receive operation in
    Verilog. In the XLS IR, the receive operation has the semantics that the
    data value is zero when the predicate is <code>false</code>. Moreover, for a
    non-blocking receive, the data value is zero when the data is invalid. When
    set to true, the data is gated and has the previously described semantics.
    However, the latter does utilize more resource/area. Setting this value to
    false may reduce the resource/area utilization, but may also result in
    mismatches between IR-level evaluation and Verilog simulation.</li>
</ul>
<ul>
<li><code>--array_index_bounds_checking</code>: With this option set, an out of bounds
    array access returns the maximal index element in the array. If this option
    is not set, the result relies on the semantics of out-of-bounds array access
    in Verilog which is not well-defined. Setting this option to <code>true</code> may
    result in more resource/area. Setting this value to <code>false</code> may reduce the
    resource/area utilization, but may also result in mismatches between
    IR-level evaluation and Verilog simulation.</li>
</ul>
<ul>
<li><code>--mutual_exclusion_z3_rlimit</code> controls how hard the mutual exclusion pass
    will work to attempt to prove that sends and receives are mutually
    exclusive. Concretely, this roughly limits the number of <code>malloc</code> calls done
    by the Z3 solver, so the output should be deterministic across machines for
    a given rlimit.</li>
</ul>
<ul>
<li><code>--default_next_value_z3_rlimit</code> controls how hard our scheduling passes
    will work to prove that state params are fully covered by their <code>next_value</code>
    nodes, so that we can skip special handling for the case where no
    <code>next_value</code> node triggers. This is purely an optimization; everything will
    work correctly even if this is disabled (omitted, or set to -1). Concretely,
    this roughly limits the number of <code>malloc</code> calls done by the Z3 solver, so
    the output should be deterministic across machines for a given rlimit.</li>
</ul>
<ul>
<li><code>--register_merge_strategy</code> controls how we merge registers between stages
    which may be shared. The options are <code>identity</code> which merges registers which
    can be shared and contain exactly the same value and <code>none</code> which disables
    register merging. Registers are eligible for merging if the stages they are
    read in are not simultaneously activatable and the registers are the same
    type.</li>
</ul></section><section class="print-page" id="ir_lowering"><h1 id="ir_lowering-xls-ir-lowering">XLS: IR Lowering</h1>
<div class="toc">
<ul>
<li><a href="#ir_lowering-xls-ir-lowering">XLS: IR Lowering</a><ul>
<li><a href="#ir_lowering-flattening">Flattening</a><ul>
<li><a href="#ir_lowering-arrays">Arrays</a></li>
<li><a href="#ir_lowering-tuples">Tuples</a></li>
<li><a href="#ir_lowering-structs">Structs</a></li>
</ul>
</li>
<li><a href="#ir_lowering-unrepresented-ops">Unrepresented Ops</a></li>
</ul>
</li>
</ul>
</div>
<p>As part of codegen, IR constructs are lowered to Verilog/SystemVerilog
constructs. In some cases, this lowering is simple and direct, but some IR
constructs don't map directly to Verilog constructs.</p>
<h2 id="ir_lowering-flattening">Flattening</h2>
<p>Some XLS types are flattened into simpler types when IR gets lowered to RTL.
This flattening is performed
<a href="https://github.com/google/xls/tree/main/xls/codegen/flattening.cc">here</a> (also see
<a href="https://github.com/google/xls/tree/main/xls/codegen/flattening.h">the more-commented header file</a>).
The following summarizes how types are flattened.</p>
<h3 id="ir_lowering-arrays">Arrays</h3>
<p>Arrays are flattened such that the last element occupies the most significant
bits. Elements are concatenated via the SystemVerilog concatenation operation.
This matches the flattening of SystemVerilog packed arrays (e.g. <code>logic [N:0]
foo</code>) to unpacked arrays declared like <code>logic bar[N:0]</code>. For example, a
4-element array of 4-bit UInts would be flattened as</p>
<div class="highlight"><pre><span></span><code>[0x3, 0x4, 0x5, 0x6] =&gt; 0x6543
</code></pre></div>
<h3 id="ir_lowering-tuples">Tuples</h3>
<p>Tuples are flattened by concatenating each leaf element of the tuple. If an
element of a tuple is an array, this is equivalent to first flattening the array
and treating the flattened array as a leaf element. Concatenation is performed
via the SystemVerilog concatenation operation. The zero-th tuple element will
end up occupying the most significant bits in the flattened output. For example,
a 4-tuple of 4-bit UInts would be flattened as</p>
<div class="highlight"><pre><span></span><code>(0x3, 0x4, 0x5, 0x6) =&gt; 0x3456
</code></pre></div>
<p>and a 2-tuple of length 2 arrays of 4-bit UInts would be flattened as</p>
<div class="highlight"><pre><span></span><code>([0x3, 0x4], [0x5, 0x6]) =&gt; 0x4365
</code></pre></div>
<h3 id="ir_lowering-structs">Structs</h3>
<p>DSLX structs are lowered to tuples in the IR, so there's no separate handling of
structs.</p>
<h2 id="ir_lowering-unrepresented-ops">Unrepresented Ops</h2>
<p>Tokens are not represented in RTL.</p>
<p>Entities with zero width are unrepresented in RTL. Where a zero-width value is
used, a zero-valued literal can be substituted.</p>
<p>Asserts and covers are only represented when producing SystemVerilog, and are
unrepresented when producing Verilog.</p></section><section class="print-page" id="vast"><h1 id="vast-verilog-abstract-syntax-tree-vast">Verilog Abstract Syntax Tree (VAST)</h1>
<p>XLS outputs Verilog (or SystemVerilog) for synthesis and simulation. As a lowest
common denominator, Verilog output enables XLS generated designs to integrate
into existing design flows. To make generation of Verilog easier, XLS includes
an abstract representation of Verilog called VAST (Verilog Abstract Syntax
Tree). VAST is a C++ library which represents Verilog in a recursive tree data
structure which is simple to construct and manipulate programmatically. Verilog
source code is emitted directly from the VAST data structure.</p>
<p>VAST is intentionally not a complete representation of the Verilog language.
VAST is used to emit Verilog for the purposes of code generation within XLS.
Given this limited use case, VAST is much smaller and simpler than a complete
representation of the entire Verilog language as might be required for a parser,
for example.</p>
<h2 id="vast-vast-overview">VAST Overview</h2>
<p>Each supported Verilog construct is represented with a C++ class. These classes
form a type hierarchy with the class <code>VastNode</code> at the root. Objects are
gathered in tree-shaped structures to represent Verilog constructs. Ownership of
all VAST objects is maintained by a <code>VerilogFile</code> object which represents a
single file of Verilog source code. References between objects are stored as
plain pointers.</p>
<p>For example, consider the following Verilog expression:</p>
<div class="highlight"><pre><span></span><code>  foo + 8
</code></pre></div>
<p>In VAST, this is represented with an object of the <code>BinaryInfix</code> class which is
derived from the <code>Expression</code> class representing arbitrary Verilog expressions.
A <code>BinaryInfix</code> object has three relevant data members:</p>
<p><code>std::string op_;</code>
:   The string representation of the operation to perform (e.g., <code>+</code>).</p>
<p><code>Expression* lhs_;</code>
:   The left-hand-side of the expression. In this example, this points to a
    <code>LogicRef</code> object (derived from <code>Expression</code> class) referring to a Verilog
    <code>reg</code> or <code>wire</code> variable.</p>
<p><code>Expression* rhs_;</code>
:   The left-hand-side of the expression. In this example, this points to a
    <code>Literal</code> object (derived from <code>Expression</code> class) containing the number 8
    with unspecified bit width.</p>
<p>The <code>BinaryInfix</code> object representing <code>foo + 8</code> might be used within other
expressions or statements by referring to the object by pointer. For example,
the representation of the statement <code>assign bar = foo + 8</code> would contain an
<code>Expression*</code> pointer referring to the <code>foo + 8</code> object for the right-hand-side
of the assignment.</p>
<h3 id="vast-operator-precedence">Operator Precedence</h3>
<p>To avoid ambiguity, operators in Verilog follow precedence rules. For example,
multiplication is higher precedence than addition so the expression <code>2 + 4 *
10</code> evaluates to <code>42</code> (i.e., <code>2 + (4 * 10)</code>) not <code>60</code> (i.e., <code>(2 + 4) * 10</code>). In
VAST, expressions are built as a trees which is evaluated from the leaves to the
root. To ensure that the operations are evaluated in the correct order when
emitted as Verilog text, VAST automatically adds parentheses where appropriate.
For example, the VAST expression consisting of the product (<code>BinaryInfix</code> with
operation <code>*</code>) of <code>10</code> and the sum of <code>2</code> and <code>4</code> (<code>BinaryInfix</code> with operation
<code>+</code>) will be emitted as <code>10 * (2 + 4)</code>.</p>
<h3 id="vast-containers">Containers</h3>
<p>VAST has a number of classes which hold a sequence of (pointers to) other VAST
objects. At the top-level, this includes the <code>VerilogFile</code> class which can hold
a sequence of objects such as include statements and modules. Verilog modules
themselves are represented with the <code>Module</code> class containing a sequence of
statements, declarations, comments, and other constructs. Other containers
include always blocks and functions.</p>
<h3 id="vast-emitting-verilog-text">Emitting Verilog text</h3>
<p>VAST classes include an <code>Emit</code> method which returns the represented Verilog
construct as a string. Typically, <code>Emit</code> is called on the top-level
<code>VerilogFile</code> object to create the text of the entire Verilog source file.
Underneath the hood, this method calls the <code>Emit</code> method on all contained VAST
objects and assembles the returned strings into the Verilog source code.</p>
<h3 id="vast-systemverilog-support">SystemVerilog support</h3>
<p>XLS can emit either Verilog or SystemVerilog so VAST supports both languages.
SystemVerilog constructs are included alongside Verilog constructs in VAST.
Examples of SystemVerilog features supported by VAST include:</p>
<ul>
<li><code>always_ff</code> procedure for modeling sequential logic (VAST <code>AlwaysFlop</code>
    class).</li>
</ul>
<ul>
<li>Array assignment pattern (VAST <code>ArrayAssignmentPattern</code> class). Example:
    <code>'{foo, bar, baz}</code></li>
</ul>
<ul>
<li>Array declaration using sizes. Example: <code>reg [7:0] foo[42];</code></li>
</ul>
<p>Within VAST, there is no distinction between the two languages and it is up to
the user of VAST to only use the supported features for the target language
(Verilog or SystemVerilog).</p></section><h1 class='nav-section-title-end'>Ended: Code Generation</h1>
                        <h1 class='nav-section-title' id='section-tools'>
                            Tools <a class='headerlink' href='#section-tools' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="build_system"><h1 id="build_system-build-system">Build system</h1>
<p>XLS uses the <a href="http://bazel.build">Bazel</a> build system for itself and all its
dependencies. Bazel is an easy to configure and use, and has powerful extension
facilities. (It's also
<a href="https://bazel.build/start/bazel-intro">well-documented</a>!) XLS provides a number
of <a href="https://bazel.build/rules/language">Starlark</a>
<a href="https://bazel.build/rules/rules">rules</a> and
<a href="https://bazel.build/rules/macros">macros</a> to define a build flow.</p>
<div class="toc">
<ul>
<li><a href="#build_system-build-system">Build system</a><ul>
<li><a href="#build_system-whirlwind-intro-to-bazel">Whirlwind Intro To Bazel</a><ul>
<li><a href="#build_system-where-the-output-files-go">Where the output files go</a></li>
</ul>
</li>
<li><a href="#build_system-xls-project-build-rules">XLS Project Build Rules</a></li>
<li><a href="#build_system-bazel-queries">Bazel queries</a><ul>
<li><a href="#build_system-finding-transitive-dependencies">Finding transitive dependencies</a></li>
<li><a href="#build_system-finding-dependees-reverse-dependencies">Finding dependees ("reverse dependencies")</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="build_system-whirlwind-intro-to-bazel">Whirlwind Intro To Bazel</h2>
<p>Many developers are familiar with a make-style build flow. Bazel, by contrast,
provides more built-in structure for where generated files and binary artifacts
are placed, in order to keep the source tree unmodified and the build process
fully declarative / repeatable. In Bazel, one of the key principles is "the user
should not need to <code>bazel clean</code>".</p>
<p>A typical build command looks like:</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt //xls/tools:opt_main
</code></pre></div>
<p>The <code>-c opt</code> flag is requesting we produce an optimized build. Other options for
development are:</p>
<ul>
<li><code>-c fastbuild</code>: fewer optimizations, quicker turn around time on builds, and</li>
<li><code>-c dbg</code>: debug binaries, minimal optimization level and debug information
    produced, e.g. for using binaries under <code>gdb</code></li>
</ul>
<p>Targets are referenced with <code>//</code> as the root of the current repository -- it is
generally optional. From there you specify the path to a directory with a
<code>BUILD</code> file, and then <code>:target_name</code> to reference a named target within that
<code>BUILD</code> file. In the case above, the build target referenced is a C++ binary --
its build definition is described by a <code>cc_binary</code> rule in the <code>xls/tools/BUILD</code>
file.</p>
<h3 id="build_system-where-the-output-files-go">Where the output files go</h3>
<p>The above command notes the following in its output:</p>
<div class="highlight"><pre><span></span><code>Target //xls/tools:opt_main up-to-date:
  bazel-bin/xls/tools/opt_main
</code></pre></div>
<p>We can see binary result files go to <code>bazel-bin</code> within our repository's root
directory. (Aside: <code>bazel-bin</code> is a convenient symlink to an out-of-tree
location where build artifacts are placed.)</p>
<p><strong>Generated</strong> files that are intermediate entities in the build process are also
visible via a similar symlink, <code>bazel-out</code>. Within the following directory:</p>
<div class="highlight"><pre><span></span><code>$ ls bazel-out/host/bin/xls/ir/
</code></pre></div>
<p>We can see files that were part of the build of the IR library, like <code>op.h</code> and
<code>op.cc</code>.</p>
<h2 id="build_system-xls-project-build-rules">XLS Project Build Rules</h2>
<p>XLS provides a set of Bazel build rules and macros that allow users to
quickly/easily create XLS-based design artifacts -- analogous to the way C++,
Python, etc are done in Bazel. For example, <code>dslx_library</code> lets a user make a
library target written in XLS' Domain Specific Language frontend.</p>
<p>XLS build rules and macros are defined in
<a href="https://github.com/google/xls/tree/main/xls/build_rules/xls_build_defs.bzl">xls/build_rules/xls_build_defs.bzl</a>.</p>
<p>Examples using the rules and macros are found at
<a href="https://github.com/google/xls/tree/main/xls/build_rules/tests/BUILD">xls/build_rules/tests/BUILD</a>.</p>
<p>A detailed description of the bazel rules/macros can be found
<a href="#bazel_rules_macros">here</a>.</p>
<h2 id="build_system-bazel-queries">Bazel queries</h2>
<p>Understanding the build tree for a new project can be difficult, but fortunately
Bazel provides a
<a href="https://bazel.build/reference/query">powerful query mechanism</a>. <code>bazel query</code>
enables a user to examine build targets, dependencies between them, and much
more. A few usage examples are provided here, but the full documentation (linked
above) is comprehensive.</p>
<h3 id="build_system-finding-transitive-dependencies">Finding transitive dependencies</h3>
<p>To understand why, for example, the combinational verilog generator depends on
the ABSL container algorithm library, one could run:</p>
<div class="highlight"><pre><span></span><code>$ bazel query &#39;somepath(//xls/codegen:combinational_generator, @com_google_absl//absl/algorithm:container)&#39;
//xls/codegen:combinational_generator
//xls/codegen:vast
@com_google_absl//absl/algorithm:container
</code></pre></div>
<p>This result shows that one such path goes through the <code>:vast</code> target. Another
such path goes through the xls/ir:ir target, then the xls/ir:value target.
<code>somepath</code> provides <em>some</em> path, not all paths (that's what <code>allpaths</code> is for).</p>
<h3 id="build_system-finding-dependees-reverse-dependencies">Finding dependees ("reverse dependencies")</h3>
<p>Sometimes it's useful to identify the set of targets depending on some other
target - the <code>rdeps</code> query performs this:</p>
<div class="highlight"><pre><span></span><code>$ bazel query &#39;rdeps(//xls/codegen:all, //xls/codegen:combinational_generator)&#39;
//xls/codegen:flattening_test
//xls/ir:ir_test_base
//xls/codegen:combinational_generator_test
//xls/codegen:combinational_generator
</code></pre></div>
<p>This shows the transitive closure of all dependencies of the combinational
generator, with the starting set being all targets in <code>//xls/codegen:all</code>. This
set of dependencies can quickly grow to be unmanageable, so keep the initial set
(the first argument) as small as possible, and consider specifying a third
argument for maximum search depth.</p></section><section class="print-page" id="bazel_rules_macros"><!-- DO NOT EDIT THIS FILE -->
<!-- Generated with Stardoc: http://skydoc.bazel.build -->

<h1 id="bazel_rules_macros-bazel-rules-and-macros">Bazel Rules And Macros</h1>
<!-- DO NOT REMOVE! Placeholder for TOC. -->

<p><a id="check_sha256sum_frozen"></a></p>
<h2 id="bazel_rules_macros-check_sha256sum_frozen">check_sha256sum_frozen</h2>
<pre>
check_sha256sum_frozen(<a href="#bazel_rules_macros-check_sha256sum_frozen-name">name</a>, <a href="#bazel_rules_macros-check_sha256sum_frozen-src">src</a>, <a href="#bazel_rules_macros-check_sha256sum_frozen-frozen_file">frozen_file</a>, <a href="#bazel_rules_macros-check_sha256sum_frozen-sha256sum">sha256sum</a>)
</pre>

<p>Produces a frozen file if the sha256sum checksum of a source file matches a user-defined checksum.</p>
<p>As projects cut releases or freeze, it's important to know that
generated (e.g. Verilog) code is never changing without having to
actually check in the generated artifact. This rule performs a checksum
of a generated file as an integrity check. Users might use this rule to
help enable confidence that there is neither:</p>
<ul>
<li>non-determinism in the toolchain, nor</li>
<li>an accidental dependence on a non-released toolchain (e.g. an
    accidental dependence on top-of-tree, where the toolchain is
    constantly changing)</li>
</ul>
<p>Say there was a codegen rule producing <code>my_output.v</code>, a user might instantiate
something like:</p>
<div class="highlight"><pre><span></span><code>check_sha256sum_frozen(
    name = &quot;my_output_checksum&quot;,
    src = &quot;:my_output.v&quot;,
    sha256sum = &quot;d1bc8d3ba4afc7e109612cb73acbdddac052c93025aa1f82942edabb7deb82a1&quot;,
    frozen_file = &quot;my_output.frozen.x&quot;,
)
</code></pre></div>
<p>... and then take a dependency on <code>my_output.frozen.v</code> in the
surrounding project, knowing that it had been checksum-verified.</p>
<p>Taking a dependence on <code>my_output.v</code> directly may also be ok if the
<code>:my_output_checksum</code> target is also built (e.g. via the same wildcard
build request), but taking a dependence on the output <code>.frozen.v</code> file
ensures that the checking is an integral part of the downstream
build-artifact-creation process.</p>
<p>At its core, this rule ensure that the contents of a file does not
change by verifying that it matches a given checksum. Typically, this
rule is used to control the build process. The rule serves as a trigger
on rules depending on its output (the frozen file). When the validation
of the sha256sum succeed, rules depending on the frozen file are
built/executed. When the validation of the sha256sum fails, rules
depending on the frozen file are not built/executed.</p>
<p>In the example below, when the validation of the sha256sum for
target 'generated_file_sha256sum_frozen' succeeds, target
'generated_file_dslx' is built. However, when the validation of the
sha256sum for target 'generated_file_sha256sum_frozen' fails, target
'generated_file_dslx' is not built.</p>
<p>Examples:</p>
<ol>
<li>A simple example.<div class="highlight"><pre><span></span><code>check_sha256sum_frozen(
    name = &quot;generated_file_sha256sum_frozen&quot;,
    src = &quot;:generated_file.x&quot;,
    sha256sum = &quot;6522799f7b64dbbb2a31eb2862052b8988e78821d8b61fff7f508237a9d9f01d&quot;,
    frozen_file = &quot;generated_file.frozen.x&quot;,
)

dslx_library(
    name = &quot;generated_file_dslx&quot;,
    src = &quot;:generated_file.frozen.x&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_frozen-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_frozen-src"></a>src</td>
<td style="text-align: left;">The source file.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_frozen-frozen_file"></a>frozen_file</td>
<td style="text-align: left;">The frozen output file.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_frozen-sha256sum"></a>sha256sum</td>
<td style="text-align: left;">The sha256sum of the source file.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p><a id="check_sha256sum_test"></a></p>
<h2 id="bazel_rules_macros-check_sha256sum_test">check_sha256sum_test</h2>
<pre>
check_sha256sum_test(<a href="#bazel_rules_macros-check_sha256sum_test-name">name</a>, <a href="#bazel_rules_macros-check_sha256sum_test-src">src</a>, <a href="#bazel_rules_macros-check_sha256sum_test-sha256sum">sha256sum</a>)
</pre>

<p>Validates the sha256sum checksum of a source file with a user-defined checksum.</p>
<p>This rule is typically used to ensure that the contents of a file is
unchanged.</p>
<p>Examples:</p>
<ol>
<li>A simple example.<div class="highlight"><pre><span></span><code>check_sha256sum_test(
    name = &quot;generated_file_sha256sum_test&quot;,
    src = &quot;:generated_file.x&quot;,
    sha256sum = &quot;6522799f7b64dbbb2a31eb2862052b8988e78821d8b61fff7f508237a9d9f01d&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_test-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_test-src"></a>src</td>
<td style="text-align: left;">The source file.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="check_sha256sum_test-sha256sum"></a>sha256sum</td>
<td style="text-align: left;">The sha256sum of the source file.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p><a id="proto_data"></a></p>
<h2 id="bazel_rules_macros-proto_data">proto_data</h2>
<pre>
proto_data(<a href="#bazel_rules_macros-proto_data-name">name</a>, <a href="#bazel_rules_macros-proto_data-src">src</a>, <a href="#bazel_rules_macros-proto_data-proto_name">proto_name</a>, <a href="#bazel_rules_macros-proto_data-protobin_file">protobin_file</a>)
</pre>

<p>Converts a proto text with a xlscc.HLSBlock message to a proto binary.</p>
<p>This rules is used in conjunction with the (e.g. xls_cc_ir and xls_cc_verilog)
rules and xls_cc_* (e.g. xls_cc_ir_macro and xls_cc_verilog_macro) macros.</p>
<p>Examples:</p>
<ol>
<li>A simple example.<div class="highlight"><pre><span></span><code>proto_data(
    name = &quot;packet_selector_block_pb&quot;,
    src = &quot;packet_selector.textproto&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="proto_data-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="proto_data-src"></a>src</td>
<td style="text-align: left;">The source file.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="proto_data-proto_name"></a>proto_name</td>
<td style="text-align: left;">The name of the message type in the .proto files that 'src' file represents.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>"xlscc.HLSBlock"</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="proto_data-protobin_file"></a>protobin_file</td>
<td style="text-align: left;">The name of the output file to write binary proto to. If not specified, the target name of the bazel rule followed by a .protobin extension is used.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_benchmark_verilog"></a></p>
<h2 id="bazel_rules_macros-xls_benchmark_verilog">xls_benchmark_verilog</h2>
<pre>
xls_benchmark_verilog(<a href="#bazel_rules_macros-xls_benchmark_verilog-name">name</a>, <a href="#bazel_rules_macros-xls_benchmark_verilog-verilog_target">verilog_target</a>)
</pre>

<p>Computes and prints various metrics about a Verilog target.</p>
<p>Example:
    <div class="highlight"><pre><span></span><code>xls_benchmark_verilog(
    name = &quot;a_benchmark&quot;,
    verilog_target = &quot;a_verilog_target&quot;,
)
</code></pre></div></p>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_verilog-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_verilog-verilog_target"></a>verilog_target</td>
<td style="text-align: left;">The verilog target to benchmark.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_delay_model_generation"></a></p>
<h2 id="bazel_rules_macros-xls_delay_model_generation">xls_delay_model_generation</h2>
<pre>
xls_delay_model_generation(<a href="#bazel_rules_macros-xls_delay_model_generation-name">name</a>, <a href="#bazel_rules_macros-xls_delay_model_generation-samples_file">samples_file</a>, <a href="#bazel_rules_macros-xls_delay_model_generation-standard_cells">standard_cells</a>)
</pre>

<p>Builds a script to generate an XLS delay model for one PDK corner.</p>
<p>This rule gathers the locations of the required dependencies
(Yosys, OpenSTA, helper scripts, and cell libraries) and
generates a wrapper script that invokes "run_timing_characterization"
with the dependency locations provided as args.</p>
<p>Any extra runtime args will get passed in to the
"run_timing_characterization" script (e.g. "--debug" or "--quick_run").</p>
<p>The script must be "run" from the root of the workspace
to perform the timing characterization.  The output textproto
will be produced in the current directory (which, as just
stated, must be the root of the workspace).</p>
<p>Currently, only a subset of XLS operators are characterized,
including most arithmetic, logical, and shift operators.
However, many common operators such as "concat", "bit_slice",
and "encode" are missing, and so the delay model that is
currently produced should be considered INCOMPLETE.</p>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_delay_model_generation-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_delay_model_generation-samples_file"></a>samples_file</td>
<td style="text-align: left;">Proto providing sample points.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_delay_model_generation-standard_cells"></a>standard_cells</td>
<td style="text-align: left;">Target for the PDK; will use the target's default corner.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_library"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_library">xls_dslx_library</h2>
<pre>
xls_dslx_library(<a href="#bazel_rules_macros-xls_dslx_library-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_library-deps">deps</a>, <a href="#bazel_rules_macros-xls_dslx_library-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_dslx_library-warnings_as_errors">warnings_as_errors</a>)
</pre>

<p>A build rule that parses and type checks DSLX source files.</p>
<p>Examples:</p>
<ol>
<li>
<p>A collection of DSLX source files.</p>
<div class="highlight"><pre><span></span><code>xls_dslx_library(
    name = &quot;files_123_dslx&quot;,
    srcs = [
        &quot;file_1.x&quot;,
        &quot;file_2.x&quot;,
        &quot;file_3.x&quot;,
    ],
)
</code></pre></div>
</li>
<li>
<p>Dependency on other xls_dslx_library targets.</p>
<div class="highlight"><pre><span></span><code>xls_dslx_library(
    name = &quot;a_dslx&quot;,
    srcs = [&quot;a.x&quot;],
)

# Depends on target a_dslx.
xls_dslx_library(
    name = &quot;b_dslx&quot;,
    srcs = [&quot;b.x&quot;],
    deps = [&quot;:a_dslx&quot;],
)

# Depends on target a_dslx.
xls_dslx_library(
    name = &quot;c_dslx&quot;,
    srcs = [&quot;c.x&quot;],
    deps = [&quot;:a_dslx&quot;],
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_library-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_library-deps"></a>deps</td>
<td style="text-align: left;">Dependency targets for the rule.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">List of labels</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_library-srcs"></a>srcs</td>
<td style="text-align: left;">Source files for the rule. Files must have a '.x' extension.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">List of labels</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_library-warnings_as_errors"></a>warnings_as_errors</td>
<td style="text-align: left;">Whether warnings are errors within this library definition.</td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_opt_ir_test"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_opt_ir_test">xls_dslx_opt_ir_test</h2>
<pre>
xls_dslx_opt_ir_test(<a href="#bazel_rules_macros-xls_dslx_opt_ir_test-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-benchmark_ir_args">benchmark_ir_args</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-dep">dep</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-dslx_test_args">dslx_test_args</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-input_validator">input_validator</a>,
                     <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-input_validator_expr">input_validator_expr</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-ir_equivalence_args">ir_equivalence_args</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-ir_eval_args">ir_eval_args</a>,
                     <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-scheduling_options_proto">scheduling_options_proto</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir_test-top">top</a>)
</pre>

<p>A build rule that tests a xls_dslx_opt_ir target.</p>
<p>Executes the test commands for the following rules in the order presented:</p>
<ol>
<li>xls_dslx_test</li>
<li>xls_ir_equivalence_test</li>
<li>xls_eval_ir_test</li>
<li>xls_benchmark_ir</li>
</ol>
<p>Examples:</p>
<ol>
<li>A simple example.<div class="highlight"><pre><span></span><code>xls_dslx_opt_ir(
    name = &quot;a_opt_ir&quot;,
    srcs = [&quot;a.x&quot;],
    dslx_top = &quot;a&quot;,
)

xls_dslx_opt_ir_test(
    name = &quot;a_opt_ir_test&quot;,
    dep = &quot;:a_opt_ir&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-benchmark_ir_args"></a>benchmark_ir_args</td>
<td style="text-align: left;">Arguments of the benchmark IR tool. For details on the arguments, refer to the benchmark_main application at //xls/tools/benchmark_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-dep"></a>dep</td>
<td style="text-align: left;">The xls_dslx_opt_ir target to test.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-dslx_test_args"></a>dslx_test_args</td>
<td style="text-align: left;">Arguments of the DSLX interpreter executable. For details on the arguments, refer to the interpreter_main application at //xls/dslx/interpreter_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-input_validator"></a>input_validator</td>
<td style="text-align: left;">The DSLX library defining the input validator for this test. Mutually exclusive with "input_validator_expr".</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-input_validator_expr"></a>input_validator_expr</td>
<td style="text-align: left;">The expression to validate an input for the test function. Mutually exclusive with "input_validator".</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-ir_equivalence_args"></a>ir_equivalence_args</td>
<td style="text-align: left;">Arguments of the IR equivalence tool. For details on the arguments, refer to the check_ir_equivalence_main application at //xls/tools/check_ir_equivalence_main.cc. The 'function' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-ir_eval_args"></a>ir_eval_args</td>
<td style="text-align: left;">Arguments of the IR interpreter. For details on the arguments, refer to the eval_ir_main application at //xls/tools/eval_ir_main.cc.The 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{"random_inputs": "100", "optimize_ir": "true"}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-scheduling_options_proto"></a>scheduling_options_proto</td>
<td style="text-align: left;">Protobuf filename of scheduling arguments to the benchmark IR tool. For details on the arguments, refer to the benchmark_main application at //xls/tools/benchmark_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir_test-top"></a>top</td>
<td style="text-align: left;">The (<em>mangled</em>) name of the entry point. See get_mangled_ir_symbol. Defines the 'top' argument of the IR tool/application.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_prove_quickcheck_test"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_prove_quickcheck_test">xls_dslx_prove_quickcheck_test</h2>
<pre>
xls_dslx_prove_quickcheck_test(<a href="#bazel_rules_macros-xls_dslx_prove_quickcheck_test-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_prove_quickcheck_test-deps">deps</a>, <a href="#bazel_rules_macros-xls_dslx_prove_quickcheck_test-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_dslx_prove_quickcheck_test-library">library</a>, <a href="#bazel_rules_macros-xls_dslx_prove_quickcheck_test-test_filter">test_filter</a>)
</pre>

<p>Attempts to prove DSLX quickcheck properties with a SAT solver.</p>
<p>Examples:</p>
<ol>
<li>
<p>xls_dslx_prove_quickcheck_test on DSLX source files.</p>
<div class="highlight"><pre><span></span><code># Assume a xls_dslx_library target bc_dslx is present.
xls_dslx_prove_quickcheck_test(
    name = &quot;e_dslx_quickcheck_test&quot;,
    srcs = [
        &quot;d.x&quot;,
        &quot;e.x&quot;,
    ],
    deps = [&quot;:bc_dslx&quot;],
)
</code></pre></div>
</li>
<li>
<p>xls_dslx_prove_quickcheck_test on a xls_dslx_library.</p>
<div class="highlight"><pre><span></span><code>xls_dslx_library(
    name = &quot;b_dslx&quot;,
    srcs = [&quot;b.x&quot;],
    deps = [&quot;:a_dslx&quot;],
)

xls_dslx_prove_quickcheck_test(
    name = &quot;b_dslx_test&quot;,
    library = &quot;b_dslx&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_prove_quickcheck_test-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_prove_quickcheck_test-deps"></a>deps</td>
<td style="text-align: left;">Dependency targets for the files in the 'srcs' attribute. This attribute is mutually exclusive with the 'library' attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">List of labels</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_prove_quickcheck_test-srcs"></a>srcs</td>
<td style="text-align: left;">Source files for the rule. The files must have a '.x' extension. This attribute is mutually exclusive with the 'library' attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">List of labels</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_prove_quickcheck_test-library"></a>library</td>
<td style="text-align: left;">A DSLX library target where the direct (non-transitive) files of the target are tested. This attribute is mutually exclusive with the 'srcs' and 'deps' attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_prove_quickcheck_test-test_filter"></a>test_filter</td>
<td style="text-align: left;">Regex to select quickcheck tests to run.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_test"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_test">xls_dslx_test</h2>
<pre>
xls_dslx_test(<a href="#bazel_rules_macros-xls_dslx_test-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_test-deps">deps</a>, <a href="#bazel_rules_macros-xls_dslx_test-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_dslx_test-dslx_test_args">dslx_test_args</a>, <a href="#bazel_rules_macros-xls_dslx_test-library">library</a>)
</pre>

<p>A dslx test executes the tests and quick checks of a DSLX source file.</p>
<p>Examples:</p>
<ol>
<li>
<p>xls_dslx_test on DSLX source files.</p>
<div class="highlight"><pre><span></span><code># Assume a xls_dslx_library target bc_dslx is present.
xls_dslx_test(
    name = &quot;e_dslx_test&quot;,
    srcs = [
        &quot;d.x&quot;,
        &quot;e.x&quot;,
    ],
    deps = [&quot;:bc_dslx&quot;],
)
</code></pre></div>
</li>
<li>
<p>xls_dslx_test on a xls_dslx_library.</p>
<div class="highlight"><pre><span></span><code>xls_dslx_library(
    name = &quot;b_dslx&quot;,
    srcs = [&quot;b.x&quot;],
    deps = [&quot;:a_dslx&quot;],
)

xls_dslx_test(
    name = &quot;b_dslx_test&quot;,
    library = &quot;b_dslx&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_test-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_test-deps"></a>deps</td>
<td style="text-align: left;">Dependency targets for the files in the 'srcs' attribute. This attribute is mutually exclusive with the 'library' attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">List of labels</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_test-srcs"></a>srcs</td>
<td style="text-align: left;">Source files for the rule. The files must have a '.x' extension. This attribute is mutually exclusive with the 'library' attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">List of labels</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_test-dslx_test_args"></a>dslx_test_args</td>
<td style="text-align: left;">Arguments of the DSLX interpreter executable. For details on the arguments, refer to the interpreter_main application at //xls/dslx/interpreter_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_test-library"></a>library</td>
<td style="text-align: left;">A DSLX library target where the direct (non-transitive) files of the target are tested. This attribute is mutually exclusive with the 'srcs' and 'deps' attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_eval_ir_test"></a></p>
<h2 id="bazel_rules_macros-xls_eval_ir_test">xls_eval_ir_test</h2>
<pre>
xls_eval_ir_test(<a href="#bazel_rules_macros-xls_eval_ir_test-name">name</a>, <a href="#bazel_rules_macros-xls_eval_ir_test-src">src</a>, <a href="#bazel_rules_macros-xls_eval_ir_test-input_validator">input_validator</a>, <a href="#bazel_rules_macros-xls_eval_ir_test-input_validator_expr">input_validator_expr</a>, <a href="#bazel_rules_macros-xls_eval_ir_test-ir_eval_args">ir_eval_args</a>, <a href="#bazel_rules_macros-xls_eval_ir_test-top">top</a>)
</pre>

<p>Executes the IR interpreter on an IR file.</p>
<p>Examples:</p>
<ol>
<li>
<p>A file as the source.</p>
<div class="highlight"><pre><span></span><code>xls_eval_ir_test(
    name = &quot;a_eval_ir_test&quot;,
    src = &quot;a.ir&quot;,
)
</code></pre></div>
</li>
<li>
<p>An xls_ir_opt_ir target as the source.</p>
<div class="highlight"><pre><span></span><code>xls_ir_opt_ir(
    name = &quot;a_opt_ir&quot;,
    src = &quot;a.ir&quot;,
)


xls_eval_ir_test(
    name = &quot;a_eval_ir_test&quot;,
    src = &quot;:a_opt_ir&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_eval_ir_test-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_eval_ir_test-src"></a>src</td>
<td style="text-align: left;">The IR source file for the rule. A single source file must be provided. The file must have a '.ir' extension.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_eval_ir_test-input_validator"></a>input_validator</td>
<td style="text-align: left;">The DSLX library defining the input validator for this test. Mutually exclusive with "input_validator_expr".</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_eval_ir_test-input_validator_expr"></a>input_validator_expr</td>
<td style="text-align: left;">The expression to validate an input for the test function. Mutually exclusive with "input_validator".</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_eval_ir_test-ir_eval_args"></a>ir_eval_args</td>
<td style="text-align: left;">Arguments of the IR interpreter. For details on the arguments, refer to the eval_ir_main application at //xls/tools/eval_ir_main.cc.The 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{"random_inputs": "100", "optimize_ir": "true"}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_eval_ir_test-top"></a>top</td>
<td style="text-align: left;">The (<em>mangled</em>) name of the entry point. See get_mangled_ir_symbol. Defines the 'top' argument of the IR tool/application.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_ir_equivalence_test"></a></p>
<h2 id="bazel_rules_macros-xls_ir_equivalence_test">xls_ir_equivalence_test</h2>
<pre>
xls_ir_equivalence_test(<a href="#bazel_rules_macros-xls_ir_equivalence_test-name">name</a>, <a href="#bazel_rules_macros-xls_ir_equivalence_test-ir_equivalence_args">ir_equivalence_args</a>, <a href="#bazel_rules_macros-xls_ir_equivalence_test-src_0">src_0</a>, <a href="#bazel_rules_macros-xls_ir_equivalence_test-src_1">src_1</a>, <a href="#bazel_rules_macros-xls_ir_equivalence_test-top">top</a>)
</pre>

<p>Executes the equivalence tool on two IR files.</p>
<p>Examples:</p>
<ol>
<li>
<p>A file as the source.</p>
<div class="highlight"><pre><span></span><code>xls_ir_equivalence_test(
    name = &quot;ab_ir_equivalence_test&quot;,
    src_0 = &quot;a.ir&quot;,
    src_1 = &quot;b.ir&quot;,
)
</code></pre></div>
</li>
<li>
<p>A target as the source.</p>
<div class="highlight"><pre><span></span><code>xls_dslx_ir(
    name = &quot;b_ir&quot;,
    srcs = [&quot;b.x&quot;],
)

xls_ir_equivalence_test(
    name = &quot;ab_ir_equivalence_test&quot;,
    src_0 = &quot;a.ir&quot;,
    src_1 = &quot;:b_ir&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_ir_equivalence_test-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_equivalence_test-ir_equivalence_args"></a>ir_equivalence_args</td>
<td style="text-align: left;">Arguments of the IR equivalence tool. For details on the arguments, refer to the check_ir_equivalence_main application at //xls/tools/check_ir_equivalence_main.cc. The 'function' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_equivalence_test-src_0"></a>src_0</td>
<td style="text-align: left;">An IR source file for the rule. A single source file must be provided. The file must have a '.ir' extension.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_equivalence_test-src_1"></a>src_1</td>
<td style="text-align: left;">An IR source file for the rule. A single source file must be provided. The file must have a '.ir' extension.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_equivalence_test-top"></a>top</td>
<td style="text-align: left;">The (<em>mangled</em>) name of the entry point. See get_mangled_ir_symbol. Defines the 'top' argument of the IR tool/application.</td>
<td style="text-align: left;">String</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_ir_verilog_fdo"></a></p>
<h2 id="bazel_rules_macros-xls_ir_verilog_fdo">xls_ir_verilog_fdo</h2>
<pre>
xls_ir_verilog_fdo(<a href="#bazel_rules_macros-xls_ir_verilog_fdo-name">name</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-src">src</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-outs">outs</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-block_ir_file">block_ir_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-codegen_args">codegen_args</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-codegen_options_proto">codegen_options_proto</a>,
                   <a href="#bazel_rules_macros-xls_ir_verilog_fdo-module_sig_file">module_sig_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-schedule_file">schedule_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-schedule_ir_file">schedule_ir_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-scheduling_options_proto">scheduling_options_proto</a>,
                   <a href="#bazel_rules_macros-xls_ir_verilog_fdo-sta_tool">sta_tool</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-standard_cells">standard_cells</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-verilog_file">verilog_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-verilog_line_map_file">verilog_line_map_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog_fdo-yosys_tool">yosys_tool</a>)
</pre>

<p>A build rule that generates a Verilog file from an IR file using
FDO (feedback-directed optimization).  Codegen args to activate FDO
and provide required dependencies are automatically provided.  Default
values for FDO parameters are provided but can be overridden in
"codegen_args {...}".</p>
<p>In FDO mode, the codegen_arg "clock_period_ps" MUST be provided.</p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code>```
xls_ir_verilog_fdo(
    name = &quot;a_verilog&quot;,
    src = &quot;a.ir&quot;,
    codegen_args = {
        &quot;clock_period_ps&quot;: &quot;750&quot;,
        &quot;fdo_iteration_number&quot;: &quot;5&quot;,
        ...
    },
)
```
</code></pre></div>
<p><strong>ATTRIBUTES</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Mandatory</th>
<th style="text-align: left;">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-name"></a>name</td>
<td style="text-align: left;">A unique name for this target.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels#target-names">Name</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-src"></a>src</td>
<td style="text-align: left;">The IR source file for the rule. A single source file must be provided. The file must have a '.ir' extension.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-outs"></a>outs</td>
<td style="text-align: left;">The list of generated files.</td>
<td style="text-align: left;">List of strings</td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-block_ir_file"></a>block_ir_file</td>
<td style="text-align: left;">The filename of block-level IR file generated during codegen. If not specified, the basename of the Verilog file followed by a .block.ir extension is used.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-codegen_args"></a>codegen_args</td>
<td style="text-align: left;">Arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/rules/lib/dict">Dictionary: String -&gt; String</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-codegen_options_proto"></a>codegen_options_proto</td>
<td style="text-align: left;">Filename of a protobuf with arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-module_sig_file"></a>module_sig_file</td>
<td style="text-align: left;">The filename of module signature of the generated Verilog file. If not specified, the basename of the Verilog file followed by a .sig.textproto extension is used.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-schedule_file"></a>schedule_file</td>
<td style="text-align: left;">The filename of schedule of the generated Verilog file.If not specified, the basename of the Verilog file followed by a .schedule.textproto extension is used.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-schedule_ir_file"></a>schedule_ir_file</td>
<td style="text-align: left;">The filename of scheduled IR file generated during scheduled. If not specified, the basename of the Verilog file followed by a .schedule.opt.ir extension is used.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-scheduling_options_proto"></a>scheduling_options_proto</td>
<td style="text-align: left;">Filename of a protobuf with scheduling options arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-sta_tool"></a>sta_tool</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>"@org_theopenroadproject//:opensta"</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-standard_cells"></a>standard_cells</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>"@com_google_skywater_pdk_sky130_fd_sc_hd//:sky130_fd_sc_hd"</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-verilog_file"></a>verilog_file</td>
<td style="text-align: left;">The filename of Verilog file generated. The filename must have a v extension.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">required</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-verilog_line_map_file"></a>verilog_line_map_file</td>
<td style="text-align: left;">The filename of line map for the generated Verilog file.If not specified, the basename of the Verilog file followed by a .verilog_line_map.textproto extension is used.</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog_fdo-yosys_tool"></a>yosys_tool</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><a href="https://bazel.build/concepts/labels">Label</a></td>
<td style="text-align: left;">optional</td>
<td style="text-align: left;"><code>"//third_party/yosys"</code></td>
</tr>
</tbody>
</table>
<p><a id="cc_xls_ir_jit_wrapper"></a></p>
<h2 id="bazel_rules_macros-cc_xls_ir_jit_wrapper">cc_xls_ir_jit_wrapper</h2>
<pre>
cc_xls_ir_jit_wrapper(<a href="#bazel_rules_macros-cc_xls_ir_jit_wrapper-name">name</a>, <a href="#bazel_rules_macros-cc_xls_ir_jit_wrapper-src">src</a>, <a href="#bazel_rules_macros-cc_xls_ir_jit_wrapper-jit_wrapper_args">jit_wrapper_args</a>, <a href="#bazel_rules_macros-cc_xls_ir_jit_wrapper-wrapper_type">wrapper_type</a>, <a href="#bazel_rules_macros-cc_xls_ir_jit_wrapper-kwargs">kwargs</a>)
</pre>

<p>Invokes the JIT wrapper generator and compiles the result as a cc_library.</p>
<p>The macro invokes the JIT wrapper generator on an IR source file. The
generated source files are the inputs to a cc_library with its target name
identical to this macro.</p>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="cc_xls_ir_jit_wrapper-name"></a>name</td>
<td style="text-align: left;">The name of the cc_library target.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="cc_xls_ir_jit_wrapper-src"></a>src</td>
<td style="text-align: left;">The path to the IR file.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="cc_xls_ir_jit_wrapper-jit_wrapper_args"></a>jit_wrapper_args</td>
<td style="text-align: left;">Arguments of the JIT wrapper tool. Note: argument 'output_name' cannot be defined.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="cc_xls_ir_jit_wrapper-wrapper_type"></a>wrapper_type</td>
<td style="text-align: left;">The type of XLS construct to wrap. Must be one of 'BLOCK', 'FUNCTION', or 'PROC'. You should use the exported FUNCTION_WRAPPER_TYPE, BLOCK_WRAPPER_TYPE, or PROC_WRAPPER_TYPE symbols. Defaults to FUNCTION_WRAPPER_TYPE for compatibility.</td>
<td style="text-align: left;"><code>"FUNCTION"</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="cc_xls_ir_jit_wrapper-kwargs"></a>kwargs</td>
<td style="text-align: left;">Keyword arguments. Named arguments.</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="get_mangled_ir_symbol"></a></p>
<h2 id="bazel_rules_macros-get_mangled_ir_symbol">get_mangled_ir_symbol</h2>
<pre>
get_mangled_ir_symbol(<a href="#bazel_rules_macros-get_mangled_ir_symbol-module_name">module_name</a>, <a href="#bazel_rules_macros-get_mangled_ir_symbol-function_name">function_name</a>, <a href="#bazel_rules_macros-get_mangled_ir_symbol-parametric_values">parametric_values</a>, <a href="#bazel_rules_macros-get_mangled_ir_symbol-is_implicit_token">is_implicit_token</a>,
                      <a href="#bazel_rules_macros-get_mangled_ir_symbol-is_proc_next">is_proc_next</a>)
</pre>

<p>Returns the mangled IR symbol for the module/function combination.</p>
<p>"Mangling" is the process of turning nicely namedspaced symbols into
"grosser" (mangled) flat (non hierarchical) symbol, e.g. that lives on a
package after IR conversion. To retrieve/execute functions that have been IR
converted, we use their mangled names to refer to them in the IR namespace.</p>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="get_mangled_ir_symbol-module_name"></a>module_name</td>
<td style="text-align: left;">The DSLX module name that the function is within.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="get_mangled_ir_symbol-function_name"></a>function_name</td>
<td style="text-align: left;">The DSLX function name within the module.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="get_mangled_ir_symbol-parametric_values"></a>parametric_values</td>
<td style="text-align: left;">Any parametric values used for instantiation (e.g. for a parametric entry point that is known to be instantiated in the IR converted module). This is generally for more advanced use cases like internals testing. The argument is mutually exclusive with argument 'is_proc_next'.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="get_mangled_ir_symbol-is_implicit_token"></a>is_implicit_token</td>
<td style="text-align: left;">A boolean flag denoting whether the symbol contains an implicit token. The argument is mutually exclusive with argument 'is_proc_next'.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="get_mangled_ir_symbol-is_proc_next"></a>is_proc_next</td>
<td style="text-align: left;">A boolean flag denoting whether the symbol is a next proc function. The argument is mutually exclusive with arguments: 'parametric_values' and 'is_implicit_token'.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>RETURNS</strong></p>
<p>The "mangled" symbol string.</p>
<p><a id="xls_benchmark_ir"></a></p>
<h2 id="bazel_rules_macros-xls_benchmark_ir">xls_benchmark_ir</h2>
<pre>
xls_benchmark_ir(<a href="#bazel_rules_macros-xls_benchmark_ir-name">name</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-src">src</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-synthesize">synthesize</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-codegen_args">codegen_args</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-benchmark_ir_args">benchmark_ir_args</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-standard_cells">standard_cells</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-tags">tags</a>,
                 <a href="#bazel_rules_macros-xls_benchmark_ir-ir_tags">ir_tags</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-synth_tags">synth_tags</a>, <a href="#bazel_rules_macros-xls_benchmark_ir-kwargs">kwargs</a>)
</pre>

<p>Executes the benchmark tool on an IR file.</p>
<p>Examples:</p>
<ol>
<li>
<p>A file as the source.</p>
<div class="highlight"><pre><span></span><code>xls_benchmark_ir(
    name = &quot;a_benchmark&quot;,
    src = &quot;a.ir&quot;,
)
</code></pre></div>
</li>
<li>
<p>An xls_ir_opt_ir target as the source.</p>
<div class="highlight"><pre><span></span><code>xls_ir_opt_ir(
    name = &quot;a_opt_ir&quot;,
    src = &quot;a.ir&quot;,
)


xls_benchmark_ir(
    name = &quot;a_benchmark&quot;,
    src = &quot;:a_opt_ir&quot;,
)
</code></pre></div>
<p>Args:
      name: A unique name for this target.
      src: The IR source file for the rule. A single source file must be provided. The file must
        have a '.ir' extension.
      synthesize: Add a synthesis benchmark in addition to the IR benchmark.
      codegen_args: Arguments of the codegen tool. For details on the arguments,
        refer to the codegen_main application at
        //xls/tools/codegen_main.cc.
      benchmark_ir_args: Arguments of the benchmark IR tool. For details on the arguments, refer
        to the benchmark_main application at //xls/tools/benchmark_main.cc.
      standard_cells: Label for the PDK (possibly specifying a
        non-default corner), with the assumption that $location will
        return the timing (Liberty) library for the PDK corner. Unused if synthesize == False.
      tags: Tags for IR and synthesis benchmark targets.
      ir_tags: Tags for the IR benchmark target only.
      synth_tags: Tags for the synthesis and synthesis benchmark targets. Unused if synthesize == False.
      **kwargs: Keyword arguments for the IR benchmark target only.</p>
</li>
</ol>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-name"></a>name</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-src"></a>src</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-synthesize"></a>synthesize</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-codegen_args"></a>codegen_args</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-benchmark_ir_args"></a>benchmark_ir_args</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-standard_cells"></a>standard_cells</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-tags"></a>tags</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-ir_tags"></a>ir_tags</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-synth_tags"></a>synth_tags</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_benchmark_ir-kwargs"></a>kwargs</td>
<td style="text-align: left;"><p align="center"> - </p></td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_cpp_type_library"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_cpp_type_library">xls_dslx_cpp_type_library</h2>
<pre>
xls_dslx_cpp_type_library(<a href="#bazel_rules_macros-xls_dslx_cpp_type_library-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_cpp_type_library-src">src</a>, <a href="#bazel_rules_macros-xls_dslx_cpp_type_library-namespace">namespace</a>)
</pre>

<p>Creates a cc_library target for transpiled DSLX types.</p>
<p>This macros invokes the DSLX-to-C++ transpiler and compiles the result as
a cc_library with its target name identical to this macro.</p>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_cpp_type_library-name"></a>name</td>
<td style="text-align: left;">The name of the eventual cc_library.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_cpp_type_library-src"></a>src</td>
<td style="text-align: left;">The DSLX file whose types to compile as C++.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_cpp_type_library-namespace"></a>namespace</td>
<td style="text-align: left;">The C++ namespace to generate the code in (e.g., <code>foo::bar</code>).</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_fmt_test"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_fmt_test">xls_dslx_fmt_test</h2>
<pre>
xls_dslx_fmt_test(<a href="#bazel_rules_macros-xls_dslx_fmt_test-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_fmt_test-src">src</a>, <a href="#bazel_rules_macros-xls_dslx_fmt_test-opportunistic_postcondition">opportunistic_postcondition</a>)
</pre>

<p>Creates a test target that confirms <code>src</code> is auto-formatted.</p>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_fmt_test-name"></a>name</td>
<td style="text-align: left;">Name of the (diff) test target this will emit.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_fmt_test-src"></a>src</td>
<td style="text-align: left;">Source file to auto-format.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_fmt_test-opportunistic_postcondition"></a>opportunistic_postcondition</td>
<td style="text-align: left;">Flag that checks whether the output text is highly similar to the input text. Note that sometimes this /can/ flag an error for some set of valid auto-formattings, so is intended primarily for use as a development/debugging tool.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_ir"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_ir">xls_dslx_ir</h2>
<pre>
xls_dslx_ir(<a href="#bazel_rules_macros-xls_dslx_ir-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_ir-dslx_top">dslx_top</a>, <a href="#bazel_rules_macros-xls_dslx_ir-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_dslx_ir-deps">deps</a>, <a href="#bazel_rules_macros-xls_dslx_ir-library">library</a>, <a href="#bazel_rules_macros-xls_dslx_ir-ir_conv_args">ir_conv_args</a>, <a href="#bazel_rules_macros-xls_dslx_ir-enable_generated_file">enable_generated_file</a>,
            <a href="#bazel_rules_macros-xls_dslx_ir-enable_presubmit_generated_file">enable_presubmit_generated_file</a>, <a href="#bazel_rules_macros-xls_dslx_ir-kwargs">kwargs</a>)
</pre>

<p>A macro that instantiates a build rule converting a DSLX source file to an IR file.</p>
<p>The macro instantiates a rule that converts a DSLX source file to an IR
file. The macro also instantiates the 'enable_generated_file_wrapper'
function. The generated files are listed in the outs attribute of the rule.</p>
<p>Example:</p>
<p>An IR conversion with a top entity defined.</p>
<div class="highlight"><pre><span></span><code>```
# Assume a xls_dslx_library target bc_dslx is present.
xls_dslx_ir(
    name = &quot;d_ir&quot;,
    srcs = [&quot;d.x&quot;],
    deps = [&quot;:bc_dslx&quot;],
    dslx_top = &quot;d&quot;,
)
```
</code></pre></div>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-name"></a>name</td>
<td style="text-align: left;">The name of the rule.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-dslx_top"></a>dslx_top</td>
<td style="text-align: left;">The top entity to perform the IR conversion.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-srcs"></a>srcs</td>
<td style="text-align: left;">Top level source files for the conversion. Files must have a '.x' extension. There must be single source file.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-deps"></a>deps</td>
<td style="text-align: left;">Dependency targets for the files in the 'srcs' argument.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-library"></a>library</td>
<td style="text-align: left;">A DSLX library target where the direct (non-transitive) files of the target are tested. This argument is mutually exclusive with the 'srcs' and 'deps' arguments.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-ir_conv_args"></a>ir_conv_args</td>
<td style="text-align: left;">Arguments of the IR conversion tool. For details on the arguments, refer to the ir_converter_main application at //xls/dslx/ir_convert/ir_converter_main.cc. Note: the 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-enable_generated_file"></a>enable_generated_file</td>
<td style="text-align: left;">See 'enable_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-enable_presubmit_generated_file"></a>enable_presubmit_generated_file</td>
<td style="text-align: left;">See 'enable_presubmit_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_ir-kwargs"></a>kwargs</td>
<td style="text-align: left;">Keyword arguments. Named arguments.</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_opt_ir"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_opt_ir">xls_dslx_opt_ir</h2>
<pre>
xls_dslx_opt_ir(<a href="#bazel_rules_macros-xls_dslx_opt_ir-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-dslx_top">dslx_top</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-deps">deps</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-library">library</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-ir_conv_args">ir_conv_args</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-opt_ir_args">opt_ir_args</a>,
                <a href="#bazel_rules_macros-xls_dslx_opt_ir-enable_generated_file">enable_generated_file</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-enable_presubmit_generated_file">enable_presubmit_generated_file</a>, <a href="#bazel_rules_macros-xls_dslx_opt_ir-kwargs">kwargs</a>)
</pre>

<p>A macro that instantiates a build rule generating an optimized IR file from a DSLX source file.</p>
<p>The macro instantiates a build rule that generates an optimized IR file from
a DSLX source file. The build rule executes the core functionality of
following macros:</p>
<ol>
<li>xls_dslx_ir (converts a DSLX file to an IR), and,</li>
<li>xls_ir_opt_ir (optimizes the IR).</li>
</ol>
<p>The macro also instantiates the 'enable_generated_file_wrapper'
function. The generated files are listed in the outs attribute of the rule.</p>
<p>Examples:</p>
<ol>
<li>A simple example.<div class="highlight"><pre><span></span><code># Assume a xls_dslx_library target bc_dslx is present.
xls_dslx_opt_ir(
    name = &quot;d_opt_ir&quot;,
    srcs = [&quot;d.x&quot;],
    deps = [&quot;:bc_dslx&quot;],
    dslx_top = &quot;d&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-name"></a>name</td>
<td style="text-align: left;">The name of the rule.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-dslx_top"></a>dslx_top</td>
<td style="text-align: left;">The top entity to perform the IR conversion.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-srcs"></a>srcs</td>
<td style="text-align: left;">Top level source files for the conversion. Files must have a '.x' extension. There must be single source file.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-deps"></a>deps</td>
<td style="text-align: left;">Dependency targets for the files in the 'srcs' argument.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-library"></a>library</td>
<td style="text-align: left;">A DSLX library target where the direct (non-transitive) files of the target are tested. This argument is mutually exclusive with the 'srcs' and 'deps' arguments.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-ir_conv_args"></a>ir_conv_args</td>
<td style="text-align: left;">Arguments of the IR conversion tool. For details on the arguments, refer to the ir_converter_main application at //xls/dslx/ir_convert/ir_converter_main.cc. Note: the 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-opt_ir_args"></a>opt_ir_args</td>
<td style="text-align: left;">Arguments of the IR optimizer tool. For details on the arguments, refer to the opt_main application at //xls/tools/opt_main.cc. Note: the 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-enable_generated_file"></a>enable_generated_file</td>
<td style="text-align: left;">See 'enable_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-enable_presubmit_generated_file"></a>enable_presubmit_generated_file</td>
<td style="text-align: left;">See 'enable_presubmit_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_opt_ir-kwargs"></a>kwargs</td>
<td style="text-align: left;">Keyword arguments. Named arguments.</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="xls_dslx_verilog"></a></p>
<h2 id="bazel_rules_macros-xls_dslx_verilog">xls_dslx_verilog</h2>
<pre>
xls_dslx_verilog(<a href="#bazel_rules_macros-xls_dslx_verilog-name">name</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-dslx_top">dslx_top</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-verilog_file">verilog_file</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-deps">deps</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-library">library</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-ir_conv_args">ir_conv_args</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-opt_ir_args">opt_ir_args</a>,
                 <a href="#bazel_rules_macros-xls_dslx_verilog-codegen_args">codegen_args</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-enable_generated_file">enable_generated_file</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-enable_presubmit_generated_file">enable_presubmit_generated_file</a>, <a href="#bazel_rules_macros-xls_dslx_verilog-kwargs">kwargs</a>)
</pre>

<p>A macro that instantiates a build rule generating a Verilog file from a DSLX source file and tests the build.</p>
<p>The macro instantiates a build rule that generates a Verilog file from a DSLX source file. The
build rule executes the core functionality of following macros:</p>
<ol>
<li>xls_dslx_ir (converts a DSLX file to an IR),</li>
<li>xls_ir_opt_ir (optimizes the IR), and,</li>
<li>xls_ir_verilog (generated a Verilog file).</li>
</ol>
<p>The macro also instantiates a 'build_test' testing that the build rule generating a Verilog
file. If the build is not successful, an error is produced when executing a test command on the
target.</p>
<p>Examples:</p>
<ol>
<li>A simple example.<div class="highlight"><pre><span></span><code># Assume a xls_dslx_library target bc_dslx is present.
xls_dslx_verilog(
    name = &quot;d_verilog&quot;,
    srcs = [&quot;d.x&quot;],
    deps = [&quot;:bc_dslx&quot;],
    codegen_args = {
        &quot;pipeline_stages&quot;: &quot;1&quot;,
    },
    dslx_top = &quot;d&quot;,
)
</code></pre></div>
</li>
</ol>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-name"></a>name</td>
<td style="text-align: left;">The name of the rule.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-dslx_top"></a>dslx_top</td>
<td style="text-align: left;">The top entity to perform the IR conversion.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-verilog_file"></a>verilog_file</td>
<td style="text-align: left;">The filename of Verilog file generated. The filename must have a '.v' extension.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-srcs"></a>srcs</td>
<td style="text-align: left;">Top level source files for the conversion. Files must have a '.x' extension. There must be single source file.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-deps"></a>deps</td>
<td style="text-align: left;">Dependency targets for the files in the 'srcs' argument.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-library"></a>library</td>
<td style="text-align: left;">A DSLX library target where the direct (non-transitive) files of the target are tested. This argument is mutually exclusive with the 'srcs' and 'deps' arguments.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-ir_conv_args"></a>ir_conv_args</td>
<td style="text-align: left;">Arguments of the IR conversion tool. For details on the arguments, refer to the ir_converter_main application at //xls/dslx/ir_convert/ir_converter_main.cc. Note: the 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-opt_ir_args"></a>opt_ir_args</td>
<td style="text-align: left;">Arguments of the IR optimizer tool. For details on the arguments, refer to the opt_main application at //xls/tools/opt_main.cc. Note: the 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-codegen_args"></a>codegen_args</td>
<td style="text-align: left;">Arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-enable_generated_file"></a>enable_generated_file</td>
<td style="text-align: left;">See 'enable_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-enable_presubmit_generated_file"></a>enable_presubmit_generated_file</td>
<td style="text-align: left;">See 'enable_presubmit_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_dslx_verilog-kwargs"></a>kwargs</td>
<td style="text-align: left;">Keyword arguments. Named arguments.</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="xls_ir_cc_library"></a></p>
<h2 id="bazel_rules_macros-xls_ir_cc_library">xls_ir_cc_library</h2>
<pre>
xls_ir_cc_library(<a href="#bazel_rules_macros-xls_ir_cc_library-name">name</a>, <a href="#bazel_rules_macros-xls_ir_cc_library-src">src</a>, <a href="#bazel_rules_macros-xls_ir_cc_library-top">top</a>, <a href="#bazel_rules_macros-xls_ir_cc_library-namespaces">namespaces</a>)
</pre>

<p>Invokes the AOT compiles the input IR into a cc_library.</p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code>xls_ir_opt_ir(
    name &quot;foo&quot;,
    ...
)

xls_ir_cc_library_macro(
    name = &quot;foo_cc&quot;,
    src = &quot;:foo.opt.ir&quot;,
    top = &quot;bar&quot;,
    namespaces = &quot;a,b,c&quot;,
)
</code></pre></div>
<p>This will produce a cc_library that will execute the fn <code>bar</code> from the
<code>foo</code> IR file. The call itself will be inside the namespace <code>a::b::c</code>.</p>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_ir_cc_library-name"></a>name</td>
<td style="text-align: left;">The name of the resulting library.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_cc_library-src"></a>src</td>
<td style="text-align: left;">The path to the IR file to compile.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_cc_library-top"></a>top</td>
<td style="text-align: left;">The entry point in the IR file of interest.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_cc_library-namespaces"></a>namespaces</td>
<td style="text-align: left;">A comma-separated list of namespaces into which the generated code should go.</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
</tbody>
</table>
<p><a id="xls_ir_opt_ir"></a></p>
<h2 id="bazel_rules_macros-xls_ir_opt_ir">xls_ir_opt_ir</h2>
<pre>
xls_ir_opt_ir(<a href="#bazel_rules_macros-xls_ir_opt_ir-name">name</a>, <a href="#bazel_rules_macros-xls_ir_opt_ir-src">src</a>, <a href="#bazel_rules_macros-xls_ir_opt_ir-opt_ir_args">opt_ir_args</a>, <a href="#bazel_rules_macros-xls_ir_opt_ir-enable_generated_file">enable_generated_file</a>, <a href="#bazel_rules_macros-xls_ir_opt_ir-enable_presubmit_generated_file">enable_presubmit_generated_file</a>,
              <a href="#bazel_rules_macros-xls_ir_opt_ir-debug_srcs">debug_srcs</a>, <a href="#bazel_rules_macros-xls_ir_opt_ir-kwargs">kwargs</a>)
</pre>

<p>A macro that instantiates a build rule optimizing an IR file.</p>
<p>The macro instantiates a build rule that optimizes an IR file. The macro
also instantiates the 'enable_generated_file_wrapper' function. The
generated files are listed in the outs attribute of the rule.</p>
<p>Examples:</p>
<ol>
<li>
<p>A simple example.</p>
<div class="highlight"><pre><span></span><code>xls_ir_opt_ir(
    name = &quot;a_opt_ir&quot;,
    src = &quot;a.ir&quot;,
)
</code></pre></div>
</li>
<li>
<p>Optimizing an IR file with a top entity defined.</p>
<div class="highlight"><pre><span></span><code>xls_ir_opt_ir(
    name = &quot;a_opt_ir&quot;,
    src = &quot;a.ir&quot;,
    opt_ir_args = {
        &quot;inline_procs&quot; : &quot;true&quot;,
    },
)
</code></pre></div>
</li>
</ol>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-name"></a>name</td>
<td style="text-align: left;">The name of the rule.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-src"></a>src</td>
<td style="text-align: left;">The IR source file. A single source file must be provided. The file must have a '.ir' extension.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-opt_ir_args"></a>opt_ir_args</td>
<td style="text-align: left;">Arguments of the IR optimizer tool. For details on the arguments, refer to the opt_main application at //xls/tools/opt_main.cc. Note: the 'top' argument is not assigned using this attribute.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-enable_generated_file"></a>enable_generated_file</td>
<td style="text-align: left;">See 'enable_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-enable_presubmit_generated_file"></a>enable_presubmit_generated_file</td>
<td style="text-align: left;">See 'enable_presubmit_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-debug_srcs"></a>debug_srcs</td>
<td style="text-align: left;">List of additional source files for debugging info. Allows opt_main to correctly display lines from original source file (e.g. the .cc file before the xlscc pass) when an error occurs.</td>
<td style="text-align: left;"><code>[]</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_opt_ir-kwargs"></a>kwargs</td>
<td style="text-align: left;">Keyword arguments. Named arguments.</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="xls_ir_verilog"></a></p>
<h2 id="bazel_rules_macros-xls_ir_verilog">xls_ir_verilog</h2>
<pre>
xls_ir_verilog(<a href="#bazel_rules_macros-xls_ir_verilog-name">name</a>, <a href="#bazel_rules_macros-xls_ir_verilog-src">src</a>, <a href="#bazel_rules_macros-xls_ir_verilog-verilog_file">verilog_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog-codegen_args">codegen_args</a>, <a href="#bazel_rules_macros-xls_ir_verilog-codegen_options_proto">codegen_options_proto</a>,
               <a href="#bazel_rules_macros-xls_ir_verilog-scheduling_options_proto">scheduling_options_proto</a>, <a href="#bazel_rules_macros-xls_ir_verilog-enable_generated_file">enable_generated_file</a>, <a href="#bazel_rules_macros-xls_ir_verilog-enable_presubmit_generated_file">enable_presubmit_generated_file</a>,
               <a href="#bazel_rules_macros-xls_ir_verilog-kwargs">kwargs</a>)
</pre>

<p>A macro that instantiates a build rule generating a Verilog file from an IR file and tests the build.</p>
<p>The macro instantiates a build rule that generate a Verilog file from an IR file, and a
'build_test' testing that the build rule generating a Verilog file. If the build is not
successful, an error is produced when executing a test command on the target.</p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code>```
xls_ir_verilog(
    name = &quot;a_verilog&quot;,
    src = &quot;a.ir&quot;,
    codegen_args = {
        &quot;pipeline_stages&quot;: &quot;1&quot;,
        ...
    },
)
```
</code></pre></div>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-name"></a>name</td>
<td style="text-align: left;">The name of the rule.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-src"></a>src</td>
<td style="text-align: left;">The IR source file. A single source file must be provided. The file must have a '.ir' extension.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-verilog_file"></a>verilog_file</td>
<td style="text-align: left;">The filename of Verilog file generated. The filename must have a '.v' or '.sv', extension.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-codegen_args"></a>codegen_args</td>
<td style="text-align: left;">Arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><code>{}</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-codegen_options_proto"></a>codegen_options_proto</td>
<td style="text-align: left;">Filename of a protobuf with arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-scheduling_options_proto"></a>scheduling_options_proto</td>
<td style="text-align: left;">Filename of a protobuf with scheduling options arguments of the codegen tool. For details on the arguments, refer to the codegen_main application at //xls/tools/codegen_main.cc.</td>
<td style="text-align: left;"><code>None</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-enable_generated_file"></a>enable_generated_file</td>
<td style="text-align: left;">See 'enable_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>True</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-enable_presubmit_generated_file"></a>enable_presubmit_generated_file</td>
<td style="text-align: left;">See 'enable_presubmit_generated_file' from 'enable_generated_file_wrapper' function.</td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_ir_verilog-kwargs"></a>kwargs</td>
<td style="text-align: left;">Keyword arguments. Named arguments.</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table>
<p><a id="xls_synthesis_metrics"></a></p>
<h2 id="bazel_rules_macros-xls_synthesis_metrics">xls_synthesis_metrics</h2>
<pre>
xls_synthesis_metrics(<a href="#bazel_rules_macros-xls_synthesis_metrics-name">name</a>, <a href="#bazel_rules_macros-xls_synthesis_metrics-srcs">srcs</a>, <a href="#bazel_rules_macros-xls_synthesis_metrics-kwargs">kwargs</a>)
</pre>

<p>Gather per-pipeline-stage metrics from log files.</p>
<p>Gather per-stage post-synth metrics from the provided logs
(from Yosys or OpenSTA) and save them in a "DesignStats" textproto.
Recognized metrics from Yosys log:
  Total cell area (um^2).
  Logic levels
  Cell count
  Flop count
Recognized metrics from OpenSTA log:
  Critical path delay (ps)
  Critical path start point
  Critical path end point</p>
<p><strong>PARAMETERS</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a id="xls_synthesis_metrics-name"></a>name</td>
<td style="text-align: left;">Output "DesignStats" textproto will be <code>&lt;name&gt;.textproto</code></td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_synthesis_metrics-srcs"></a>srcs</td>
<td style="text-align: left;">Targets from which log files will be scanned. For post-synth, use "synthesize_rtl" and "run_opensta" targets.</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;"><a id="xls_synthesis_metrics-kwargs"></a>kwargs</td>
<td style="text-align: left;">Accepts add'l keyword arguments. Passed to native.genrule().</td>
<td style="text-align: left;">none</td>
</tr>
</tbody>
</table></section><section class="print-page" id="tools_quick_start"><h1 id="tools_quick_start-xls-tools-quick-start">XLS Tools Quick Start</h1>
<p>This document is a quick start guide through the use of the individual XLS
tools, from DSL input to RTL generation.</p>
<p><strong>Note:</strong> This guide assumes you have
<a href="#index-building-from-source">set up your system so it can build the XLS tools via Bazel</a>.
There is currently no binary tools distribution so building from source is
required.</p>
<p>Create a file <code>/tmp/simple_add.x</code> with the following contents:</p>
<div class="highlight"><pre><span></span><code>fn add(x: u32, y: u32) -&gt; u32 {
  x + y + u32:0  // Something to optimize.
}

#[test]
fn test_add() {
  assert_eq(add(u32:2, u32:3), u32:5)
}
</code></pre></div>
<p>This contains a function, and a unit test of that function.</p>
<h2 id="tools_quick_start-interpreting-the-dsl-file">Interpreting the DSL file</h2>
<p>Now, run it through the DSL interpreter -- the DSL interpreter is useful for
interactive development and debugging.</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/dslx:interpreter_main -- /tmp/simple_add.x
[ RUN      ] add
[       OK ] add
</code></pre></div>
<p>The DSL interpreter is the execution engine running the test shown.</p>
<p>In lieu of using bazel run for the subsequent commands, this document will
assume <code>bazel build -c opt //xls/...</code> has been completed so the binaries in
<code>./bazel-bin</code> can be used directly:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/dslx/interpreter_main /tmp/simple_add.x
[ RUN      ] add
[       OK ] add
</code></pre></div>
<h2 id="tools_quick_start-dsl-to-ir-conversion">DSL to IR conversion</h2>
<p>To convert the DSL file to IR, run the following command:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/dslx/ir_convert/ir_converter_main --top=add /tmp/simple_add.x &gt; /tmp/simple_add.ir
</code></pre></div>
<h2 id="tools_quick_start-ir-optimization">IR optimization</h2>
<p>To optimize the IR, use the <code>opt_main</code> tool:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/tools/opt_main /tmp/simple_add.ir &gt; /tmp/simple_add.opt.ir
</code></pre></div>
<p>Check the output of <code>diff -U8 /tmp/simple_add*.ir</code> to see that the optimizer
eliminated the useless add-with-zero.</p>
<h2 id="tools_quick_start-verilog-rtl-generation">Verilog RTL generation</h2>
<p>To generate RTL from the optimized IR, use the <code>codegen_main</code> tool:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/tools/codegen_main --pipeline_stages=1 --delay_model=unit /tmp/simple_add.opt.ir &gt; /tmp/simple_add.v
</code></pre></div>
<h2 id="tools_quick_start-ir-visualizer">IR visualizer</h2>
<p>To get a graphical view of the IR files, use the IR visualization tool:</p>
<div class="highlight"><pre><span></span><code>$ ./bazel-bin/xls/visualization/ir_viz/app --delay_model=unit --preload_ir_path=/tmp/simple_add.ir
</code></pre></div>
<p>This starts a server on localhost port 5000 by default, so you can access
it from your machine as <code>http://localhost:5000</code> in a web browser.</p></section><section class="print-page" id="tools"><h1 id="tools-xls-tools">XLS Tools</h1>
<p>An index of XLS developer tools.</p>
<h2 id="tools-bdd_stats"><a href="https://github.com/google/xls/tree/main/xls/tools/bdd_stats.cc"><code>bdd_stats</code></a></h2>
<p>Constructs a binary decision diagram (BDD) using a given XLS function and prints
various statistics about the BDD. BDD construction can be very slow in
pathological cases and this utility is useful for identifying the underlying
causes. Accepts arbitrary IR as input or a benchmark specified by name.</p>
<h2 id="tools-benchmark_main"><a href="https://github.com/google/xls/tree/main/xls/tools/benchmark_main.cc"><code>benchmark_main</code></a></h2>
<p>Prints numerous metrics and other information about an XLS IR file including:
total delay, critical path, codegen information, optimization time, etc. This
tool may be run against arbitrary IR not just the fixed set of XLS benchmarks.
The output of this tool is scraped by <code>run_benchmarks</code> to construct a table
comparing metrics against a mint CL across the benchmark suite.</p>
<h2 id="tools-booleanify_main"><a href="https://github.com/google/xls/tree/main/xls/tools/booleanify_main.cc"><code>booleanify_main</code></a></h2>
<p>Rewrites an XLS IR function in terms of its ops' fundamental AND/OR/NOT
constituents, i.e., makes all operations boolean, thus it's "booleanifying" the
function.</p>
<h2 id="tools-codegen_main"><a href="https://github.com/google/xls/tree/main/xls/tools/codegen_main.cc"><code>codegen_main</code></a></h2>
<p>Lowers an XLS IR file into Verilog. Options include emitting a feedforward
pipeline or a purely combinational block. Emits both a Verilog file and a module
signature which includes metadata about the block. The tool does not run any XLS
passes so unoptimized IR may fail if the IR contains constructs not expected by
the backend.</p>
<p>For a detailed list of codegen options including I/O configurations, please
visit the <a href="#codegen_options">codegen options</a> page.</p>
<h2 id="tools-delay_info_main"><a href="https://github.com/google/xls/tree/main/xls/tools/delay_info_main.cc"><code>delay_info_main</code></a></h2>
<p>Dumps delay information about an XLS function including per-node delay
information and critical-path.</p>
<h2 id="tools-eval_ir_main"><a href="https://github.com/google/xls/tree/main/xls/tools/eval_ir_main.cc"><code>eval_ir_main</code></a></h2>
<p>Evaluates an XLS IR file with user-specified or random inputs. Includes features
for evaluating the IR before and after optimizations which makes this tool very
useful for identifying optimization bugs.</p>
<p>This tool accepts two [mutually exclusive] optional args,
<code>--input_validator_expr</code> and <code>--input_validator_path</code>, which allow the user to
specify an expression to "filter" potential input values to discard invalid
ones. For both, the filter must be a function, named <code>validator</code>, and must take
params of the same layout as the function under test. This function should
return true if the inputs are valid for the function and false otherwise.
<code>--input_validator_expr</code> lists the function as an inline command-line argument,
whereas <code>--input_validator_path</code> holds the path to a .x file containing the
validation function.</p>
<h3 id="tools-jit-inspection">Jit Inspection Flags</h3>
<p><code>eval_ir_main</code> provides several flags which can be used to inspect the jit code
produced by our function jit. These flags all require that <code>--use_llvm_jit=true</code>
(the default). Currently these flags only work with xls-functions. See the
<a href="#fuzzer">fuzzing documentation</a> for more information about how the
information these flags reveal can be used.</p>
<p>This tool can also be used to generate and inspect the LLVM/ASM programs
generated by the jit (for function programs). This can be used to diagnose
issues found by the fuzzer.</p>
<ul>
<li><code>--llvm_jit_ir_output=&lt;file&gt;</code> controls where the unoptimized llvm ir for the
    function is saved.</li>
<li><code>--llvm_jit_opt_ir_output=&lt;file&gt;</code> does the same but with the IR after LLVM
    itself has optimized it.</li>
<li><code>--llvm_jit_asm_output=&lt;file&gt;</code> saves the result of converting the opt-ir
    into assembly for the current architecture.</li>
<li><code>--llvm_jit_main_wrapper_output=&lt;file&gt;</code> writes a bytecode file containing a
    <code>main(int argc, char** argv)</code> function which calls the function the jit
    creates. This can be
    <a href="https://llvm.org/docs/CommandGuide/llvm-link.html"><code>llvm-link</code></a>d with the
    <code>llvm_jit_ir_output</code> or <code>llvm_jit_opt_ir_output</code> to create a program
    runnable by <a href="https://llvm.org/docs/CommandGuide/lli.html"><code>lli</code></a> or other
    llvm tools.</li>
<li><code>--llvm_jit_main_wrapper_write_is_linked=true</code> (default is <code>false</code>) makes
    the main wrapper call the posix <code>write</code> API to send the output to stdout.
    The data is written without any processing as a stream of bytes in the order
    it appears in memory. This flag is provided (and defaulted to off) because
    not all llvm analysis tools are always able to handle extern symbols in a
    reasonable way.</li>
</ul>
<p>Note: LLVM can change significantly and bytecode is not always compatible
between versions. If possible, LLVM tools built at the same commit as the JIT
should be used to interact with the generated llvm bytecode. This can be done by
building the LLVM tools using <code>bazel build</code> from the XLS repo.</p>
<h2 id="tools-ir_minimizer_main"><a href="https://github.com/google/xls/tree/main/xls/tools/ir_minimizer_main.cc"><code>ir_minimizer_main</code></a></h2>
<p>Tool for reducing IR to a minimal test case based on an external test.</p>
<h2 id="tools-ir_stats_main"><a href="https://github.com/google/xls/tree/main/xls/tools/ir_stats_main.cc"><code>ir_stats_main</code></a></h2>
<p>Prints summary information/stats on an IR [Package] file. An example:</p>
<div class="highlight"><pre><span></span><code>$ bazel-bin/xls/tools/ir_stats_main bazel-genfiles/xls/modules/fp32_add_2.ir
Package &quot;fp32_add_2&quot;
  Function: &quot;__float32__is_inf&quot;
    Signature: ((bits[1], bits[8], bits[23])) -&gt; bits[1]
    Nodes: 8

  Function: &quot;__float32__is_nan&quot;
    Signature: ((bits[1], bits[8], bits[23])) -&gt; bits[1]
    Nodes: 8

  Function: &quot;__fp32_add_2__fp32_add_2&quot;
    Signature: ((bits[1], bits[8], bits[23]), (bits[1], bits[8], bits[23])) -&gt; (bits[1], bits[8], bits[23])
    Nodes: 252
</code></pre></div>
<h2 id="tools-check_ir_equivalence"><a href="https://github.com/google/xls/tree/main/xls/tools/check_ir_equivalence_main.cc"><code>check_ir_equivalence</code></a></h2>
<p>Verifies that two IR files (for example, optimized and unoptimized IR from the
same source) are logically equivalent.</p>
<h2 id="tools-opt_main"><a href="https://github.com/google/xls/tree/main/xls/tools/opt_main.cc"><code>opt_main</code></a></h2>
<p>Runs XLS IR through the optimization pipeline.</p>
<p>Standard flags include:</p>
<ul>
<li><code>--top=NAME</code>: Override/set the top function/proc. This is required if a
    function/proc is not already marked as <code>top</code> in the IR.</li>
<li><code>--opt_level=NUMBER</code>: Change the optimization level. This should be used
    with care as the differences between optimization levels are less defined
    for xls than they are in tools such as <code>clang</code>. Defaults to <code>3</code>.</li>
</ul>
<p>Several flags which control the behavior of individual optimizations are also
available. Care should be used when modifying the values of these flags.</p>
<ul>
<li><code>--rm_rewrites_pb=FILE</code>: Used to pass a proto describing the ram rewrites to
    be performed.</li>
<li><code>--inline_procs=true|false</code>: Whether to enable or disable inlining all procs
    into a single mega-proc. Defaults to <code>false</code>.</li>
<li><code>--convert_array_index_to_select=NUMBER</code>: Controls the maximum number of
    dimensions an array can have to allow xls to convert accesses to the array
    into select chains. This can have complicated impacts on the area and delay
    of the generated code.</li>
<li><code>--use_context_narrowing_analysis=true|false</code>: Controls whether to use
    contextual information to optimize range calculations. This can in some
    circumstances reveal additional optimization opportunities but it can be
    quite slow. Defaults to <code>false</code>.</li>
</ul>
<h3 id="tools-debuggingexperimenting-with-optimizations">Debugging/Experimenting with Optimizations</h3>
<p>There are also several flags which are used for debugging and understanding the
behavior of the standard optimization pipeline itself and the passes which make
up the pipeline. These flags should mostly be used for testing and debugging
purposes only.</p>
<ul>
<li><code>--passes=PIPELINE_SPEC</code>: Allows one to specify an explicit optimization
    pipeline to use instead of the standard one. The pipeline is specified by
    listing passes using their short-names. Different passes are space
    separated. Fixed-point combinations of passes are specified by surrounding
    them with square-brackets '<code>[]</code>'. For example, to run the pipeline
    'inlining' then 'arith_simp' and 'dce' to fixed-point then 'narrowing' and a
    final 'dce' the flag would be set to <code>inlining [ arith_simp dce ] narrowing
    dce</code>. This can be used to test odd interactions between specific or single
    passes.</li>
<li><code>--passes_bisect_limit=NUMBER</code>: Tells <code>opt_main</code> to cease pipeline execution
    after running <code>NUMBER</code> passes. This can be used to narrow down misbehaving
    passes. This flag works with both custom <code>--passes</code> pipelines and the
    standard pipeline.</li>
<li><code>--ir_dump_path=FOLDER</code>: Tells <code>opt_main</code> to dump files containing all the
    intermediate states of the optimizations IRs into files in that particular
    directory. Each file is named so they sort lexicographically in the order
    they were created. The names include the pass-number, the pass run and
    whether the pass made any changes to the output.</li>
<li><code>--skip_passes=NAME1,NAME2,...</code>: Tells <code>opt_main</code> to skip execution of
    specific named passes (specified using the short-name of the pass). This
    does not otherwise modify the pipeline being used and the pass is considered
    to have finished successfully without making any changes. Multiple passes
    may be passed at once separated by commas.</li>
</ul>
<h2 id="tools-print_bom"><a href="https://github.com/google/xls/tree/main/xls/tools/print_bom.cc"><code>print_bom</code></a></h2>
<p>Tool to calculate and print a summary of the BOM (bill of materials) elements
from <code>ModuleSignatureProto</code> protobuf files produced using the
<code>--output_signature_path</code> codegen argument.</p>
<p>Features include;</p>
<ul>
<li>Combining the data from multiple protobuf files.</li>
<li>Output in fancy human readable table.</li>
<li>Output machine readable CSV (common separate values) file for loading into
    other tools (like Google Sheets).</li>
<li>Filtering output to a single value type like <code>BOM_KIND_ADDER</code>.</li>
</ul>
<p>Running the following commands;</p>
<div class="highlight"><pre><span></span><code>bazel build //xls/examples/protobuf:varint_encode_sv
bazel run //xls/tools:print_bom -- --root_path $PWD/bazel-bin/xls/examples/protobuf/
</code></pre></div>
<p>should produce the following output;</p>
<div class="highlight"><pre><span></span><code>Found 1 protobuf files.
 * &quot;bazel-bin/xls/examples/protobuf/varint_encode_u32.sig.textproto&quot;

 +------------------------+----------------+-------------+--------------+-------+
 |                   Kind |             Op | Input Width | Output Width | Count |
 +------------------------+----------------+-------------+--------------+-------+
 |    BOM_KIND_COMPARISON |             ne |           4 |            1 |     1 |
 |                        |                |           7 |            1 |     2 |
 |                        |                |          11 |            1 |     1 |
 |                        |                |          18 |            1 |     1 |
 |                        |                |          25 |            1 |     1 |
 +------------------------+----------------+-------------+--------------+-------+
 | BOM_KIND_INSIGNIFICANT |          array |           8 |           40 |     1 |
 |                        |      bit_slice |          32 |            4 |     1 |
 |                        |                |          32 |            7 |     4 |
 |                        |                |          32 |           11 |     1 |
 |                        |                |          32 |           18 |     1 |
 |                        |                |          32 |           25 |     1 |
 |                        |         concat |           1 |            2 |     1 |
 |                        |                |           2 |            3 |     1 |
 |                        |                |           4 |            8 |     1 |
 |                        |                |           7 |            8 |     4 |
 |                        |        literal |           0 |            1 |     2 |
 |                        |                |           0 |            2 |     2 |
 |                        |                |           0 |            3 |     2 |
 |                        |                |           0 |            4 |     2 |
 |                        |                |           0 |            7 |     2 |
 |                        |                |           0 |           11 |     1 |
 |                        |                |           0 |           18 |     1 |
 |                        |                |           0 |           25 |     1 |
 |                        |          tuple |          40 |           43 |     1 |
 +------------------------+----------------+-------------+--------------+-------+
 |          BOM_KIND_MISC |     input_port |           0 |           32 |     1 |
 |                        |    output_port |          43 |            0 |     1 |
 |                        |  register_read |           0 |           32 |     1 |
 |                        |                |           0 |           43 |     1 |
 |                        | register_write |          32 |            0 |     1 |
 |                        |                |          43 |            0 |     1 |
 +------------------------+----------------+-------------+--------------+-------+
 |        BOM_KIND_SELECT |            sel |           2 |            2 |     2 |
 |                        |                |           3 |            3 |     2 |
 +------------------------+----------------+-------------+--------------+-------+
</code></pre></div>
<p>To save the details about the comparison operators to a machine readable CSV
file you can do;</p>
<div class="highlight"><pre><span></span><code>bazel run //xls/tools:print_bom -- --root_path=$PWD/bazel-bin/xls/examples/protobuf/ --output_as=csv --op_kind=BOM_KIND_COMPARISON &gt; my.csv
</code></pre></div>
<p>which will produce a CSV file which looks like the following;</p>
<div class="highlight"><pre><span></span><code>Kind,Op,Input Width,Output Width,Count
BOM_KIND_COMPARISON,ne,4,1,1
BOM_KIND_COMPARISON,ne,7,1,2
BOM_KIND_COMPARISON,ne,11,1,1
BOM_KIND_COMPARISON,ne,18,1,1
BOM_KIND_COMPARISON,ne,25,1,1
</code></pre></div>
<h2 id="tools-dslxinterpreter_main"><a href="https://github.com/google/xls/tree/main/xls/dslx/interpreter_main.cc"><code>dslx/interpreter_main</code></a></h2>
<p>Interpreter for DSLX code and test-runner.</p>
<p>When tests are run this also cross-checks that the conversion to IR and JIT
compilation of the IR produces the same values.</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/dslx:interpreter_main -- $PWD/xls/dslx/stdlib/std.x
[ RUN UNITTEST  ] sizeof_signed_test
[            OK ]
...
</code></pre></div>
<p>Note that this binary takes a command line argument <code>--dslx_path</code> which
indicates where the binary should search for <code>.x</code> files on import (i.e. an
import resolution path). Try to use this sparingly, but it is useful for
pointing at installation locations where DSLX modules have been placed.</p>
<p>In a Bazel environment this binary is encapsulated in
<a href="https://google.github.io/xls/bazel_rules_macros/#xls_dslx_test">an <code>xls_dslx_test</code> target</a></p>
<h2 id="tools-dslxprove_quickcheck_test"><a href="https://github.com/google/xls/tree/main/xls/dslx/prove_quickcheck_test.cc"><code>dslx/prove_quickcheck_test</code></a></h2>
<p>Command line utility for attempting to prove a quickcheck property via SMT
translation. Invoke this tool as:</p>
<p><code>prove_quickcheck_main $ENTRY_FILE $QUICKCHECK_NAME</code></p>
<p>And it will attempt to prove the given quickcheck property over the entire input
domain. Example:</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/dslx:prove_quickcheck_main -- $PWD/xls/dslx/stdlib/std.x convert_to_from_bools
Proven! elapsed: 115.419669ms
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently an error code is returned if it cannot be proven, but it does
not dump a counterexample to terminal. A temporary workaround is to use
<code>--alsologtostderr --v=1</code> until that functionality is completed.</p>
</div>
<h2 id="tools-dslxdslx_fmt"><a href="https://github.com/google/xls/tree/main/xls/dslx/dslx_fmt.cc"><code>dslx/dslx_fmt</code></a></h2>
<p>Auto-formatter for DSLX code (i.e. <code>.x</code> files). This is analogous to rustfmt /
clang-format.</p>
<p>To format a file in-place, use the <code>-i</code> flag:</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt //xls/dslx:dslx_fmt
$ echo &#39;fn f(x:u32)-&gt;u32{x}&#39; &gt; /tmp/my_file.x
$ ./bazel-bin/xls/dslx/dslx_fmt -i /tmp/my_file.x
$ cat /tmp/my_file.x
fn f(x: u32) -&gt; u32 { x }
</code></pre></div>
<p>Without the <code>-i</code> flag the formatted result is given in the standard output from
the tool and the input file path remains unchanged.</p>
<p><strong>Note:</strong> there is also a Bazel build construct to ensure files remain
auto-formatted using the latest <code>dslx_fmt</code> results:</p>
<div class="highlight"><pre><span></span><code>load(&quot;//xls/build_rules:xls_build_defs.bzl&quot;, &quot;xls_dslx_fmt_test&quot;)

xls_dslx_fmt_test(
    name = &quot;my_file_dslx_fmt_test&quot;,
    src = &quot;my_file.x&quot;,
)
</code></pre></div>
<p>Also see the
<a href="https://google.github.io/xls/bazel_rules_macros/#xls_dslx_fmt_test">Bazel rule documentation for <code>xls_dslx_fmt_test</code></a>.</p>
<h2 id="tools-dslxir_convertir_converter_main"><a href="https://github.com/google/xls/tree/main/xls/dslx/ir_convert/ir_converter_main.cc"><code>dslx/ir_convert/ir_converter_main</code></a></h2>
<p>Tool for converting DSLX code (i.e. whole <code>.x</code> files or functions/procs inside
of <code>.x</code> files) into XLS IR.</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt //xls/dslx/ir_convert:ir_converter_main
$ echo &#39;fn f(x:u32)-&gt;u32{x}&#39; &gt; /tmp/my_file.x
$ ./bazel-bin/xls/dslx/ir_convert/ir_converter_main /tmp/my_file.x &gt; /tmp/my_file.ir
$ cat /tmp/my_file.ir
package my_file

file_number 0 &quot;/tmp/my_file.x&quot;

fn __my_file__f(x: bits[32]) -&gt; bits[32] {
  ret x: bits[32] = param(name=x)
}
</code></pre></div>
<h2 id="tools-proto_to_dslx_main"><a href="https://github.com/google/xls/tree/main/xls/tools/proto_to_dslx_main.cc"><code>proto_to_dslx_main</code></a></h2>
<p>Takes in a proto schema and a textproto instance thereof and outputs a DSLX
module containing a DSLX type and constant matching both inputs, respectively.</p>
<p>Not all protocol buffer types map to DSLX types, so there are some restrictions
or other behaviors requiring explanation:</p>
<ol>
<li>Only scalar and repeated fields are supported (i.e., no maps or oneofs,
    etc.).</li>
<li>Only recursively-integral messages are supported, that is to say, a message
    may contain submessages, as long as all non-Message fields are integral.</li>
<li>Since DSLX doesn't support variable arrays and Protocol Buffers don't
    support fixed-length repeated fields. To unify this, all instances of
    repeated-field-containing Messages must have the same size of their repeated
    members (declared as arrays in DSLX). This size will be calculated as the
    maximum size of any instance of that repeated field across all instances in
    the input textproto. For example, if a message <code>Foo</code> has a repeated field
    <code>bar</code>, and this message is present multiple times in the input textproto,
    say as:<div class="highlight"><pre><span></span><code>  foo: {
    bar: 1
  }
  foo: {
    bar: 1
    bar: 2
  }
  foo: {
    bar: 1
    bar: 2
    bar: 3
  }
</code></pre></div>
<p>the DSLX version of <code>Foo</code> will declare <code>bar</code> has a 3-element array. An
  accessory field, <code>bar_count</code>, will also be created, which will contain the
  number of valid entries in an actual instance of <code>Foo::bar</code>.</p>
<p>The "Fields" example in
  <code>./xls/tools/testdata/proto_to_dslx_main.*</code> demonstrates this
  behavior.</p>
</li>
</ol>
<h2 id="tools-repl"><a href="https://github.com/google/xls/tree/main/xls/tools/repl.cc"><code>repl</code></a></h2>
<p>Allows you to interactively run various parts of the compiler, including
parsing/type checking (<code>:reload</code>), lowering/optimization (<code>:ir</code>), Verilog
codegen (<code>:verilog [identifier]</code>), and LLVM codegen (<code>:llvm</code>, not yet
implemented). You can also inspect the IR types of identifiers with <code>:type</code>, and
even imported identifiers can be accessed with <code>:type foo::bar</code>.</p>
<p><img alt="animated GIF" src="../repl.gif" /></p>
<h2 id="tools-simulate_module_main"><a href="https://github.com/google/xls/tree/main/xls/tools/simulate_module_main.cc"><code>simulate_module_main</code></a></h2>
<p>Runs a Verilog block emitted by XLS through a Verilog simulator. Requires both
the Verilog text and the module signature which includes metadata about the
block.</p>
<h2 id="tools-smtlib_emitter_main"><a href="https://github.com/google/xls/tree/main/xls/tools/smtlib_emitter_main.cc"><code>smtlib_emitter_main</code></a></h2>
<p>Simple driver for Z3IrTranslator - converts a given IR function into its Z3
representation and outputs that translation as SMTLIB2.</p>
<p>First obtain an XLS IR file:</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt //xls/examples:tiny_adder.opt.ir
</code></pre></div>
<p>And then feed that XLS IR file into this binary:</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/tools:smtlib_emitter_main -- --ir_path \
    $PWD/bazel-bin/xls/examples/tiny_adder.opt.ir
(bvadd (concat #b0 x) (concat #b0 y))
</code></pre></div>
<p>To turn it into "gate level" SMTLib, we can do a pre-pass through the
<code>booleanify_main</code> tool:</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/tools:booleanify_main -- --ir_path \
   $PWD/bazel-bin/xls/examples/tiny_adder.opt.ir \
   &gt; /tmp/tiny_adder.boolified.ir
$ bazel run -c opt //xls/tools:smtlib_emitter_main -- \
    --ir_path /tmp/tiny_adder.boolified.ir
(let ((a!1 (bvand (bvor ((_ extract 0 0) x) ((_ extract 0 0) y))
                  (bvnot (bvand ((_ extract 0 0) x) ((_ extract 0 0) y))))))
(let ((a!2 (bvor (bvand (bvor #b0 #b0) (bvnot (bvand #b0 #b0)))
                 (bvor (bvand ((_ extract 0 0) x) ((_ extract 0 0) y))
                       (bvand a!1 #b0))))
      (a!3 (bvand (bvand (bvor #b0 #b0) (bvnot (bvand #b0 #b0)))
                  (bvor (bvand ((_ extract 0 0) x) ((_ extract 0 0) y))
                        (bvand a!1 #b0)))))
  (concat (bvand a!2 (bvnot a!3))
          (bvand (bvor a!1 #b0) (bvnot (bvand a!1 #b0))))))
</code></pre></div>
<h2 id="tools-solver"><a href="https://github.com/google/xls/tree/main/xls/tools/solver.cc"><code>solver</code></a></h2>
<p>Uses a SMT solver (i.e. Z3) to prove properties of an XLS IR program from the
command line. Currently the set of "predicates" that the solver supports from
the command line are limited, but in theory it is capable of solving for
arbitrary IR-function-specified predicates.</p>
<p>This can be used to uncover opportunities for optimization that were missed, or
to prove equivalence of transformed representations with their original version.</p>
<h2 id="tools-cell_library_extract_formula"><a href="https://github.com/google/xls/tree/main/xls/tools/cell_library_extract_formula.cc"><code>cell_library_extract_formula</code></a></h2>
<p>Parses a cell library ".lib" file and extracts boolean formulas from it that
determine the functionality of cells. This is useful for LEC of the XLS IR
against the post-synthesis netlist.</p>
<h2 id="tools-dslxhighlight_main"><a href="https://github.com/google/xls/tree/main/xls/dslx/highlight_main.cc"><code>dslx/highlight_main</code></a></h2>
<p>Performs terminal-based color code highlighting of a DSL file.</p>
<h2 id="tools-dslxtype_systemtypecheck_main"><a href="https://github.com/google/xls/tree/main/xls/dslx/type_system/typecheck_main.cc"><code>dslx/type_system/typecheck_main</code></a></h2>
<p>Dumps type information that has been deduced for a given DSL file.</p>
<h2 id="tools-development-tools">Development Tools</h2>
<h3 id="tools-clang-tidy">clang-tidy</h3>
<p>For C++ development, you might need a compilation database to have good support
in your IDE. You can create the <code>compile_commands.json</code> by running this script.</p>
<div class="highlight"><pre><span></span><code>dev_utils/make-compilation-db.sh
</code></pre></div>
<p>To run clang-tidy and create a report of things that might be worthwhile fixing,
use the following script:</p>
<div class="highlight"><pre><span></span><code>dev_utils/run-clang-tidy-cached.sh
</code></pre></div>
<p>(Note, this will be pretty slow on the first run, but it caches results and will
only reprocess changed files in subsequent runs).</p>
<p>The output of the clang-tidy runs shows up in the <code>xls_clang-tidy.out</code> file
which is formatted just like an output from a compiler. So to quickly work with
these, you can use <code>cat xls_clang-tidy.out</code> as your 'compiler invocation' in
your IDE (e.g. <code>M-x compile</code> in emacs) and step through next-error locations as
usual.</p>
<h3 id="tools-golden-comparison-files">Golden Comparison Files</h3>
<p>To re-generate golden reference files (for all test targets that use golden
reference file comparisons), run:</p>
<div class="highlight"><pre><span></span><code>dev_utils/rebuild_golden_files.sh
</code></pre></div>
<h2 id="tools-extract_interface_main"><a href="https://github.com/google/xls/tree/main/xls/tools/extract_interface_main.cc"><code>extract_interface_main</code></a></h2>
<p>Reads an <code>ir</code> file and prints a protobuf describing the interfaces of the
contained code. The interfaces consist of the names of the <code>procs</code>, <code>blocks</code>,
and <code>functions</code> and the names and types of all of their inputs and outputs.
Information about what <code>channels</code> are defined and other useful details is also
included. Take a look at
<a href="https://github.com/google/xls/tree/main/xls/ir/xls_ir_interface.proto"><code>xls_ir_interface.proto</code></a>
for what the interface contains.</p></section><section class="print-page" id="interpreters"><h1 id="interpreters-interpreters">Interpreters</h1>
<p>XLS provides a several interpreters to assist in design validation across our
functional stack, from input DSLX down to the netlist level.</p>
<div class="toc">
<ul>
<li><a href="#interpreters-interpreters">Interpreters</a><ul>
<li><a href="#interpreters-dslx">DSLX</a><ul>
<li><a href="#interpreters-execution-comparison">Execution comparison</a></li>
</ul>
</li>
<li><a href="#interpreters-ir">IR</a></li>
<li><a href="#interpreters-netlists">Netlists</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="interpreters-dslx">DSLX</h2>
<p>The DSLX interpreter (<code>//xls/dslx:interpreter_main</code>) operates on
DSLX <code>.x</code> files that contain both the design and unit tests to execute (present
as <code>#[test]</code> annotated functions).</p>
<p>The <a href="https://github.com/google/xls/tree/main/xls/examples/adler32/adler32.x">adler32</a>
example demonstrates this: the design is encapsulated in the <code>main</code>,
<code>adler32_seq</code>, and <code>mod</code> functions, and the samples are present in the test
<code>adler32_one_char</code> (note that unit-style tests/interpretations of <code>adler32_seq</code>
and <code>mod</code> could also be present).</p>
<p>Interpreter targets are automatically generated for <code>dslx_test()</code> targets, so no
special declarations are necessary to wrap DSLX code.</p>
<p>To invoke these samples, execute the following:</p>
<div class="highlight"><pre><span></span><code>bazel build -c opt //xls/examples/adler32:adler32_dslx_test
./bazel-bin/xls/examples/adler32/adler32_dslx_test
</code></pre></div>
<p>To execute directly via the interpreter, you can instead run:</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt //xls/dslx/interpreter_main
$ ./bazel-bin/xls/dslx/interpreter_main \
    ./xls/examples/adler32/adler32.x
</code></pre></div>
<p>These two methods are equivalent.</p>
<h3 id="interpreters-execution-comparison">Execution comparison</h3>
<p>The DSL interpreter provides a flag, <code>--compare</code>, to implicitly compare its run
results to those of the IR-converted DSL functions. This helps "spot check"
consistency between IR and DSL execution (in addition to other methods used in
more generally in XLS, like the fuzzer).</p>
<p>The user may compare DSL execution to IR interpreter execution, IR JIT
execution, or not perform IR comparison at all.</p>
<div class="highlight"><pre><span></span><code><span class="gp">$ </span>./bazel-bin/xls/dslx/interpreter_main<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>./xls/examples/adler32/adler32.x<span class="w"> </span>--compare<span class="o">=</span>jit
<span class="gp">$ </span>./bazel-bin/xls/dslx/interpreter_main<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>./xls/examples/adler32/adler32.x<span class="w"> </span>--compare<span class="o">=</span>interpreter
<span class="gp">$ </span>./bazel-bin/xls/dslx/interpreter_main<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>./xls/examples/adler32/adler32.x<span class="w"> </span>--compare<span class="o">=</span>none
</code></pre></div>
<h2 id="interpreters-ir">IR</h2>
<p>XLS provides two means of evaluating IR - interpretation and native host
compilation (the
<a href="#ir_jit">JIT</a>). Both are
invoked in nearly the same way, via the
<a href="https://github.com/google/xls/tree/main/xls/tools/eval_ir_main.cc"><code>eval_ir_main</code></a> tool.</p>
<p><code>eval_ir_main</code> supports a wide number of use cases, but the most common end-user
case will be to run a sample through a design. To evaluate a sample (1.0 + 2.5)
on the add function in
<a href="https://github.com/google/xls/tree/main/xls/dslx/stdlib/float32.x">floating-point adder</a>,
one would run the following:</p>
<div class="highlight"><pre><span></span><code>bazel build -c opt //xls/tools:eval_ir_main
./bazel-bin/xls/tools/eval_ir_main    \
--input &#39;(bits[1]: 0x0, bits[8]:0x7F, bits[23]:0x0); (bits[1]: 0x0, bits[8]:0x80, bits[23]:0x200000)&#39;   \
./bazel-bin/xls/dslx/stdlib/float32_add.opt.ir
</code></pre></div>
<p>By default, this runs via the JIT. To use the interpreter, add the
<code>--use_llvm_jit=false</code> flag to the invocation.</p>
<p><code>eval_ir_main</code> supports a broad set of options and modes of execution. Refer to
its [very thorough] <code>--help</code> documentation for full details.</p>
<h2 id="interpreters-netlists">Netlists</h2>
<p>Finally, compiled netlists can also be interpreted against input samples via the
aptly-named
<a href="https://github.com/google/xls/tree/main/xls/tools/netlist_interpreter_main.cc"><code>netlist_interpreter_main</code></a>
tool. This tool currently only supports single sample evaluation (as illustrated
in the IR section above):</p>
<div class="highlight"><pre><span></span><code>bazel build -c opt //xls/tools:netlist_interpreter_main
./bazel-bin/xls/tools/netlist_interpreter_main \
  --netlist &lt;path to netlist&gt;
  --module  &lt;module to evaluate&gt;
  --cell_library[_proto] &lt;path to the module&#39;s cell library [proto]&gt;
  --inputs  &lt;input sample, as above&gt;
</code></pre></div>
<p>As XLS does not currently provide an sample/example netlist (TODO(rspringer)),
concrete values can't [yet] be provided here. The <code>--cell_library</code> flag merits
extra discussion, though.</p>
<p>During netlist compilation, a cell library is provided to indicate the
individual logic cells available for the design, and these cells are referenced
in the output netlist. The interpreter needs a description of these cells'
behaviors/functions, so the cell library must be provided here, as well. Many
cell libraries are very large (&gt; 1GB), and can thus incur significant processing
overhead at startup, so we also accept pre-processed cell libraries, as
<a href="https://github.com/google/xls/tree/main/xls/netlist/netlist.proto"><code>CellLibraryProto</code></a>
messages, that contain much-abridged cell descriptions. The
<a href="https://github.com/google/xls/tree/main/xls/netlist/function_extractor_main.cc"><code>function_extractor_main</code></a>
tool can automatically perform this extraction for
<a href="https://www.synopsys.com/community/interoperability-programs/tap-in.html">Liberty</a>-formatted
cell library descriptions.</p></section><h1 class='nav-section-title-end'>Ended: Tools</h1>
                        <h1 class='nav-section-title' id='section-development'>
                            Development <a class='headerlink' href='#section-development' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="contributing"><h1 id="contributing-how-to-contribute">How to Contribute</h1>
<p>We'd love to accept your patches and contributions to XLS. We recommend filing
an issue for back-and-forth discussion on implementation strategy before sending
a PR. Also, note the community guidelines below.</p>
<h2 id="contributing-community-guidelines">Community Guidelines</h2>
<p>This project follows
<a href="https://opensource.google/conduct/">Google's Open Source Community Guidelines</a>.</p>
<h2 id="contributing-contributor-license-agreement">Contributor License Agreement</h2>
<p>Contributions to this project must be accompanied by a Contributor License
Agreement (CLA). You (or your employer) retain the copyright to your
contribution; this simply gives us permission to use and redistribute your
contributions as part of the project. Head over to
<a href="https://cla.developers.google.com/">https://cla.developers.google.com/</a> to see your current agreements on file or
to sign a new one.</p>
<p>You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it
again.</p>
<h2 id="contributing-code-style">Code style</h2>
<p>When writing code contributions to the project, please make sure to follow the
style guides:
The <a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>
and the
<a href="https://google.github.io/styleguide/pyguide.html">Google Python Style Guide</a>.
There are a few small
<a href="https://google.github.io/xls/xls_style/">XLS clarifications</a> for local style on
this project where the style guide is ambiguous.</p>
<h2 id="contributing-code-reviews">Code reviews</h2>
<p>All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult
<a href="https://help.github.com/articles/about-pull-requests/">GitHub Help</a> for more
information on using pull requests.</p>
<h3 id="contributing-pull-request-style">Pull Request Style</h3>
<p>We ask contributors to squash all the commits in the PR into a single one, in
order to have a cleaner revision history.</p>
<p>Specifically, when you initially send a PR, please ensure it has a single
commit. <strong>If</strong> you'd like to address review comments by <em>adding</em>
commits,<sup id="contributing-fnref:why-add"><a class="footnote-ref" href="#contributing-fn:why-add">1</a></sup> please be sure to squash them into one again once the PR is
approved (though squashing continuously is also acceptable).</p>
<p>Generally, squashing to a single commit can be accomplished by:</p>
<div class="highlight"><pre><span></span><code><span class="go">proj/xls$ # Here we assume origin points to google/xls.</span>
<span class="go">proj/xls$ git fetch origin main</span>
<span class="go">proj/xls$ git merge-base origin/main my-branch-name  # Tells you common ancesor COMMIT_HASH.</span>
<span class="go">proj/xls$ git reset --soft $COMMIT_HASH</span>
<span class="go">proj/xls$ git commit -a -m &quot;My awesome squashed commit message!!!1&quot;</span>
<span class="go">proj/xls$ # Now we can more easily rebase our squashed commit on main.</span>
<span class="go">proj/xls$ git rebase origin/main</span>
</code></pre></div>
<p>Rebased branches can be pushed to their corresponding PRs with <code>--force</code>.</p>
<p>See also <a href="https://stackoverflow.com/questions/17354353/git-squash-all-commits-in-branch-without-conflicting">this Stack Overflow
question</a>.</p>
<h2 id="contributing-rendering-documentation">Rendering Documentation</h2>
<p>XLS uses <a href="https://www.mkdocs.org/">mkdocs</a> to render its documentation, and
serves it via GitHub pages at <a href="https://google.github.io/xls">https://google.github.io/xls</a>. To render
documentation locally as a preview, you can set up mkdocs as follows:</p>
<div class="highlight"><pre><span></span><code><span class="go">proj/xls$ mkvirtualenv xls-mkdocs-env</span>
<span class="go">proj/xls$ pip install mkdocs-material mkdocs-exclude mdx_truly_sane_lists mkdocs-print-site-plugin</span>
<span class="go">proj/xls$ mkdocs serve</span>
</code></pre></div>
<p>This will start a local server that you can browse to and that will update the
documentation on the fly as you make changes.</p>
<p>Note that the <code>mkvirtualenv</code> command assumes you're using
<a href="https://virtualenvwrapper.readthedocs.io/en/latest/index.html">virtualenvwrapper</a>
to manage your Python environment. You'll need to adjust these instrutions if
you're doing something different. That can include explicitly adding <code>mkdocs</code> to
your path, if locally installed Python binaries aren't available by default.</p>
<h3 id="contributing-dsl-snippets-in-documentation">DSL snippets in documentation</h3>
<p>There are a few different language annotations we use in different
circumstances in the Markdown docs:</p>
<ul>
<li><code>dslx</code>: A full code block that should be parsed/typechecked/tested.</li>
<li><code>dslx-snippet</code>: A fragment that should be syntax highlighted, but not
  parsed/typechecked/tested.</li>
<li><code>dslx-bad</code>: An example of something that we expect to produce an error
  when parsing/typechecking/testing.</li>
</ul>
<p>GitHub issue <a href="https://github.com/google/xls/issues/378">google/xls#378</a> tracks
a script that does the parse/typecheck/test that ensures our documentation is
up to date and correct.</p>
<h3 id="contributing-github-issue-t-shirt-size-estimate-labels">GitHub Issue "T-Shirt Size" Estimate Labels</h3>
<p>We attempt to employ some lightweight processes for task size estimation for the
GitHub issues in the XLS repository, as a way of making tasks available that fit
for available development time as well as gut checking, if something takes
longer than we expected, why and can we do things to mitigate the surprising
amount of time required going forward.</p>
<p>There's a practice of marking issues with "t-shirt sizes" for development tasks.
An issue can be XS, S, M, L, XL, these are given in the <a href="https://github.com/google/xls/labels?q=estimate">"estimate"
labels</a>:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Abbreviation</th>
<th style="text-align: center;">Time Scale</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">eXtra Small</td>
<td style="text-align: center;">XS</td>
<td style="text-align: center;">~few hours</td>
</tr>
<tr>
<td style="text-align: center;">Small</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">~a day</td>
</tr>
<tr>
<td style="text-align: center;">Medium</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">~1-3 days</td>
</tr>
<tr>
<td style="text-align: center;">Large</td>
<td style="text-align: center;">L</td>
<td style="text-align: center;">~a week</td>
</tr>
<tr>
<td style="text-align: center;">eXtra Large</td>
<td style="text-align: center;">XL</td>
<td style="text-align: center;">~multi-week</td>
</tr>
</tbody>
</table>
<p>These are not "load bearing", just to note expectation. Generally the
assumption is "time expected for a person familiar with this matter / part of
the code base", so developers that would ramp on an issue would require more
time than is indicated by the label. Feel free to change the label at will,
ideally by providing a helpful explanation for why/how the estimate came to
change.</p>
<div class="footnote">
<hr />
<ol>
<li id="contributing-fn:why-add">
<p>Adding commits preserves the GitHub code review history and makes it
  easier to review incremental changes, but causes an additional "round trip"
  with the reviewer for the final squash after approval, so there is a small
  procedural tradeoff.&#160;<a class="footnote-backref" href="#contributing-fnref:why-add" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><section class="print-page" id="xls_style"><h1 id="xls_style-xls-style-guide">XLS Style Guide</h1>
<p>The Google style guides recommend enforcing local consistency where stylistic
choices are not predefined. This file notes some of the choices we make locally
in the XLS project, with the relevant Google style guides
(<a href="https://google.github.io/styleguide/cppguide.html">C++</a>,
<a href="https://google.github.io/styleguide/pyguide.html">Python</a>) as their bases.</p>
<h2 id="xls_style-c">C++</h2>
<ul>
<li>Align the pointer or reference modifier token with the type; e.g. <code>Foo&amp;
    foo = ...</code> instead of <code>Foo &amp;foo = ...</code>, and <code>Foo* foo = ...</code> instead of <code>Foo
    *foo= ...</code>.</li>
</ul>
<ul>
<li>Use <code>/*parameter_name=*/value</code> style comments if you choose to annotate
    arguments in a function invocation. <code>clang-tidy</code> recognizes this form, and
    provides a Tricorder notification if <code>parameter_name</code> is mismatched against
    the parameter name of the callee.</li>
</ul>
<ul>
<li>Prefer <code>int64_t</code> over <code>int</code> to avoid any possibility of overflow.</li>
</ul>
<ul>
<li>Always use <code>Status</code> or <code>StatusOr</code> for any error that a user could encounter.</li>
</ul>
<ul>
<li>Other than user-facing errors, use <code>Status</code> only in exceptional situations.
    For example, <code>Status</code> is good to signal that a required file does not exist
    but not for signaling that constant folding did not constant fold an
    expression.<p>See <a href="#xls_style-how-heavyweight-is-statusor">how heavyweight is StatusOr</a> for more
  details on thinking about the costs involved.</p>
</li>
</ul>
<ul>
<li>Internal errors for conditions that should never be false can use <code>CHECK</code>,
    but may also use <code>Status</code> or <code>StatusOr</code>.</li>
</ul>
<ul>
<li>Prefer to brace single-statement blocks. Because the <code>XLS_ASSIGN_OR_RETURN</code>
    macro expands into multiple statements, this can cause problems when using
    unbraced single-statement blocks. Instead of XLS developers needing to think
    about individual cases of single statement blocks, we brace all single
    statement blocks.</li>
</ul>
<ul>
<li>Prefer using <code>XLS_ASSIGN_OR_RETURN</code> / <code>XLS_RETURN_IF_ERROR</code> when
    appropriate, but when binding a <code>StatusOr</code> wrapped value prefer to name it
    <code>thing_or</code> so that it can be referenced without the wrapper as <code>thing</code>; e.g.<div class="highlight"><pre><span></span><code>absl::StatusOr&lt;Thing&gt; thing_or = f();
if (!thing_or.ok()) {
  // ... handling of the status via thing_or.status() and returning ...
}
const Thing&amp; thing = thing_or.value();
</code></pre></div>
</li>
</ul>
<ul>
<li>Prefer <code>CHECK</code> to <code>DCHECK</code>, except that <code>DCHECK</code> can be used to verify
    conditions that it would be too expensive to verify in production, but that
    are fast enough to include outside of production.</li>
</ul>
<ul>
<li>Use <code>QCHECK</code> and <code>LOG(QFATAL)</code> during program startup when verifying startup
    parameters (i.e., flags); prefer <code>CHECK</code> and <code>LOG(FATAL)</code> in all other
    circumstances, as the <code>Q</code> variants suppress <code>atexit</code> handling (including
    <code>--cpu_profile</code>).</li>
</ul>
<ul>
<li>Follow the C++ style guide for capitalization guidelines; however, in the
    somewhat ambiguous case of I/O (short for Input/Output, which we use often),
    the slash counts as internal spacing and therefore the capitalization we use
    is <code>IO</code>, as in <code>WrapIO</code> or <code>StreamingIOReader</code>.</li>
</ul>
<ul>
<li>Prefer to use the <code>XLS_FRIEND_TEST</code> macro vs friending manually-mangled test
    names.<p>At times it can be useful to test unit test a private/protected member of a
  class, and the <code>XLS_FRIEND_TEST</code> macro makes this possible. Note that the
  test case must live outside an unnamed namespace in the test file for the
  "friending" to work properly.</p>
</li>
</ul>
<ul>
<li>For simple const accessors, for the sake of consistency in the code base,
    and a weak preference towards the benefits of information hiding, prefer to
    return view types over the apparent type of the member; e.g.<div class="highlight"><pre><span></span><code>class MyClass {
 public:
  // This return type is preferrable to `const std::vector&lt;uint64_t&gt;&amp;`.
  absl::Span&lt;const uint64_t&gt; values() const { return values_; }

 private:
  std::vector&lt;uint64_t&gt; values_;
};
</code></pre></div>
</li>
</ul>
<ul>
<li>Follow the
    <a href="https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_">style guide's</a>
    decision to avoid RTTI. In practice, this means <code>down_cast&lt;&gt;</code> should be used
    instead of <code>dynamic_cast&lt;&gt;</code>. However, the style guide says to avoid
    hand-implementing RTTI-like workarounds. The DSLX and XLScc frontends are
    places where avoiding RTTI would require implementing workarounds that end
    up looking a lot like RTTI, so <code>dynamic_cast&lt;&gt;</code> is common and accepted for
    those parts of the codebase. Elsewhere, especially with IR <code>Node</code> types,
    <code>down_cast&lt;&gt;</code> should be used instead.</li>
</ul>
<ul>
<li>Prefer <code>std::string_view</code> to <code>absl::string_view</code>. <code>absl::string_view</code> mainly
    differs from <code>std::string_view</code> in construction from nullptr, which our
    usage/callers do not depend upon. This decision lets us switch over to the
    more consistent end-state sooner. Although the style guide recommends we
    prefer <code>absl::string_view</code> for now, the rationale for why does not really
    apply to us and their target end state is clear.</li>
</ul>
<ul>
<li>XLS code is often written in a functional (i.e. separating functions from
    the [ideally immutable] structs they operate on) and layered style, which
    leads to <code>_utils.h</code> style translation units that layer on and compose
    functionality. Prefer the suffix <code>_utils.h</code> for these, vs <code>_helpers.h</code> or
    other alternatives.</li>
</ul>
<ul>
<li>Static member functions should be used sparingly, generally only for
    factories that call a private constructor. We prefer to document
    implementations with a <code>/* static */</code> comment as a reminder to readers (and
    writers that there is no <code>this</code> available). Comments are not an ideal way to
    mark this kind of information, but there should be a small number of these
    functions and as factories it is unlikely the static qualifier will be
    dropped in the future to put the comments out of sync.</li>
</ul>
<ul>
<li>We prefer <code>absl::visit</code> over <code>std::visit</code> as it is reportedly higher
    performance.</li>
</ul>
<h3 id="xls_style-functions">Functions</h3>
<ul>
<li>Short or easily-explained argument lists (as defined by the developer) can
    be explained inline with the rest of the function comment. For more complex
    argument lists, the following pattern should be used:<div class="highlight"><pre><span></span><code>// &lt;Function description&gt;
// Args:
//   arg1: &lt;arg1 description&gt;
//   arg2: &lt;arg2 description&gt;
//   ...
</code></pre></div>
</li>
</ul>
<h3 id="xls_style-ir-nodes">IR nodes</h3>
<h4 id="xls_style-class-hierarchy-and-oop-design">Class Hierarchy and OOP Design</h4>
<p>A frequently asked question about XLS's design is how the IR class hierarchy
gels with Google style guide recommendations. This section is intended to
provide a rationale for "tagging" leaf node types and for using
<code>node-&gt;Is&lt;NodeType&gt;()</code> and <code>switch (node-&gt;op())</code> to form categories of node
types instead of a class inheritance taxonomy.</p>
<p>The base type <code>Node</code> encapsulates an element that takes input operands and
produces an output, along with some metadata like type, name, and references to
source locations. Each IR node (e.g. <code>add</code>, <code>send</code>, <code>concat</code>, etc.) extends
directly from <code>Node</code>.</p>
<p>Each <code>Node</code> defines <code>op()</code> and <code>Is&lt;NodeType&gt;()</code> methods which are more
performant alternatives to C++'s RTTI. For example,</p>
<div class="highlight"><pre><span></span><code>if (node-&gt;Is&lt;Send&gt;()) {
  return node-&gt;As&lt;Send&gt;()-&gt;channel_id();  // As&lt;Send&gt;() is down_cast&lt;Send*&gt;()
}
</code></pre></div>
<p>or</p>
<div class="highlight"><pre><span></span><code>switch (node-&gt;op()) {
  case Op::kSend:
    return down_cast&lt;Send*&gt;(node)-&gt;channel_id();
  // case Op:: ...
}
</code></pre></div>
<p>are common patterns on IR nodes.</p>
<p>In many contexts, this code would be a cry for better abstractions- some
reasonable ideas include:</p>
<ol>
<li>A <code>virtual std::optional&lt;int64_t&gt; Node::channel_id()</code> (or
    <code>absl::StatusOr&lt;int64_t&gt;</code>) implementation.</li>
<li>A subclass or mixin trait like <code>ChannelNode</code> that extends <code>Node</code> for <code>Send</code>
    to derive.</li>
<li>A visitor that implements similar functionality outside of the class
    hierarchy.</li>
</ol>
<p>These ideas are generally not a good fit for IR nodes. The first idea's main
problem is that there are a lot of node types and the base class will become
huge if it needs to contain every property of each type of node. Furthermore,
the base class will be difficult to reason about without more structure- e.g.
does a node with a <code>channel_id</code> sometimes, always, or never also have a
<code>predicate</code>?</p>
<p>The second idea seems to address the problems of the first, but it is not clear
how to design a useful type hierarchy for IR nodes. The subset of nodes we care
about is very context dependent. The examples above invite a <code>ChannelNode</code>
abstraction, but other places in the code might care about unary vs. n-ary ops,
or ops that produce bare values vs. tuples, or some other way to group nodes. We
can find ourselves facing the first idea's complexity explosion if we make a
mixin trait for each pass, and there aren't good ways to inject mixin traits for
each compilation unit.</p>
<p>The third idea of using a visitor (or, similarly, a typeclass) is used in the
XLS codebase at times, but mostly where there's some well-defined behavior for
most kinds of nodes. If you want to pluck out an ad-hoc subset of nodes, you
need to make a new kind of visitor for that subset and it ends up being similar
to the code above. In the limit, you might need all arbitrary combinations which
will lead to too many visitor types to maintain centrally.</p>
<p>Using <code>node-&gt;Is&lt;NodeType&gt;()</code> or <code>switch (node-&gt;op())</code> are concise and readable
ways for the common task of operating on a new category of nodes. The typical
OOP tools we'd often use instead don't map well to the needs of an IR, so we
discourage adding to the base type or type hierarchy of IR nodes. We encourage
gathering categories that are reused in
<a href="https://github.com/google/xls/tree/main/xls/ir/node_util.h">node_util.h</a>.</p>
<p>It's also worth noting that <code>node-&gt;op()</code>, <code>node-&gt;Is&lt;NodeType&gt;()</code>,
<code>node-&gt;As&lt;NodeType&gt;()</code>, and <code>down_cast&lt;NodeType*&gt;(node)</code> are more performant
than C++ RTTI and <code>dynamic_cast&lt;&gt;</code>. C++ RTTI is not designed to be cheap and if
we used <code>dynamic_cast&lt;&gt;</code> instead of our own tags + <code>down_cast&lt;&gt;</code>, we expect that
would perform significantly worse. Performance is not the primary rationale for
the design decision discussed above, but the knock-on performance effects
further support the decision.</p>
<h4 id="xls_style-passing-node-types">Passing Node Types</h4>
<ul>
<li>Unlike most data, IR elements should be passed as non-const pointers, even
    when expected to be const (which would usually indicate passing them as
    const references). Experience has shown that IR elements often develop
    non-const usages over time. Consider the case of IR analysis passes - those
    passes themselves rarely need to mutate their input data, but they build up
    data structures whose users often need to mutate their contents. In
    addition, treating elements as pointers makes equality comparisons more
    straightforward (avoid taking an address of a reference) and helps avoid
    accidental copies (assigning a reference to local, etc.). Non-const pointer
    usage propagates outwards such that the few cases where a const reference
    could <em>actually</em> be appropriate become odd outliers, so our guidance is that
    IR elements should uniformly be passed as non-const pointers.</li>
</ul>
<ul>
<li>A corollary to the above is that <code>nullptr</code> is generally not a valid input to
    functions taking IR elements. When an IR element is optional, we recommend
    explicitly using <code>std::optional&lt;T*&gt;</code>. We deviate from the style guide here
    because for IR elements <code>T*</code> sometimes means <code>const T&amp;</code>, <code>T&amp;</code>, or just <code>T</code>
    in addition to <code>T*</code>, but which is not apparent from the signature. However,
    using <code>nullptr</code> for IR element types is OK when the usage is fully
    encapsulated.</li>
</ul>
<h2 id="xls_style-protocol-buffers">Protocol buffers</h2>
<ul>
<li>Prefer to use
    <a href="https://developers.google.com/protocol-buffers/docs/proto3#simple">proto3</a>
    specifications in all new protocol buffer files.</li>
</ul>
<h2 id="xls_style-faq">FAQ</h2>
<h3 id="xls_style-how-heavyweight-is-statusor">How heavyweight is <code>StatusOr</code>?</h3>
<p>What follows is the <strong>general guidance on how absl::StatusOr is used</strong> -- it is
used extensively throughout the XLS code base as an error-style indicator object
wrapper, so it is important to understand the mental model used for its cost.</p>
<p>Consider cost wise that: a) creating an <strong>ok</strong> <code>StatusOr</code> is cheap, b) creating
a <strong>non-ok</strong> <code>StatusOr</code> is expensive (that is, imagine the non-ok <code>Status</code>
within a <code>StatusOr</code> is the expensive part).</p>
<p>The implication being: if there's an API where "not found" is a reasonable
outcome, prefer <code>std::optional&lt;&gt;</code> as a return value to indicate that / go with
the grain of cost.</p>
<p>Something like a filesystem API would be a classic example -- where you
shouldn't be rooting around looking for files that aren't there -- so a
not-found <code>absl::StatusOr</code> result would be fine to use.</p>
<p>A good potential mental model is to imagine the program may run with logging of
a traceback for every non-ok status that is created. (This is related to a
debugging capability in Google internally called
<code>--util_status_save_stack_trace</code> that captures backtraces when error <code>Status</code>es
are created.) Ideally, with such a logging flag turned on, the screen wouldn't
fill up with "non error tracebacks", only tracebacks from events where something
really went wrong.</p></section><section class="print-page" id="adding_ir_operation"><h1 id="adding_ir_operation-adding-a-new-ir-operation">Adding a new IR operation</h1>
<p>XLS has about 60 different
<a href="https://github.com/google/xls/tree/main/xls/ir/op_specification.py">opcodes</a> and
periodically new ones are added to extend functionality or improve the
expressiveness of the IR. XLS has many different components and adding a new
opcode involves changes to numerous places in the code. These changes, some of
which are optional, are described below:</p>
<ol>
<li>
<p>Add operation to
    <a href="https://github.com/google/xls/tree/main/xls/ir/op_specification.py">op_specification.py</a></p>
<p>Opcodes and IR node classes are defined in the file <code>op_specification.py</code>.
  This Python code generates the C++ header and source files which define
  opcodes (<code>op.h</code> and <code>op.cc</code>) and the IR node type hierarchy (<code>nodes.h</code> and
  <code>nodes.cc</code>). Every opcode has an associated node subclass derived from the
  <code>xls::Node</code> base class. Some opcodes such as <code>Op::kArray</code> have their own
  class (<code>Array</code>) because of the unique structure of the operation. Other
  opcodes such as the logical operations (<code>Op::kAnd</code>, <code>Op::kOr</code>, etc) share a
  common base class (<code>BinOp</code>).</p>
<p>The first step to adding a new operations is to add an opcode, and
  potentially a new Node class, in <code>op_specification.py</code>. After adding the
  opcode numerous files will fail to build because switch statements over the
  set of opcodes will no longer be exhaustive. Add the necessary cases to each
  switch statement. The exact code in each case will, of course, be
  operation-specific. Initially the implementation might return an
  <code>absl::UnimplementedError</code> status until later changes add proper support for
  the new operation.</p>
<p>As part of this change the new operations needs to be added to the DFS
  visitor class <code>DfsVisitor</code> by adding a handler method. This class is used
  throughout XLS to traverse the IR. This will also adding an implementation
  of this new method to many of the subclasses derived from <code>DfsVisitor</code>.</p>
<p><a href="https://github.com/google/xls/commit/5fd739abe3e28f4198e07d45987522b12ebdf051">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/ir/verifier.h">IR Verifier</a></p>
<p>The IR verifier checks numerous invariants about the IR including
  operation-specific properties such as the number and type of operands. Add
  an additional handler method for the new operand and add appropriate
  operation-specific checks.</p>
<p><a href="https://github.com/google/xls/commit/5fd739abe3e28f4198e07d45987522b12ebdf051">(Code example)</a></p>
</li>
<li>
<p><a href="https://google.github.io/xls/ir_semantics/">IR Semantics document</a></p>
<p>Describe the semantics and syntax of the new operation in the IR semantics
  document.</p>
<p><a href="https://github.com/google/xls/commit/5fd739abe3e28f4198e07d45987522b12ebdf051">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/ir/function_builder.h">Function builder</a></p>
<p>The function builder is the primary API for constructing IR. If appropriate,
  add a method to the <code>BuilderBase</code> class which adds an IR node of the new
  type to a function.</p>
<p><a href="https://github.com/google/xls/commit/eb12ef77d51e2d65f4295e80ffa944043f021b2f">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/ir/ir_parser.h">IR Parser</a></p>
<p>Add support for parsing of the new operation. The parser tests typically
  send a snippet of IR with the operation through the parser and text
  serialization and verifies that the output matches the original. Supporting
  the new operation may require modifying the <code>xls::Node::ToString</code> method to
  emit any special fields required by the operation.</p>
<p><a href="https://github.com/google/xls/commit/eb12ef77d51e2d65f4295e80ffa944043f021b2f">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/interpreter/ir_interpreter.h">IR Interpreter</a></p>
<p>The IR interpreter has C++ implementations of all of the operations.
  Implement the new operation and add tests.</p>
<p><a href="https://github.com/google/xls/commit/eb12ef77d51e2d65f4295e80ffa944043f021b2f">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/ir/ir_matcher.h">IR Matcher</a></p>
<p>The IR matcher is used in tests to enable easy matching of IR expressions.
  For example, the following tests that the return value of a function is the
  parameter <code>x</code> plus the parameter <code>y</code>:</p>
<div class="highlight"><pre><span></span><code>EXPECT_THAT(f-&gt;return_value(), m::Add(m::Param(&quot;x&quot;, m::Param(&quot;y&quot;)));
</code></pre></div>
<p>If the new operation has no named attributed, IR matcher support is
  typically a single line using the macro <code>NODE_MATCHER</code>. Otherwise, a custom
  matcher should be added to enable matching the attribute as well.</p>
<p><a href="https://github.com/google/xls/commit/eb12ef77d51e2d65f4295e80ffa944043f021b2f">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/jit/ir_builder_visitor.h">LLVM JIT</a></p>
<p>The LLVM JIT enables fast simulation of the XLS IR. The JIT constructs LLVM
  IR for each XLS operation which is then optimized by LLVM and runs natively
  on the host. Implement the new operation in the <code>FunctionBuilderVisitor</code>
  class.</p>
<p><a href="https://github.com/google/xls/commit/eb12ef77d51e2d65f4295e80ffa944043f021b2f">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/codegen/node_expressions.h">Code generation</a></p>
<p>In XLS "code generation" refers to the generation of (System)Verilog from
  XLS IR. If the operation can be emitted as a single Verilog expression, then
  likely support for the new operation can be added to <code>node_expressions.h</code>,
  otherwise if the implementation requires multiple statements then support is
  added to <code>module_builder.h</code>.</p>
<p><a href="https://github.com/google/xls/commit/ef08b552ac3738eb98484cc46a7396c89f7cbb7d">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/ir/abstract_evaluator.h">Abstract evaluator</a></p>
<p>The abstract evaluator enables evaluation of the XLS IR using different
  evaluation systems than Boolean algebra. Users define the semantics of
  simple logical operations such as and, or, and not. Then, the abstract
  evaluator interprets an IR function using these rules. One example use case
  is ternary logic which uses three logic values (true, false, and unknown)
  rather than two (true and false) Ternary evaluation is used by the optimizer
  to discover statically known bits in the IR graph. The abstract evaluator
  can also be used for translation of the IR to other representations. For
  example, IR is translated to the Z3 solver representation for formal
  verification using the abstract evaluator.</p>
<p>If appropriate, the operation should be implemented in
  <code>AbstractNodeEvaluator</code> by providing an implementation which decomposes the
  operation into fundamental logical operations.</p>
<p><a href="https://github.com/google/xls/commit/bda129fed73de323574d7955292753187af7bb20">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/solvers/z3_ir_translator.h">Z3 solver</a></p>
<p>The Z3 solver is used for theorem proving and logical equivalence checking
  between the IR in different stages of compilation and the netlist. To enable
  this functionality for the new operation, add a lowering of the operation to
  Z3's internal representation.</p>
<p><a href="https://github.com/google/xls/commit/bda129fed73de323574d7955292753187af7bb20">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/delay_model">Delay model</a></p>
<p>In order to generate efficient circuits which meet timing requirement, XLS
  models the delay (in picoseconds) of each operation for different process
  technology nodes. This model is constructed by characterizing the process
  node using an EDA tool to synthesize the circuit and estimate delay.
  Typically, a new operation will need to be characterized by running numerous
  permutations of the operation (e.g., with different bit widths) through a
  synthesis flow, extracting delay, and building a delay model.</p>
<p><a href="https://github.com/google/xls/commit/19bb886a1471b074159fcbf95fccce17fba40031">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/dslx">DSLX frontend</a></p>
<p>Most ops are used by the DSLX frontend in the lowering of DSLX to IR. The
  operation may be exposed directly as a builtin (or other operation) or used
  in the lowering of other AST nodes. In any case, some changes to the DSLX
  frontend will likely be necessary.</p>
<p><a href="https://github.com/google/xls/commit/feeac2c4c0bcc73b529cb0c4a976abae47f96730">(Code example)</a></p>
</li>
<li>
<p><a href="https://github.com/google/xls/tree/main/xls/fuzzer">Fuzzer</a></p>
<p>The fuzzer generates random DSLX functions and random inputs to check and
  compare different parts of XLS, for example checking that un-optimized and
  optimized IR give the same outputs when interpreted. If there is an
  operation in DSLX that maps nicely onto the newly added operation, the
  fuzzer can be modified to generate functions with DSLX that exercise the
  new operation. This is done by adding a handler to <code>AstGenerator</code>. See
  <a href="#fuzzer">here</a> for
  more details on how the fuzzer works and how to run it.</p>
<p><a href="https://github.com/google/xls/commit/c09339f3b0c147031eadd626d1a856a860031e05">(Code example)</a></p>
</li>
<li>
<p>Operation-specific optimizations</p>
<p>Typically, a new operation provides optimization opportunities unique to the
  node. The details, of course, will be vary for different operations.
  However, typically these are at least several easy optimizations which can
  be implemented.</p>
</li>
</ol></section><section class="print-page" id="ideas_and_projects"><h1 id="ideas_and_projects-ideas-and-projects">Ideas and Projects</h1>
<p>This document lists a few sample ideas, projects, and research ideas, to help
get started on contributing to XLS.</p>
<h2 id="ideas_and_projects-programming-languages">Programming Languages</h2>
<h3 id="ideas_and_projects-xls-new-frontends">XLS New Frontends</h3>
<p>One of XLS' primary core focus areas was defining a compiler intermediate
representation that is powerful enough to express all required concepts, but
minimal enough to make it easy to target from other, new, or modified
programming languages. We are focusing on a functional domain-specific language,
but others are possible. There is work to target the IR from C++. There are many
other research systems out there with their own respective DSLs and other input
mechanisms. It would be interesting to connect those to allow comparisons. An
embedded DSL in Python could be developed, which is straightforward as the IR's
builder interfaces are already exported to Python.</p>
<h2 id="ideas_and_projects-core-xls">Core XLS</h2>
<h3 id="ideas_and_projects-ml-for-delay-estimation">ML for Delay Estimation</h3>
<p>We currently estimate the delay of ops and op combos via benchmarks and the
theory of logical efforts. In principle we are trying to guess what the
commercial toolchains will do. This is a problem that seems to be just made for
ML, especially for new technology nodes or FPGA devices.</p>
<h3 id="ideas_and_projects-delay-estimation-for-a-variety-of-devices">Delay Estimation for a variety of Devices</h3>
<p>We are focusing on only a small number of FPGAs and very specific ASIC Flows.
For the lager community out there we should add many more models, improve
automation of deriving a delay model, and/or try ML based approaches.</p>
<h3 id="ideas_and_projects-delay-estimation-for-implicit-broadcasts">Delay Estimation for Implicit Broadcasts</h3>
<p>HLS often creates implicit broadcasts (wire load / fan out / wiring congestion)
in unrolled loops, deep pipelines, large memory blocks, etc. that lead to
frequency bottlenecks. Modeling these broadcasts in the delay model can help
mitigate or even completely solve such problems.</p>
<h3 id="ideas_and_projects-z3">Z3</h3>
<p>We use Z3 for our logical equivalence checking, eg., to check that the optimized
and unoptimized IR have the same semantics. With a solver like this in place,
there are many more opportunities to apply it or make it more practical, for
example.</p>
<ul>
<li>(Automatic) Partitioning of the input IR to reduce per-phase problem space</li>
<li>Add / compare with other formal verification tools.</li>
<li>There are other alternatives, e.g. <a href="https://boolector.github.io/">Boolector</a></li>
<li>Use cases we haven't thought of yet.</li>
</ul>
<h3 id="ideas_and_projects-design-verification-flows">Design Verification Flows</h3>
<p>Provide mechanisms for "constrained random" approaches to hardware
verification -- either libraries to emulate capabilities of constraint-based
vector generation similar to UVM, or more automated approaches provided by
QuickCheck/Hypothesis.</p>
<h2 id="ideas_and_projects-implement-new-blocks-and-functions-in-xls">Implement new blocks and functions in XLS</h2>
<h3 id="ideas_and_projects-extend-xls-standard-library">Extend XLS standard library</h3>
<p>XLS has a small standard library which includes some basic utility functions and
some limited floating point support. Extending this library and developing more
complex functionality would improve the usability of XLS. Ideas:</p>
<ul>
<li>FP Libraries Implement libraries for important FP operations, modes, widths,
    with all the relevant parameters. BFloat libraries</li>
<li>Fixed point libraries, similar to above</li>
<li>Exploit FPGA hard macros and BRAMs</li>
</ul>
<p>XLS implementations of common hardware libraries - arbiters - counters -
encoders - fifos</p>
<h3 id="ideas_and_projects-three-stage-risc-v">Three-stage RISC-V</h3>
<p>Piccolo is a 3-stage RISC-V core. Implementation appears of reasonable size.</p>
<ul>
<li>IF: ISA / Instruction Fetch / Decode Unit</li>
<li>DM: Data Memory stage</li>
<li>WB: Write Back stage</li>
<li>ALU</li>
<li>add/sub unit, mul unit, shifter unit</li>
<li>PLIC / Platform Level Interrupts architecture</li>
<li>Cache Hierarchy with various sizes, associativity, and replacement policies</li>
<li>MMU and L1-Cache</li>
<li>CSRs</li>
<li>Register File</li>
</ul>
<h3 id="ideas_and_projects-support-for-systolic-arrays-as-a-parallel-pattern">Support for Systolic Arrays as a "Parallel Pattern"</h3>
<p>It is clear, especially in the domain of machine learning and signal processing,
that HLS will benefit from full support of 2D elements, such as systolic arrays
or specialized convolution engines. The idea here is to abstract these properly.
For example, one could add constructs to the IR, or we can extend the analysis
capabilities and add passes to construct them as needed. We also have to make
sure that the mechanisms are fully supported by all optimization and code
generation passes. This is a fascinating and wide-open research area and
intersects with the current work on concurrent blocks.</p>
<h3 id="ideas_and_projects-interoperability-with-other-languages-ffi">Interoperability with other languages, FFI</h3>
<p>Users may want to reuse building blocks written in other languages that are
pre-optimized. Support proper FFI. Instantiate external blocks by specifying
their properties in a way the scheduler can understand. Import type definitions
from system verilog descriptions e.g. as encoded in protobufs</p>
<h2 id="ideas_and_projects-xls-tools">XLS Tools</h2>
<h3 id="ideas_and_projects-visualization">Visualization</h3>
<p>XLS includes some minimal visualization and exploration tools. There is large
potential for tool builders to improve and add information, insights,
suggestions, etc.</p>
<h3 id="ideas_and_projects-source-correlation">Source Correlation</h3>
<p>It is always important to maintain a high level of productivity and utility for
a toolset like XLS provides. Source correlation, annotations, and many other
techniques are always improvable the enhance the debugging, visualization, and
also design verification experiences.</p>
<h3 id="ideas_and_projects-source-analysis">Source Analysis</h3>
<p>A linter/style checker for the DSL would be very helpful for users to write
high-quality HLS code.</p>
<h2 id="ideas_and_projects-xls-integration-with-other-tools">XLS Integration with other tools</h2>
<h3 id="ideas_and_projects-add-verilator-support-to-xls">Add Verilator support to XLS</h3>
<p>Verilator is a strong open-source (System)Verilog simulator. Currently XLS only
supports Icarus Verilog, a Verilog-only simulator. Verilator support in XLS will
provide much higher simulation performance and SystemVerilog support to open
source users. Unlike other simulators which can run testbench code, Verilator
only operates on synthesizable Verilog and emits C++ code for compilation and
execution. This unique flow needs to be integrating into XLS's simulation
framework.</p></section><section class="print-page" id="fpga_characterization"><h1 id="fpga_characterization-fpga-characterization">FPGA Characterization</h1>
<p>Note that right now the in-tree yosys and nextpnr-ice40 builds plugins aren't
registering properly, see
<a href="https://github.com/google/xls/issues/188">issue #188</a>. As a result, we have to
use out-of-tree <code>yosys</code> and <code>nextpnr-ice40</code> builds for the moment.</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt //xls/synthesis/yosys:yosys_server_main
$ ./bazel-bin/xls/synthesis/yosys/yosys_server_main \
    --yosys_path $(which yosys) \
    --nextpnr_path $(which nextpnr-ice40) \
    --synthesis_target=ice40 \
    --alsologtostderr
</code></pre></div>
<p>The above runs a gRPC service, so in another terminal pane, we run the
characterization driver:</p>
<div class="highlight"><pre><span></span><code>$ bazel run -c opt //xls/synthesis:timing_characterization_client_main
$ ./bazel-bin/xls/synthesis/timing_characterization_client_main \
    &gt; ./xls/delay_model/models/ice40.textproto
</code></pre></div>
<p>This produces a textual representation of the delay model protobuf.</p>
<h2 id="fpga_characterization-building-in-tree-binaries">Building In-Tree Binaries</h2>
<p>Note that these cannot currently be used for the above characterization flow,
see <a href="https://github.com/google/xls/issues/188">issue #188</a></p>
<p>Build <code>yosys</code> and <code>nextpnr-ice40</code>:</p>
<div class="highlight"><pre><span></span><code>$ bazel build -c opt @at_clifford_yosys//:yosys @nextpnr//:nextpnr-ice40
</code></pre></div></section>
                        <h2 class='nav-section-title' id='section-design-docs'>
                            Design Docs <a class='headerlink' href='#section-design-docs' title='Permanent link'>↵</a>
                        </h2>
                        <section class="print-page" id="design_docs-legalize_multiple_channel_ops_per_channel"><h1 id="design_docs-legalize_multiple_channel_ops_per_channel-legalize-multiple-channel-ops-per-channel">Legalize Multiple Channel Ops Per Channel</h1>
<div class="toc">
<ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-legalize-multiple-channel-ops-per-channel">Legalize Multiple Channel Ops Per Channel</a><ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-context">Context</a><ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-objective">Objective</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-background">Background</a></li>
</ul>
</li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-design">Design</a><ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-overview">Overview</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-minimum-viable-product">Minimum Viable Product</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-details">Details</a><ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-single-channel-operation-per-tick-with-true-predicate">Single Channel Operation per Tick with True Predicate</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-multiple-channel-operations-per-tick-with-true-predicate">Multiple Channel Operations per Tick with True Predicate</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-channel-operations-in-different-procs">Channel Operations in Different Procs</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-scheduling">Scheduling</a></li>
</ul>
</li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-long-term-enhancements">Long-Term Enhancements</a><ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-multi-proc-codegen">Multi-Proc Codegen</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-optimization-for-mutually-exclusive-operations">Optimization for Mutually Exclusive Operations</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-arbitrary-scheduling-of-multiple-channel-operations">Arbitrary Scheduling of Multiple Channel Operations</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-ir-level-testing-should-run-on-scheduled-ir">IR-level testing should run on scheduled IR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-alternatives-considered">Alternatives considered</a><ul>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-improve-proc-inlining">Improve Proc Inlining</a></li>
<li><a href="#design_docs-legalize_multiple_channel_ops_per_channel-use-a-proof-assistant-that-supports-induction">Use a proof assistant that supports induction</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>Written on 2023-05-02.</p>
<h2 id="design_docs-legalize_multiple_channel_ops_per_channel-context">Context</h2>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-objective">Objective</h3>
<p>Whenever an XLS channel has multiple sends/receives, the XLS compiler currently
relies on the mutual exclusion pass to merge these operations. If the operations
cannot be proven to be mutually exclusive or if they are not in the same token
level, it is an error and many legal programs fail to compile. The goal is to
compile more programs that have multiple sends/receives on the same channel.</p>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-background">Background</h3>
<p>One common way for the mutual exclusion pass to fail is with a pipelined loop:</p>
<div class="highlight"><pre><span></span><code>if (p) {
  send(chan, value0);
} else {
  #pragma hls_pipeline_init_interval 1
  for (int i = 0; i &lt; 4; i++) {
    send(chan, value1);
  }
}
</code></pre></div>
<p>The XLSCC frontend<sup id="fnref:1"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:1">1</a></sup> will make the for loop a separate proc with channels that
pass necessary state in and out. The "outside" proc will pause forward progress
until the loop proc completes, so the two sends are mutually exclusive. However,
after proc inlining, the predicates to the sends will be a function of the proc
state that requires induction to prove mutual exclusion. To see why this is,
it's helpful to understand how proc inlining works. The proc inlining pass
creates a new container proc that allows all the inlined procs to tick
simultaneously. This is implemented via an "activation network"- a series of
boolean values encoded in the proc state that follow the token network of each
proc. Each proc has a root activation that corresponds to the proc token
parameter- this root activation is initialized as true, and activations flow
down the network until something like a waiting blocking receive on an internal
channel occurs. When a side-effecting operation does not occur within a
container tick, all dependent operations will not be activated and will wait
until the next container tick. This allows inlined procs to independently make
progress on their execution. It also means that inlined proc ticks are decoupled
from container proc ticks.</p>
<p>Channel operations in different procs will have activations be a portion of
their predicates, but proving properties about these activations in general
requires reasoning across multiple proc ticks. The mutual exclusion pass is not
able to prove properties over time and will fail to merge the sends in the
example above.</p>
<p>Currently, XLS treats multiple channel operations on the same channel as an
error as a design choice to enforce that full throughput at II=1 is achievable.
As a result, compilation will fail. It is important to note that although this
problem exists for any channel, it is especially common when working with RAMs,
especially single-port RAMs. The example above could come from code like</p>
<div class="highlight"><pre><span></span><code>if (p) {
  mem[x] = value0;
} else {
  #pragma hls_pipeline_init_interval 1
  for (int i = 0; i &lt; 4; i++) {
    value1 += mem[(x + 1)%MEM_SIZE];
  }
}
</code></pre></div>
<p>Each memory access gets lowered to a pair of send/receives on a request and
response channel. For single-port RAMs, read and write channels will also be
merged. It is therefore critical for programs using RAMs that multiple
sends/receives work.</p>
<h2 id="design_docs-legalize_multiple_channel_ops_per_channel-design">Design</h2>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-overview">Overview</h3>
<p>Ultimately, we are asking the mutual exclusion pass to do too much. To merge
operations like the sends in the example above, analysis must prove arbitrarily
complex properties of the program, including those that change over time.
Instead of relying on mutual exclusion analysis, it seems better to allow
multiple sends and treat the mutually exclusive operations as a special case
that allows for optimization. Concretely, the proposal is:</p>
<ol>
<li>Do not merge mutually exclusive channel operations before scheduling.</li>
<li>
<p>When multiple channel operations occur on a channel, IR lowering should
    replace the channel for those operations with new internal channels. An
    adapter proc should be added that accepts multiple channel operations on the
    new "generated by the compiler pass" side and forwards them to the original
    IO channel.</p>
<p>1.  One adapter variant will be an arbiter. If multiple channel operations
      occur in a cycle, the pipeline stalls until they all complete. Priority
      for the adapter will be determined by token level. If operations that
      are not ordered with respect to each other activate at the same time, it
      will be an assertion failure. Optionally, the compiler can impose an
      arbitrary order to unordered operations (following the token ordering
      where one exists) via a topo sort.</p>
<p>1.  Another adapter variant will be a "mutex assumed" variant used only when
      the channel operations are mutually exclusive. The XLS→outside signals
      will be OR'd and the outside→XLS signals will be fanned out. An
      assertion will be added checking that at most one channel operation is
      active in a cycle<sup id="design_docs-legalize_multiple_channel_ops_per_channel-fnref:2"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:2">2</a></sup>.</p>
</li>
<li>
<p>These adapters should be separate procs and codegen'd as their own Verilog
    module. This hierarchy is useful for tracking the cost of the arbiter
    variant and facilitating later replacement of arbiter variants with mutex
    assumed variants. The MVP can initially inline the adapters until multi-proc
    codegen is supported.</p>
</li>
</ol>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-minimum-viable-product">Minimum Viable Product</h3>
<p>The goal is to support the example in the Background section (and similar
examples) ASAP. The steps roughly follow:</p>
<ol>
<li>Write a proc generator for the arbiter variant of adapter.</li>
<li>
<p>When there are multiple channel operations on the same channel, a scheduling
    pass<sup id="design_docs-legalize_multiple_channel_ops_per_channel-fnref:3"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:3">3</a></sup> will add new channels and an adapter. The pass will move the
    channel operations' channel ids over to the new channels and connect the
    adapter's send/recv to the original channel. New channels to send the
    predicate before the operation and receive a completion after the operation
    will be added and connected.</p>
<p>1.  The adapter will arbitrate between multiple operations in priority
      order.</p>
<p>2.  Priority order will be determined by token dependencies. The adapter
      will have runtime checks that all active receives are ordered with
      respect to each other. Optionally, impose an arbitrary order to
      unordered operations via a topo sort.</p>
<p>3.  Channel operations from different procs will be required to be mutually
      exclusive, enforced by a runtime check.</p>
<p>4.  Initially, use proc inlining on the adapter.</p>
</li>
<li>
<p>After the adapter is added and connected by the pass, scheduling constraints
    will only apply to the operation in the adapter. The original send/receives
    will be freely scheduled, although after inlining the predicate sends
    (before the operation) and completion receives (after the operation) will
    implicitly order the operations with respect to the scheduling constraint.</p>
</li>
</ol>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-details">Details</h3>
<p>This proposal suggests extending the current XLS behavior which are, roughly,
"multiple channel operations must be formally proven to be mutually exclusive
and on the same token level, and then must be merged into a single operation".
There are trade-offs in choosing how far to extend.</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-single-channel-operation-per-tick-with-true-predicate">Single Channel Operation per Tick with True Predicate</h4>
<p>One case is to allow multiple channel operations per proc tick, but require that
only one of them have a true predicate. The current XLS behavior requires the
operations to be on the same token level and to be formally proven to have
mutually exclusive predicates. This could be extended to not require formal
proof and instead provide a runtime check (assertion). This corresponds to the
mutex assumed adapter variant described earlier and is a very incremental
extension of the existing behavior. One problem with assuming all channel
operations are mutually exclusive (even if you can't prove it) is that they
aren't mutually exclusive. We could make it an error in the interpreter and JIT
to have multiple channel operations per tick, but it currently isn't an error
and seems potentially useful to allow eventually. There it seems like the
mutually exclusive case should be an optimization of the more general case where
multiple operations fire, and only applied when desired.</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-multiple-channel-operations-per-tick-with-true-predicate">Multiple Channel Operations per Tick with True Predicate</h4>
<p>When there are multiple channel operations per tick firing, there is a new
problem to consider: how to order the operations. There is no ambiguity when
there is a total ordering on operations. It would be safe for the MVP to require
a total ordering. However, the XLSCC frontend specifies token dependencies as
loosely as possible<sup id="design_docs-legalize_multiple_channel_ops_per_channel-fnref:4"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:4">4</a></sup>, so it is a normal occurrence for there not to be a
total ordering on channel operations.</p>
<p>If multiple channel operations aren't totally ordered, you can choose a static
or dynamic order. On a subset of operations with no ordering with respect to
each other, you could imagine choosing randomly or going round robin. However,
choosing a static order seems simplest for MVP, and dynamic options seem of
little utility. One way to choose this static order is to use the order given by
XLS's <code>TopoSort()</code><sup id="fnref:5"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:5">5</a></sup>.</p>
<p>An alternative to worrying about the order is to legalize channel operations by
adding a new channel per extra operation. This is equivalent to the current
approach without the adapter- instead, the adapter (if needed) becomes the
responsibility of the external integrator. This option might be useful in cases
where the adapter orders things based on the data (for memory traffic, you could
imagine performing all writes before all reads, or vice versa, and forwarding
data written in the previous cycle if read in the current cycle).</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-channel-operations-in-different-procs">Channel Operations in Different Procs</h4>
<p>Channel operations in different procs have no direct token relationship. There
is an ordering imposed by channel operations over control channels, but this
relationship is indirect. <code>TopoSort()</code> only operates on one proc or function at
a time.</p>
<p>We could require that multiple sends/receives occur within the same proc,
although XLSCC produces channel operations in different procs for the example
given at the start and many other interesting examples.</p>
<p>We could build a global token graph, where each proc's token parameter has an
edge to some root token and each proc's next token feeds into a global next
token (analogous to proc inlining). Edges will be added where procs send/receive
to each other on internal channels. Note that the analysis may be tricky in
cases where multiple parallel send/receives occur on these internal channels. It
may be desirable to disallow multiple channel operations on internal channels,
or have a variant of channel that disallows multiple channel operations to keep
analysis sane.</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-scheduling">Scheduling</h4>
<p>For MVP, it seems simplest to require all channel operations on a given channel
be scheduled in the same cycle. This will sometimes cause scheduling to fail and
may interact poorly with II&gt;1 passes, but is a useful starting point. Putting
channel ops on the same channel in different cycles could allow for better QoR
(especially with II&gt;1) than could be realized if channel ops were required to be
merged.</p>
<p>If channel operations on the same channel are scheduled in different cycles, the
adapters need to delay earlier channel operations until the last cycle
containing one of the multiple channel operations<sup id="design_docs-legalize_multiple_channel_ops_per_channel-fnref:6"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:6">6</a></sup><sup id="fnref:7"><a class="footnote-ref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fn:7">7</a></sup>.</p>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-long-term-enhancements">Long-Term Enhancements</h3>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-multi-proc-codegen"><a href="https://github.com/google/xls/issues/950">Multi-Proc Codegen</a></h4>
<p>The adapter procs should ideally be codegen'd as separate Verilog modules, which
will require multi-proc codegen.</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-optimization-for-mutually-exclusive-operations"><a href="https://github.com/google/xls/issues/951">Optimization for Mutually Exclusive Operations</a></h4>
<p>Post-codegen analysis may be needed to determine if operations are mutually
exclusive. For example, mutual exclusion properties may be data dependent and
depend on the context a block is instantiated in. Third party formal tools may
be useful in proving these properties.</p>
<p>Multi-proc codegen makes it straightforward to switch an adapter from
arbitrating to mutex assumed- generate both variants and have a Verilog config
set which variant should be used for each instance after the fact.</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-arbitrary-scheduling-of-multiple-channel-operations"><a href="https://github.com/google/xls/issues/952">Arbitrary Scheduling of Multiple Channel Operations</a></h4>
<p>Wavefront matching channel operations across cycles seems to mean that
scheduling channel operations in different cycles will not save anything. This
is because the extra state you need to delay a channel operation. If analysis
can determine that the wavefronts don't need to be matched (in general, this
could be data dependent!), then you could remove this extra state.</p>
<p>If wavefronts do need to be matched, care needs to be taken to drive channel
operations in the correct order in the presence of stalls.</p>
<h4 id="design_docs-legalize_multiple_channel_ops_per_channel-ir-level-testing-should-run-on-scheduled-ir"><a href="https://github.com/google/xls/issues/813">IR-level testing should run on scheduled IR</a></h4>
<p>The pass described here is a scheduling pass, and hence performed during
codegen. The priority chosen by the pass when there is not a total order on the
channel operations will impact program behavior, so ideally it would be
consistent when running IR JIT.</p>
<p>One way to resolve this is to combine IR opt + codegen into a single driver.
That can produce opt IR, scheduled IR, or RTL. Alternatively, you could make
scheduling its own distinct step, or move scheduling passes into opt and only do
block conversion and RTL conversion in codegen. Regardless, the IR jit should be
running the scheduled IR to ensure equivalent program behavior.</p>
<h2 id="design_docs-legalize_multiple_channel_ops_per_channel-alternatives-considered">Alternatives considered</h2>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-improve-proc-inlining">Improve Proc Inlining</h3>
<p>In practice, many of the failures we've seen in identifying mutually exclusive
channel operations are a result of proc inlining. Proc inlining moves channel
operation predicates into the proc state, but this doesn't seem necessary for
many of the examples that fail to compile.</p>
<p>The XLSCC frontend generally produces procs that transfer execution to one proc
at a time. They generally look something like:</p>
<div class="highlight"><pre><span></span><code>arguments = receive(input_channel, pred=is_init_state);
state = WORK_STATE;
// do stuff
send(output_channel, pred=is_done_state);
if (is_done_state) {
  state = INIT_STATE;
}
</code></pre></div>
<p>In this case, the proc activation state can be condensed into something like a
program counter. Each value of the program counter would correspond to a
different inlined proc's activation and channel operations would have their
predicates be strengthened with <code>p' = p &amp; (pc == MY_PROC_ID)</code>. As a result,
channel operations in different inlined procs would be trivially mutually
exclusive.</p>
<p>The analysis to determine if this optimization can be performed safely could be
as simple as trying it and performing a deadlock analysis. However, even if the
optimization is safe, it may not be an optimization- multiple procs ticking in
parallel may be desired for performance reasons.</p>
<p>Analysis to check that execution is transferred could look like:</p>
<ol>
<li>
<p>Find places where procs give control away. These are found by unrolling by 2
    and looking for all blocking (send, recv) pairs where the receive is
    downstream of the send in the token graph (with nothing in-between). If the
    send's predicate implies the receive's predicate, the proc gives control to
    another proc on the send's channel until it is returned via the receive's
    channel. If this property holds for every proc→proc channel within a proc,
    we can say the proc "always extinguishes".</p>
</li>
<li>
<p>Find procs that come out of initialization "extinguished". There must be at
    least one proc (generally, the top proc) where this is not true. Other procs
    that begin with a blocking receive with predicate true on initialization are
    initialized as "extinguished". Every other side-effecting operation should
    be downstream of this receive.</p>
</li>
</ol>
<p>The subset of procs that are initialized as extinguished and always extinguish
can be inlined as described above.</p>
<p>It's unclear that this approach will allow mutual exclusion to succeed for more
complicated scenarios, e.g. multiple sends/recvs in nested loops in different
orders. It also seems generally unscalable to rely on passes being aware of
mutual exclusion.</p>
<p>It is worth noting that this may be a generically useful improvement to proc
inlining. Having predicates that are easier to reason about could assist
optimization, and the state representation of proc activation would be more
compact.</p>
<p>It is also worth noting that non-blocking channel operations will not be defined
as extinguishing. The notion of extinguishing could be generalized to include
procs whose state isn't updated observably unless a receive completes.
Similarly, in our discussions <a href="https://github.com/taktoa">Remy</a> described some
potentially simpler ways of identifying procs that can be run one at a time with
a PC. Regardless of what analysis is used to identify situations where proc
inlining can execute procs mutually exclusively, the shortcomings of the
approach seem to be that 1) proc inlining and other passes need to be aware of
how powerful the mutual exclusion pass is, which doesn't scale well; and 2) it’s
not clear that this resolves all the cases where mutual exclusion can fail, even
in proc inlining (proc inlining adds state to track multiple proc↔proc channel
operations, so mutual exclusion could fail within an inlined proc if this
obfuscates the predicate).</p>
<h3 id="design_docs-legalize_multiple_channel_ops_per_channel-use-a-proof-assistant-that-supports-induction">Use a proof assistant that supports induction</h3>
<p>A more powerful proof assistant has the danger of increasing runtime or timing
out unpredictably (Z3 is already pushing our boundaries in this regard). Even
though the unrolling required to prove mutual exclusion seems bounded in most
cases, it isn’t clear what sort of runtime we should expect.</p>
<p>It seems better to treat powerful proof assistants as an infrequent, high-effort
final optimization step. For example, in the proposed design the arbiter
variants could be replaced with mutex assumed variants if an expensive proof of
mutual exclusion can be found.</p>
<div class="footnote">
<hr />
<ol>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:1">
<p>The example presented here is particular to the XLSCC frontend. DSLX
scopes channels to procs, so a similar example in DSLX would not have
multiple procs sending/receiving the same channel. Instead, an internal
channel would communicate proc→proc and the top proc would forward it to
the IO channel. If the top proc manages the send predicate, it is likely
that mutual exclusion will be able to merge the channel operations.
However, if the child proc manages the predicate, DSLX could have the same
problems with proc inlining that XLSCC does.</p>
<p>Of course, non-mutually-exclusive multiple sends/receives are not allowed
in either frontend currently and this proposal would enable that for both
frontends.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:2">
<p>In the general case where channel operations are scheduled in different
cycles, this will need to be a temporal assertion.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:3">
<p>A "scheduling pass" is a pass that operates on the IR after scheduling but
before block conversion. Importantly, we want this pass to run after the
mutual exclusion pass has a chance to run and after scheduling for II&gt;1
has occurred.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:4">
<p>As of writing, XLSCC does not specify any token relationships, it emits IR
with every side effecting operation taking the proc’s root token and
gathers all resulting tokens into an after-all for the next token. The
TokenDependencyPass uses data dependencies to add minimal token
relationships.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:5">
<p>It is often desirable for DSLX interpretation, IR interpretation/JIT, and
RTL simulation to all have identical output. One reason is to support fast
verification at higher levels of abstraction. Then a LEC chain from IR to
RTL can prove that the high-level coverage applies to the RTL.
<code>TopoSort()</code> (and many other ways of choosing an order) will be unstable
across the different levels of abstraction, which is a potential problem.
The DSLX interpreter should have a "safe" mode or throw a warning when
multiple channel operations happen in a single tick. IR interpretation/JIT
should be performed on IR with the token graph reflecting the order chosen
by the channel legalization pass.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:6">
<p>If you have send(c0) -&gt; recv(c1) -&gt; send(c10) each scheduled in different
cycles and recv(c1) blocks until the first send(c0) goes through, you’ll
get deadlock.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="design_docs-legalize_multiple_channel_ops_per_channel-fn:7">
<p>Like mutual exclusion analysis, a proof that a send in (tick, cycle)
(t[n], c[n]) implies the predicate in (t[n-i], c[n+j]) is false could
allow for early sends and simpler logic.&#160;<a class="footnote-backref" href="#design_docs-legalize_multiple_channel_ops_per_channel-fnref:7" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div></section><section class="print-page" id="design_docs-proc_scoped_channels"><h1 id="design_docs-proc_scoped_channels-proc-scoped-channels-in-xls-ir">Proc-scoped channels in XLS IR</h1>
<div class="toc">
<ul>
<li><a href="#design_docs-proc_scoped_channels-proc-scoped-channels-in-xls-ir">Proc-scoped channels in XLS IR</a><ul>
<li><a href="#design_docs-proc_scoped_channels-advantages-of-proc-scoped-channels">Advantages of proc-scoped channels</a></li>
<li><a href="#design_docs-proc_scoped_channels-disadvantagescomplexities">Disadvantages/complexities:</a></li>
<li><a href="#design_docs-proc_scoped_channels-representation-in-the-ir">Representation in the IR</a></li>
<li><a href="#design_docs-proc_scoped_channels-incremental-roll-out">Incremental roll out</a></li>
</ul>
</li>
</ul>
</div>
<p>Written on 2023/5/27</p>
<p>Channels in the IR should be changed from package-scoped to proc-scoped.
Proc-scoped channels have many advantages which outweigh the significant
refactoring effort required to make the change.</p>
<p>Currently in XLS IR channels are declared globally at the package level. For
example:</p>
<div class="highlight"><pre><span></span><code>package foo

chan in_ch(bits[32], id=0, kind=streaming, ops=receive_only)
chan out_ch(bits[32], id=1, kind=streaming, ops=send_only)
chan a_ch(bits[32], id=2, kind=streaming, ops=send_receive)

proc bar(t: token, s: ()) {
  ...
  rcv: (token, bits[32]) = receive(t, channel_id=0)
  ...
  snd0: token = send(t, data0, channel_id=2)
  ...
  snd1: token = send(t, data1, channel_id=1)
  ...
}

proc quux(t: token, s: ()) {
  ...
  rcv: (token, bits[32]) = receive(t, channel_id=2)
  ...
}
</code></pre></div>
<p>All channels have a globally unique name and id. These channels are used inside
of procs in send and receive nodes. Each channel can be used by at most a single
send node and a single receive node.</p>
<p>Changing to proc-scoped channels would change the structure of the IR to more
closely match DSLX (one of the proposal’s numerous advantages). Specifically,
procs would be organized hierarchically where procs spawn other procs. Each proc
has zero or more channel parameters with which the proc is spawned. These
channel parameters define the interface of the proc.</p>
<p>Possible syntax with proc-scoped channels for the proc example above:</p>
<div class="highlight"><pre><span></span><code>package foo

proc quux&lt;in_ch: bits[32]&gt;(t: token, st: ()) {
  ...
  rcv: (token, bits[32]) = receive(t, channel=in_ch)
  ...
}

proc bar&lt;in_ch: bits[32] in,
         out_ch: bits[32] out&gt;(t: token, st: ()) {
  // Channel declaration.
  chan a_ch(bits[32])

  // Spawn a child proc. Naming the spawn statement (“quux_inst”) provides a
  // mechanism for referring to a particular proc instance via a path of named
  // instantiations.
  quux_inst: spawn quux&lt;a_ch&gt;()

  rcv: (token, bits[32]) = receive(t, channel=in_ch)
  ...
  snd0: token = send(t, data0, channel=a_ch)
  ...
  snd1: token = send(t, data1, channel=out_ch)
  ...
}
</code></pre></div>
<h3 id="design_docs-proc_scoped_channels-advantages-of-proc-scoped-channels">Advantages of proc-scoped channels</h3>
<ul>
<li>In DSLX, an empty top proc can be used to stitch together procs via spawn
    statements (<code>next</code> method is empty). Currently this is not representable in
    the IR because the empty top proc has no connections to the spawned procs in
    the IR. This means some designs supported in DSLX are not representable in
    the IR.</li>
</ul>
<ul>
<li>The hierarchical structure of procs naturally maps to the hierarchical
    structure of Verilog modules and the structure of procs in the frontend.</li>
</ul>
<ul>
<li>Avoids channel name collisions. Currently whenever a new channel is created
    (for example, during IR conversion or transformation) care must be taken to
    avoid name collisions resulting in awkward channel names. The DSLX frontend
    for example will name channels based on line and column number in the source
    code.. With this change channel names can have shorter, more natural names
    which translate to shorter more natural Verilog module port names.</li>
</ul>
<ul>
<li>The channel interface of the proc is clearly defined via the spawn
    arguments. These channels become the port interface of the Verilog module
    generated for the proc. Grouping the proc interface channels in one place
    also provides a natural point at which to specify metadata about the
    channels. For example, SRAMs have several different kinds of channels: read
    request, write request, read response and write response. These could be
    specified as metadata on the proc.</li>
</ul>
<ul>
<li>Multiple instantiations of the same proc only require a single IR definition
    of the proc. This could extend down to the emitted Verilog resulting in a
    more compact, more easily verified RTL.</li>
</ul>
<ul>
<li>Scoping channels to procs makes it easier to hold a channel pointer in send
    and receive nodes. Currently send and receive nodes hold a channel ID which
    requires translation to a pointer before using. Associating a pointer held
    by a node with a package-scoped construct is difficult in the face of
    addition, deletion and modification of procs and nodes.</li>
</ul>
<ul>
<li>Supports unused ports on Verilog modules. This is represented with an unused
    spawn channel argument. Currently an unused channel is not associated with
    any proc which prevents these channels from representing unused ports.</li>
</ul>
<h3 id="design_docs-proc_scoped_channels-disadvantagescomplexities">Disadvantages/complexities:</h3>
<ul>
<li>This will be a major refactor which will likely require at least a couple
    weeks worth of work.</li>
</ul>
<ul>
<li>With proc scoped channels there is no longer a one-to-one correspondence
    between the Proc objects and instantiation of procs in the design. The same
    is true for channels. This will require changes in the interpreter and JIT
    (at least). Specifying a specific channel/proc instance requires a path of
    spawn statements.</li>
</ul>
<ul>
<li>Channels can be declared in a couple ways: in the spawn arguments of the
    proc where each argument represents half a channel, and channels can be
    declared inside of procs (which represents both sides of the channel).
    Likely multiple channel representations in the code will be required.
    Perhaps the spawn argument is a reference to one half of a channel, and the
    channel declaration in a proc creates the channel object itself.</li>
</ul>
<h2 id="design_docs-proc_scoped_channels-representation-in-the-ir">Representation in the IR</h2>
<p>The IR data structures will have to change to support proc-scoped channels. A
new construct which is a reference to one side of a channel needs to be added.
This construct would be used for the channel parameters of the procs. These are
bound to actual channels by spawn statements. The channel metadata (fifo depth,
etc) would remain attached to the channel. The channel reference would only hold
direction and name.</p>
<p>Possible C++ implementation:</p>
<div class="highlight"><pre><span></span><code>struct ChannelRef {
  // In (send) or out (receive).
  Direction direction;
  std::string name;
};

class Proc {
  ...
  // List of channels declared inside the proc.
  std::vector&lt;std::unique_ptr&lt;Channel&gt;&gt; channel_declarations_;

  // Spawn parameters of this proc. For example:
  //
  //   proc foo&lt;a: chan&lt;bits[32]&gt;, b: chan&lt;bits[42]&gt;&gt; (...)
  //
  // Spawn parameters are `a` and `b`.
  std::vector&lt;ChannelRef&gt; spawn_parameters_;
};
</code></pre></div>
<p>Send and receive nodes in the IR would naturally correspond to a ChannelRef
however it’s not clear whether ChannelRef data structures should be explicitly
constructed for the send and receive nodes.</p>
<p>Proc-scoped channels break the one-to-one correspondence between definitions of
channels (or procs) and instantiations of channels (or procs). Some XLS
components such as the interpreter and JIT naturally operate on channel/proc
instantiations rather than definitions. To construct instantiations, an
elaboration process walks the proc hierarchy and creates instantiation objects
for instance of channels and procs. Possible instance implementation:</p>
<div class="highlight"><pre><span></span><code>class ChannelInstance {
  // Pointer to the channel construct in the IR.
  Channel* channel;
};

class ProcInstance {
  Proc* proc;
  std::vector&lt;ChannelInstance*&gt; spawn_arguments;

  // Channels declared in this proc instance.
  std::vector&lt;ChannelInstance&gt; channel_instances;

  // Proc instances spawned by this proc instance.
  std::vector&lt;ProcInstance&gt; spawned_procs;

  // Proc which spawned this instance.
  ProcInstance* parent;
};
</code></pre></div>
<p>The elaboration process would return a ProcInstance for the top-level proc with
child instances underneath.</p>
<p>The interpreter and JIT would use this elaboration during execution. Each proc
instance gets its own continuation and each channel instance gets its own
channel queue.</p>
<p>The elaboration would be constructed as needed from the IR rather than trying to
maintain a persistent elaboration in sync with the IR.</p>
<p>One unanswered question is how the interface channels of the top-level proc
should be handled. All channels deeper in the proc hierarchy necessarily have a
corresponding channel declaration within a proc in which metadata can be stored.
However the top-level proc is by definition not spawned by another proc so the
interface channels of the top-level proc have no corresponding channel
declarations. There are several possible solutions:</p>
<ol>
<li>
<p>Declare top-level channels at the package level along with a spawn statement
    of the top-level proc:</p>
<div class="highlight"><pre><span></span><code>package the_package

chan x(bits[32], ...);
chan y(bits[32], ...);
spawn the_top_proc&lt;x, y&gt;();
</code></pre></div>
</li>
<li>
<p>Create a degenerate proc with no interface channels which spawns the
    top-level proc:</p>
<div class="highlight"><pre><span></span><code>proc __fake_top&lt;&gt;(t: token, s: ()) {
  chan x(bits[32], ...);
  chan y(bits[32], ...);
  spawn the_top_proc&lt;x, y&gt;();

  next (t, s);
}
</code></pre></div>
</li>
<li>
<p>No top-level channels are declared in IR. Instead top-level Channel objects
    are created as part of the elaboration. Any necessary metadata (if there is
    any) of the top-level procs would be passed as options to the compilation or
    evaluation process.</p>
</li>
</ol>
<p>Option (3) seems the cleanest. (1) requires adding channel and spawn support at
the package level as a weird special case. (2) is likely a better option than
(1) but it does require carrying around a dummy proc which would need to be
identified in some way as the “fake top”.</p>
<h2 id="design_docs-proc_scoped_channels-incremental-roll-out">Incremental roll out</h2>
<p>This change is too large to be done in a single change and should be done
incrementally. Below are possible steps for an incremental roll out:</p>
<ul>
<li>Add bit on Proc indicating it is a new style proc and add new fields to proc
    as described above which are only set if the bit is set. Initially, only
    support a proc being spawned once. This preserves the one-to-one
    correspondence between channels/procs and instantiations of channels/procs.</li>
</ul>
<ul>
<li>Add parsing and serialization support (channel declarations, spawn
    statements, etc).</li>
</ul>
<ul>
<li>Add interpreter and JIT support.</li>
</ul>
<ul>
<li>Add pass which converts the old-style procs of a package into a hierarchy of
    new style procs.</li>
</ul>
<ul>
<li>Add proc conversion pass to end of pipeline and update codegen to support
    new style procs. Then incrementally move the pass earlier and earlier in the
    pipeline updating passes as the conversion pass is moved.</li>
</ul>
<ul>
<li>After the conversion pass has been moved to the front of the pipeline,
    update the frontends.</li>
</ul>
<ul>
<li>Remove support for old style procs.</li>
</ul>
<ul>
<li>Add elaboration and change interpreter and jit to use elaboration results.
    This enables spawning a proc multiple times.</li>
</ul></section><h1 class='nav-section-title-end'>Ended: Design Docs</h1><section class="print-page" id="releasing"><h1 id="releasing-releasing">Releasing</h1>
<h2 id="releasing-versioning">Versioning</h2>
<p>The project use the following versioning scheme:
<div class="highlight"><pre><span></span><code>v${SEM_VER}-${COMMITS_COUNT_SINCE_LAST_ANNOTATED_TAG}-g${GIT_HASH)
</code></pre></div></p>
<blockquote>
<p>The <a href="https://github.com/google/xls/tree/v0.0.0">v0.0.0</a> annotated tag points to the initial commit to bootstrap the versioning scheme using <a href="https://git-scm.com/docs/git-describe">git-describe</a>.</p>
</blockquote>
<p>Released binaries are stamped with the <code>{version}</code> using <a href="https://bazel.build/reference/command-line-reference#:~:text=%2D%2Dembed_label%3D%3Ca%20one,label%20in%20binary"><code>--embed_label</code></a> during <code>bazel build</code> invocations.</p>
<p>Soft-tags (non-annotated) are used to mark released versions.</p>
<h2 id="releasing-packaging">Packaging</h2>
<p>The <code>//dist:xls_dist_tar</code> target uses <a href="https://github.com/bazelbuild/rules_pkg/">@rules_pkg</a>/pkg_tar to create an archive named <code>xls-{version}-{os}-{arch}.tar.gz</code> with the following layout:</p>
<div class="highlight"><pre><span></span><code>xls-{version}-{os}-{arch}/codegen_main
xls-{version}-{os}-{arch}/interpreter_main
xls-{version}-{os}-{arch}/ir_converter_main
xls-{version}-{os}-{arch}/opt_main
xls-{version}-{os}-{arch}/proto_to_dslx_main
...
xls-{version}-{os}-{arch}/LICENSE
xls-{version}-{os}-{arch}/THIRD_PARTY_NOTICES.txt
</code></pre></div>
<p><code>{version}</code>, <code>{os}</code> and <code>{arch}</code> placeholders get replaced by <a href="https://bazel.build/extending/config#user-defined-build-settings">user-defined build settings</a> passed during <code>bazel build</code> invocations.</p>
<h2 id="releasing-automation">Automation</h2>
<p>The <a href="https://github.com/google/xls/actions/workflows/nightly-ubuntu-22.04.yml">Nightly Ubuntu 22.04</a> workflow automates the release process.</p>
<p>The <code>Dist</code> step builds the <code>//dist:xls_dist_tar</code> target w/ the following flags:</p>
<table>
<thead>
<tr>
<th>flag</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--embed_label</code></td>
<td><code>$VERSION</code></td>
</tr>
<tr>
<td><code>--//dist:version</code></td>
<td><code>$VERSION</code></td>
</tr>
<tr>
<td><code>--//dist:os</code></td>
<td><code>downcased($RUNNER_OS)</code></td>
</tr>
<tr>
<td><code>--//dist:arch</code></td>
<td><code>downcased($RUNNER_ARCH)</code></td>
</tr>
</tbody>
</table>
<p>The <code>Release</code> step uploads the release artefacts to https://github.com/google/xls/releases using <a href="https://github.com/marketplace/actions/gh-release">softprops/action-gh-release@v1</a> and creates new soft-tag corresponding to <code>{version}</code>.</p></section><h1 class='nav-section-title-end'>Ended: Development</h1>
                        <h1 class='nav-section-title' id='section-noc'>
                            NoC <a class='headerlink' href='#section-noc' title='Permanent link'>↵</a>
                        </h1>
                        <section class="print-page" id="noc-xls_noc_readme"><h1 id="noc-xls_noc_readme-xls-noc-project">XLS-NoC Project</h1>
<p>The XLS-NoC subproject is a project that leverages XLS's facilities for
optimizing parameterized hardware designs in the realm of NoC generation.</p>
<p>A declarative specification drives the NoC generation process for optimization
(e.g. of performance/area tradeoffs), traffic simulations and software-level
functional verification, and the creation of (System)Verilog RTL artifacts such
as routers and network-interfacing adapter components.</p></section>
                        <h2 class='nav-section-title' id='section-topologies'>
                            Topologies <a class='headerlink' href='#section-topologies' title='Permanent link'>↵</a>
                        </h2>
                        <section class="print-page" id="noc-xls_noc_topologies"><h1 id="noc-xls_noc_topologies-xls-noc-topologies">XLS-NoC Topologies</h1>
<p>The network topology is the static arrangement of router nodes, channels, and
endpoints in a network. The document will describe the logical representation of
common topology types and define the communication flow within the topology. At
the physical level, the arrangement of the topology influences the floorplan,
layout and packaging.</p>
<p>The supported set of topologies types are:</p>
<ul>
<li><a href="#noc-xls_noc_dimension_order_topology">Dimension Order</a></li>
<li><a href="#noc-xls_noc_tree_topology">Tree</a></li>
<li><a href="#noc-xls_noc_butterfly_topology">k-ary n-fly Butterfly</a></li>
<li><a href="#noc-xls_noc_fully_connected_topology">Fully Connected</a></li>
<li><a href="#noc-xls_noc_star_topology">Star</a></li>
</ul></section><section class="print-page" id="noc-xls_noc_dimension_order_topology"><h1 id="noc-xls_noc_dimension_order_topology-dimension-order-topology-types">Dimension-Order Topology Types</h1>
<h2 id="noc-xls_noc_dimension_order_topology-overview">Overview</h2>
<p>The dimension-order topology is a topology where the arrangement of the routers
are described by their location in a dimensional space. The topology has a
hierarchical structure where dimension <em>n</em> is composed of structures from
dimension <em>n-1</em>. One or more endpoint nodes are connected to a router.</p>
<h2 id="noc-xls_noc_dimension_order_topology-k-ary-n-cube">k-ary n-cube <a id="k_ary_n_cube"></a></h2>
<p>A <em>k</em>-ary <em>n</em>-cube topology consists of <em>k<sup>n</sup></em> routers arranged in
an <em>n</em>-dimensional cube with <em>k</em> routers along each dimension. Each router is
assigned an <em>n</em>-digit radix-<em>k</em> address {a<sub>n−1</sub>, ..., a<sub>0</sub>}
and is connected to all routers with addresses that differ by ±1(mod <em>k</em>) in
exactly one address digit. Each dimension is constructed using <em>k</em> <em>k</em>-ary
(<em>n-1</em>)-cubes. The channels between the routers can be unidirectional or
bidirectional. In practice, the channels are bidirectional.</p>
<h3 id="noc-xls_noc_dimension_order_topology-ring-topology">Ring Topology <a id="ring"></a></h3>
<p><img alt="drawing" src="../noc/ring.png" /></p>
<p><strong>Figure Ring_4ary_1cube_example<a id="ring_4ary_1cube_example"></a>. A ring
topology with four routers, also known as a 4-ary 1-cube topology.</strong></p>
<p>The ring topology is a special instance of the <em>k</em>-ary <em>n</em>-cube, where <em>n</em> is
equal to one. Figure <a href="#noc-xls_noc_dimension_order_topology-ring_4ary_1cube_example">Ring_4ary_1cube_example</a> shows a
ring topology with four routers, also known as a 4-ary 1-cube topology. The
dotted lines show the connectivity between routers 0 and k-1 for a dimension.</p>
<h3 id="noc-xls_noc_dimension_order_topology-symmetric-torus-topology">Symmetric Torus Topology <a id="symmetric_torus"></a></h3>
<p><img alt="drawing" src="../noc/symmetric_torus.png" /></p>
<p><strong>Figure
Symmetric_Torus_4ary_2cube_example<a id="symmetric_torus_4ary_2cube_example"></a>.
A symmetric torus topology with four routers along each dimension, also known as
a 4-ary 2-cube topology.</strong></p>
<p>The symmetric torus topology is a special instance of the <em>k</em>-ary <em>n</em>-cube,
where n is equal to two. Figure
<a href="#noc-xls_noc_dimension_order_topology-symmetric_torus_4ary_2cube_example">Symmetric_Torus_4ary_2cube_example</a> shows a
symmetric torus topology with four routers along each dimension, also known as a
4-ary 2-cube topology. Router (3,0) has address 3 in a dimension and 0 in the
other dimension. The dotted lines show the connectivity between routers 0 and
k-1 for a dimension.</p>
<p><img alt="drawing" src="../noc/hierarchical_structure_dimension_order.png" /></p>
<p><strong>Figure
4ary_2cube_construction_example<a id="4ary_2cube_construction_example"></a>. The
construction of a symmetric torus (4-ary 2-cube) topology using 4-ary 1-cubes.</strong></p>
<p>Figure <a href="#noc-xls_noc_dimension_order_topology-4ary_2cube_construction_example">4ary_2cube_construction_example</a> shows
the construction of a symmetric torus (4-ary 2-cube) topology using 4-ary
1-cubes (ring topologies).</p>
<h3 id="noc-xls_noc_dimension_order_topology-multi-radix-n-cube">multi-radix n-cube <a id="multi_radix_n_cube"></a></h3>
<p>A multi-radix <em>n</em>-cube is a generalized form of a <em>k</em>-ary <em>n</em>-cube topology
where the radix (number of router nodes) for each dimension is explicitly
stated. Each router is assigned an <em>n</em>-digit where the digit at index <em>i</em> has
the radix of dimension <em>i</em>. A 2,3-ary 2-cube describes a grid-like topology with
a radix of 2 in one dimension and radix of 3 in the other dimension.</p>
<p><img alt="drawing" src="../noc/multi_radix_n_cube.png" /></p>
<p><strong>Figure 2,3-ary_2cube_example<a id="2_3_ary_2cube_example"></a>. A 2,3-ary
2-cube topology example.</strong></p>
<p>Figure <a href="#noc-xls_noc_dimension_order_topology-2_3_ary_2cube_example">2,3-ary_2cube_example</a> shows a 2,3-ary 2-cube
topology example. The dotted lines show the connectivity between router 0 and
router radix<sub>i </sub>- 1 for each dimension.</p>
<h2 id="noc-xls_noc_dimension_order_topology-k-ary-n-mesh">k-ary n-mesh <a id="k_ary_n_mesh"></a></h2>
<p>A <em>k</em>-ary <em>n</em>-mesh is a <em>k</em>-ary <em>n</em>-cube topology with the connection from
address a<sub>k−1</sub> to address a<sub>0</sub> omitted in each dimension.</p>
<h3 id="noc-xls_noc_dimension_order_topology-line">Line <a id="line"></a></h3>
<p><img alt="drawing" src="../noc/line.png" /></p>
<p><strong>Figure Line_4ary_1mesh_example<a id="line_4ary_1mesh_example"></a>. A line
topology with four routers, also known as a 4-ary 1-mesh topology.</strong></p>
<p>The line topology is a special instance of the <em>k</em>-ary <em>n</em>-mesh, where <em>n</em> is
equal to one. Figure <a href="#noc-xls_noc_dimension_order_topology-line_4ary_1mesh_example">Line_4ary_1mesh_example</a> shows a
line topology with four routers, also known as a 4-ary 1-mesh topology. Compared
to the ring topology in Figure
<a href="#noc-xls_noc_dimension_order_topology-ring_4ary_1cube_example">Ring_4ary_1cube_example</a>, the connection from router
0 to router 3 is omitted.</p>
<h3 id="noc-xls_noc_dimension_order_topology-symmetric-mesh">Symmetric Mesh <a id="symmetric_mesh"></a></h3>
<p><img alt="drawing" src="../noc/symmetric_mesh.png" /></p>
<p><strong>Figure
Symmetric_Mesh_4ary_2mesh_example<a id="symmetric_mesh_4ary_2mesh_example"></a>. A
symmetric mesh topology with four routers along each dimension, also known as a
4-ary 2-mesh topology.</strong></p>
<p>The symmetric torus mesh is a special instance of the <em>k</em>-ary <em>n</em>-mesh, where
<em>n</em> is equal to two. Figure
<a href="#noc-xls_noc_dimension_order_topology-symmetric_mesh_4ary_2mesh_example">Symmetric_Mesh_4ary_2mesh_example</a> shows a
symmetric mesh topology with four routers along each dimension, also known as a
4-ary 2-mesh topology. Router (1,2) has address 1 in a dimension and 2 in the
other dimension. Compared to the torus topology in Figure
<a href="#noc-xls_noc_dimension_order_topology-symmetric_torus_4ary_2cube_example">Symmetric_Torus_4ary_2cube_example</a>, the
connections between the pair of routers [(0,0), (0,3)], [(1,0), (1,3)], [(2,0),
(2,3)], [(3,0), (3,3)], [(0,0), (3,0)], [(0,1), (3,1)], [(0,2), (3,2)], and
[(0,3), (3,3)] are omitted.</p>
<h3 id="noc-xls_noc_dimension_order_topology-multi-radix-n-mesh">multi-radix n-mesh <a id="multi_radix_n_mesh"></a></h3>
<p>Similar to the multi-radix <em>n</em>-cube, a multi-radix <em>n</em>-mesh is a generalized form of
a <em>k</em>-ary <em>n</em>-mesh topology where the radix (number of router nodes) for each
dimension is explicitly stated. Each router is assigned an <em>n</em>-digit where the
digit at index <em>i</em> has the radix of dimension <em>i</em>. A 2,3-ary 2-mesh describes a
grid-like topology with a radix of 2 in one dimension and radix of 3 in the
other dimension.</p>
<p><img alt="drawing" src="../noc/multi_radix_n_mesh.png" /></p>
<p><strong>Figure 2,3-ary_2mesh_example<a id="2_3_ary_2mesh_example"></a>. A 2,3-ary
2-mesh topology example.</strong></p>
<p>Figure <a href="#noc-xls_noc_dimension_order_topology-2_3_ary_2mesh_example">2,3-ary_2mesh_example</a> shows a 2,3-ary 2-mesh
topology example. Compared to the multi-radix n-cube topology in Figure
<a href="#noc-xls_noc_dimension_order_topology-2_3_ary_2cube_example">2,3-ary_2cube_example</a>, the connections from the pair
of routers [(0,0), (0,2)], [(1,0), (1,2)], [(0,0), (1,0)], [(0,1), (1,1)] and
[(0,2), (1,2)] are omitted.</p>
<h2 id="noc-xls_noc_dimension_order_topology-cheat-sheet">Cheat Sheet</h2>
<ul>
<li>A <a href="#noc-xls_noc_dimension_order_topology-k_ary_n_cube"><em>k</em>-ary <em>n</em>-cube</a> topology consists of <em>k<sup>n</sup></em>
    routers arranged in an n-dimensional cube with k router nodes along each
    dimension. Each router is assigned an <em>n</em>-digit radix-<em>k</em> address
    {a<sub>n−1</sub>, ..., a<sub>0</sub>} and is connected to all routers with
    addresses that differ by ±1 (mod k) in exactly one address digit. Each
    dimension is constructed using <em>k</em> <em>k</em>-ary (<em>n</em>-1)-cubes where there are <em>k</em>
    routers in the first dimension.</li>
<li>A <a href="#noc-xls_noc_dimension_order_topology-multi_radix_n_cube">multi-radix n-cube</a> is a generalized form of a
    <em>k</em>-ary <em>n</em>-cube topology where the radix (number of routers) for each
    dimension is explicitly stated. Each router is assigned an <em>n</em>-digit where
    the digit at index <em>i</em> has the radix of dimension <em>i</em>.</li>
<li>A <a href="#noc-xls_noc_dimension_order_topology-k_ary_n_mesh"><em>k</em>-ary <em>n</em>-mesh</a> is a <em>k</em>-ary <em>n</em>-cube topology with the
    connection from address a<sub>k−1</sub> to address a<sub>0</sub> omitted in
    each dimension.</li>
<li>Similar to the multi-radix <em>n</em>-cube, a
    <a href="#noc-xls_noc_dimension_order_topology-multi_radix_n_mesh">multi-radix n-mesh</a> is a generalized form of a <em>k</em>-ary
    <em>n</em>-mesh topology where the radix (number of routers) for each dimension is
    explicitly stated. Each router is assigned an <em>n</em>-digit where the digit at
    index <em>i</em> has the radix of dimension <em>i</em>.</li>
<li>Channel direction can be unidirectional or bidirectional.</li>
<li><a href="#noc-xls_noc_dimension_order_topology-ring">Ring</a>: k-ary 1-cube</li>
<li><a href="#noc-xls_noc_dimension_order_topology-symmetric_torus">Symmetric Torus</a>: k-ary 2-cube</li>
<li><a href="#noc-xls_noc_dimension_order_topology-line">Line</a>: k-ary 1-mesh</li>
<li><a href="#noc-xls_noc_dimension_order_topology-symmetric_mesh">Symmetric Mesh</a>: k-ary 2-mesh</li>
</ul>
<h2 id="noc-xls_noc_dimension_order_topology-references">References</h2>
<p>William James Dally and Brian Patrick Towles. 2004. Principles and Practices of
Interconnection Networks. Morgan Kaufmann Publishers Inc., San Francisco, CA,
USA.</p></section><section class="print-page" id="noc-xls_noc_tree_topology"><h1 id="noc-xls_noc_tree_topology-tree-topology-types">Tree Topology Types</h1>
<h2 id="noc-xls_noc_tree_topology-overview">Overview <a id="tree"></a></h2>
<p>The tree topology is a hierarchical topology with a root node and children
nodes. The radix of a node defines the number of children nodes for the given
node. The nodes represent the router nodes and endpoint nodes of a network. A
tree topology has endpoints connected to the root router and leaf routers. It is
called a tree topology because the router nodes form a tree data structure.</p>
<p><img alt="drawing" src="../noc/tree_topology.png" /></p>
<p><strong>Figure Tree_Topology_Example<a id="tree_topology_example"></a>. A tree
topology example.</strong></p>
<p>Figure <a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a> shows an example of a
tree topology. In the figure, there are nine nodes: three router nodes and six
endpoint nodes. Router 1 is a root router, and routers 2 and 5 are leaf routers.
Router 1 has a radix of four, and routers 2 and 5 have a radix of two. Routers 2
and 5 are child routers of router 1. Endpoints 3 and 4 are child endpoints of
router 1. Endpoints 6 and 7, and endpoints 8 and 9 are child endpoints of router
2 and router 5 respectively.</p>
<h2 id="noc-xls_noc_tree_topology-unidirectional-types">Unidirectional Types <a id="unidirectional_tree"></a></h2>
<p>A unidirectional tree is a tree topology where the communication flow is
unidirectional, thus all channels in the tree are unidirectional. There are two
unidirectional tree types: aggregation tree and distribution tree.</p>
<h3 id="noc-xls_noc_tree_topology-aggregation-tree">Aggregation Tree <a id="aggregation_tree"></a></h3>
<p>In the aggregation tree, the communication flow is from the leaf routers of the
tree to the root router of the tree. The endpoints connected to the root router
receive from the network, and the endpoints connected to the leaf routers send
to the network.</p>
<p><img alt="drawing" src="../noc/aggregation_tree.png" /></p>
<p><strong>Figure
Aggregation_Tree_Topology_Example<a id="aggregation_tree_topology_example"></a>.
The aggregation tree topology representation of the tree in Figure
<a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a>.</strong></p>
<p>Figure <a href="#noc-xls_noc_tree_topology-aggregation_tree_topology_example">Aggregation_Tree_Topology_Example</a>
shows the aggregation tree topology representation of the tree in Figure
<a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a>. Endpoints 6, 7, 8 and 9 send to
the network, and endpoints 3 and 4 receive from the network.</p>
<h3 id="noc-xls_noc_tree_topology-distribution-tree">Distribution Tree <a id="distribution_tree"></a></h3>
<p>In the distribution tree, the communication flow is from the root router of the
tree to the leaf routers of the tree. The endpoints connected to the root router
send to the network, and the endpoints connected to the leaf routers receive
from the network.</p>
<p><img alt="drawing" src="../noc/distribution_tree.png" /></p>
<p><strong>Figure
Distribution_Tree_Topology_Example<a id="distribution_tree_topology_example"></a>.
The distribution tree topology representation of the tree in Figure
<a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a>.</strong></p>
<p>Figure <a href="#noc-xls_noc_tree_topology-distribution_tree_topology_example">Distribution_Tree_Topology_Example</a>
shows the distribution tree topology representation of the tree in Figure
<a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a>. Endpoints 3 and 4 send to the
network, and endpoints 6, 7, 8 and 9 receive from the network.</p>
<h2 id="noc-xls_noc_tree_topology-bidirectional-type">Bidirectional Type <a id="bidirectional_tree"></a></h2>
<p>A bidirectional tree is a tree topology where the communication flow is
bidirectional. The communication flows: from the root router of the tree to the
leaf routers of the tree <span style="text-decoration:underline;">and</span>
from the leaf routers of the tree to the root router of the tree. By definition,
a bidirectional tree requires: 1) at least one endpoint connected to the root
router that sends to the network, 2) at least one endpoint connected to the root
router that receives from the network, 3) at least one endpoint connected to the
leaf routers that sends to the network, and 4) at least one endpoint connected
to the leaf routers that receives from the network. In practice, it is common to
have all endpoints connected to the root router and leaf routers send to and
receive from the network.</p>
<p><img alt="drawing" src="../noc/bidirectional_tree.png" /></p>
<p><strong>Figure
Bidirectional_Tree_Topology_Example<a id="bidirectional_tree_topology_example"></a>.
The bidirectional tree topology representation of the tree in Figure
<a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a>.</strong></p>
<p>Figure
<a href="#noc-xls_noc_tree_topology-bidirectional_tree_topology_example">Bidirectional_Tree_Topology_Example</a>
shows the bidirectional tree topology representation of the tree in Figure
<a href="#noc-xls_noc_tree_topology-tree_topology_example">Tree_Topology_Example</a>. All endpoints in the tree send
to and receive from the network.</p>
<h2 id="noc-xls_noc_tree_topology-cheat-sheet">Cheat Sheet</h2>
<ul>
<li>A <a href="#noc-xls_noc_tree_topology-tree">tree</a> topology has endpoints connected to the root router and leaf
    routers.</li>
<li><a href="#noc-xls_noc_tree_topology-unidirectional_tree">Unidirectional Trees</a><ul>
<li>In the <a href="#noc-xls_noc_tree_topology-aggregation_tree">aggregation tree</a>, the communication flow is
      from the leaf routers of the tree to the root router of the tree.</li>
<li>In the <a href="#noc-xls_noc_tree_topology-distribution_tree">distribution tree</a>, the communication flow
      is from the root router of the tree to the leaf routers of the tree.</li>
</ul>
</li>
<li>The communication flow of a <a href="#noc-xls_noc_tree_topology-bidirectional_tree">bidirectional tree</a> is:
    from the root router of the tree to the leaf routers of the tree
    <span style="text-decoration:underline;">and</span> from the leaf routers of
    the tree to the root router of the tree.</li>
</ul></section><section class="print-page" id="noc-xls_noc_butterfly_topology"><h1 id="noc-xls_noc_butterfly_topology-k-ary-n-fly-butterfly-topology-types">k-ary n-fly Butterfly Topology Types</h1>
<h2 id="noc-xls_noc_butterfly_topology-overview">Overview <a id="butterfly"></a></h2>
<p>A <em>k</em>-ary <em>n</em>-fly butterfly topology type is a multistage logarithm network. It
is implemented using <em>n</em> stages of identical routers, where <em>k</em> is the number of
channels of a router that connect to the previous and/or to the next stage. For
example, a 2-ary 3-tree butterfly topology has three stages composed of routers
with two channels connect to the routers of the previous and/or the next stage
(see Figure Butterfly_Topology_Example).</p>
<p>Each endpoint node and channel has an <em>n</em>-digit radix-<em>k</em> identifier,
{d<sub>n−1</sub>, d<sub>n−2</sub>, ..., d<sub>0</sub>}. The first <em>n−1</em> digits
{d<sub>n−1</sub>, d<sub>n−2</sub>, ..., d<sub>1</sub>} of the identifier
corresponds to the router that it is connected to. Each router node has an
<em>n−1</em>-digit radix-<em>k</em> identifier. To distinguish nodes and channels from
different stages, the stage number is appended to their identifier separated by
a period. For example, for a 2-ary 4-fly butterfly network: 2.1010<sub>2</sub>
is channel 10<sub>10</sub> from stage 2. <strong><a href="#noc-xls_noc_butterfly_topology-butterfly_ref_0">Butterfly_Ref_0</a></strong></p>
<p>The connection between the stages is a permutation of the channel identifier.
The connection of a channel from stage <em>i</em>-1 to stage <em>i</em> swaps digits
d<sub>n−i</sub> and d<sub>0</sub> of the channel identifier, with <em>i</em> &gt;= 1 and
<em>i</em> &lt; n. For example, for a 2-ary 4-fly butterfly network: channel
9<sub>10</sub> of stage 1 [1.1001<sub>2</sub>] is connected to router 4
[1.<strong>100</strong>1<sub>2</sub>] of stage 1 and router 6
[2.<strong>110</strong>0<sub>2</sub>] of stage 2.
<strong><a href="#noc-xls_noc_butterfly_topology-butterfly_ref_0">Butterfly_Ref_0</a></strong></p>
<p><img alt="drawing" src="../noc/butterfly_topology.png" /></p>
<p><strong>Figure Butterfly_Topology_Example<a id="butterfly_topology_example"></a>. The
router nodes of a 2-ary 3-tree butterfly topology.</strong></p>
<p>Figure <a href="#noc-xls_noc_butterfly_topology-butterfly_topology_example">Butterfly_Topology_Example</a> shows the
router nodes of a 2-ary 3-tree butterfly topology. The routers are labelled with
an <strong>S.I</strong> format where <strong>S</strong> is the stage identifier and <strong>I</strong> is the router
identifier. For example, router 0.2 is router 2 from stage 0. Channel 0.6 is
connected to router 3 [0.<strong>11</strong>0<sub>2</sub>] of stage 0 and router
1 of stage 1 [1.<strong>01</strong>1<sub>2</sub>], Channel 1.3 is connected to
router 1 [1.<strong>01</strong>1<sub>2</sub>] of stage 1 and to router 1
[1.<strong>01</strong>1<sub>2</sub>] of stage 2.</p>
<h2 id="noc-xls_noc_butterfly_topology-unidirectional-types">Unidirectional Types <a id="unidirectional_butterfly"></a></h2>
<p>For the unidirectional type of the <em>k</em>-ary <em>n</em>-fly, there are endpoints
connected to stage 0 <span style="text-decoration:underline;">and</span> stage
<em>n</em>-1. There are two configurations: 1) the endpoints connected to stage 0 send
to the network, and the endpoints connected to stage <em>n</em>-1 receive from the
network, and 2) the endpoints connected to stage 0 receive from the network, and
the endpoints connected to stage <em>n</em>-1 send to the network. A unidirectional
<em>k</em>-ary <em>n</em>-fly butterfly topology has at most <em>k<sup>n</sup></em> endpoints
connected to stage 0 and at most <em>k<sup>n</sup></em> endpoints connected to stage
<em>n</em>-1. Typically, the endpoints nodes connected to stage 0 and stage <em>n</em>-1 are
the same nodes, resulting in an equal number of nodes connected to stage 0 and
stage <em>n</em>-1. Moreover, the endpoints nodes are connected to stage 0 in the same
order as stage <em>n</em>-1 (mirrored from the vertical cross section).</p>
<p><img alt="drawing" src="../noc/unidirectional_butterfly.png" /></p>
<p><strong>Figure
Unidirectional_Butterfly_Topology_Example<a id="unidirectional_butterfly_topology_example"></a>.
A 2-ary 3-fly butterfly with the endpoints connected to stage 0 sending to the
network, and the endpoints connected to stage 2 receiving from the network
example.</strong></p>
<p>Figure
<a href="#noc-xls_noc_butterfly_topology-unidirectional_butterfly_topology_example">Unidirectional_Butterfly_Topology_Example</a>
shows a 2-ary 3-fly butterfly with the endpoints connected to stage 0 sending to
the network, and the endpoints connected to stage 2 receiving from the network
example.</p>
<h2 id="noc-xls_noc_butterfly_topology-bidirectional-types">Bidirectional Types <a id="bidirectional_butterfly"></a></h2>
<p>In the bidirectional type, there are endpoints connected to stage 0
<span style="text-decoration:underline;">or</span> stage <em>n</em>-1. A bidirectional
<em>k</em>-ary <em>n</em>-fly butterfly topology has at most <em>k<sup>n</sup></em> endpoints
connected to stage 0 or stage <em>n</em>-1. A bidirectional <em>k</em>-ary <em>n</em>-fly butterfly
topology with the endpoints connected to stage <em>n</em>-1 is also referred to as the
<em>k</em>-ary <em>n</em>-fly fat tree butterfly topology or <em>k</em>-ary <em>n</em>-tree butterfly fat
tree topology <strong><a href="#noc-xls_noc_butterfly_topology-fat_tree_ref_0">Fat_Tree_Ref_0</a></strong>.</p>
<p>For context, minimal routing between a pair of nodes on a bidirectional k-ary
n-tree can be accomplished by sending the message to one of the nearest common
ancestors of both source and destination and from there to the destination. That
is, each message experiences two phases, an ascending phase to get to a nearest
common ancestor, followed by a descending phase.
<strong><a href="#noc-xls_noc_butterfly_topology-fat_tree_ref_1">Fat_Tree_Ref_1</a></strong></p>
<p><img alt="drawing" src="../noc/bidirectional_butterfly.png" /></p>
<p><strong>Figure
Bidirectional_Butterfly_Topology_Example<a id="bidirectional_butterfly_topology_example"></a>.
A bidirectional 2-ary 3-fly butterfly with the endpoints connected to stage 0
example.</strong></p>
<p>Figure
<a href="#noc-xls_noc_butterfly_topology-bidirectional_butterfly_topology_example">Bidirectional_Butterfly_Topology_Example</a>
shows a bidirectional 2-ary 3-fly butterfly with the endpoints connected to
stage 0 example.</p>
<h2 id="noc-xls_noc_butterfly_topology-cheat-sheet">Cheat Sheet</h2>
<ul>
<li><a href="#noc-xls_noc_butterfly_topology-butterfly"><em>k</em>-ary <em>n</em>-flies</a> are implemented by using <em>n</em> stages of
    identical routers, where <em>k</em> is the number of channels of a router that
    connect to the previous and/or to the next stage.</li>
<li>For unidirectional <a href="#noc-xls_noc_butterfly_topology-unidirectional_butterfly"><em>k</em>-ary <em>n</em>-fly</a>, there are
    endpoints connected to stage 0
    <span style="text-decoration:underline;">and</span> stage <em>n</em>-1. The
    communication flows from stage 0 to stage <em>n</em>-1
    <span style="text-decoration:underline;">or</span> from stage <em>n</em>-1 to
    stage 0.</li>
<li>For bidirectional <a href="#noc-xls_noc_butterfly_topology-bidirectional_butterfly"><em>k</em>-ary <em>n</em>-fly</a>, there are
    endpoints connected to stage 0
    <span style="text-decoration:underline;">or</span> stage <em>n</em>-1. The
    communication flows from stage 0 to stage <em>n</em>-1
    <span style="text-decoration:underline;">and</span> from stage <em>n</em>-1 to
    stage 0.</li>
</ul>
<h2 id="noc-xls_noc_butterfly_topology-variants">Variants</h2>
<p>This section describes variants to the <em>k</em>-ary <em>n</em>-fly butterfly topology.</p>
<h3 id="noc-xls_noc_butterfly_topology-flattened-butterfly">Flattened Butterfly</h3>
<p>The flattened butterfly is derived by flattening the routers in each row of a
conventional butterfly topology while maintaining the same inter-router
connections. <strong><a href="#noc-xls_noc_butterfly_topology-butterfly_ref_1">Butterfly_Ref_1</a></strong></p>
<p><img alt="drawing" src="../noc/flatten_butterfly.png" /></p>
<p><strong>Figure
Flattened_Butterfly_Topology_Example<a id="flattened_butterfly_topology_example"></a>.
An example of a 2-ary 3-fly butterfly and its corresponding flattened butterfly
topology.</strong></p>
<p>Figure
<a href="#noc-xls_noc_butterfly_topology-flattened_butterfly_topology_example">Flattened_Butterfly_Topology_Example</a>
shows an example of a 2-ary 3-fly butterfly and its corresponding flattened
butterfly topology. For each row, routers from stage 0, 1 and 2 are flattened
into individual routers. For example, router 0.0, 1.0 and 2.0 are flattened into
router 0.</p>
<h3 id="noc-xls_noc_butterfly_topology-endpoint-connections">Endpoint Connections</h3>
<p>As mentioned, typically, for the unidirectional butterfly topology, the
endpoints nodes are connected to stage 0 in the same order as stage <em>n</em>-1
(mirrored from the vertical cross section). However, different topologies are
said to emerge by modifying the order of the endpoint nodes connected to the
network. Such a change in connectivity may also change the routing algorithm.
Ludovici et al present a Reduced Unidirectional Fat Tree derived from a k-ary
n-fly topology. <strong><a href="#noc-xls_noc_butterfly_topology-fat_tree_ref_0">Fat_Tree_Ref_0</a></strong></p>
<h2 id="noc-xls_noc_butterfly_topology-references">References</h2>
<p><strong>[Butterfly_Ref_0]<a id="butterfly_ref_0"></a></strong> William James Dally and Brian
Patrick Towles. 2004. Principles and Practices of Interconnection Networks.
Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.</p>
<p><strong>[Fat_Tree_Ref_0]<a id="fat_tree_ref_0"></a></strong> D. Ludovici et al., "Assessing
fat-tree topologies for regular network-on-chip design under nanoscale
technology constraints," 2009 Design, Automation &amp; Test in Europe Conference &amp;
Exhibition, Nice, 2009, pp. 562-565, doi: 10.1109/DATE.2009.5090727.</p>
<p><strong>[Fat_Tree_Ref_1]<a id="fat_tree_ref_1"></a></strong> F. Petrini and M. Vanneschi,
"k-ary n-trees: high performance networks for massively parallel architectures,"
Proceedings 11th International Parallel Processing Symposium, Genva,
Switzerland, 1997, pp. 87-93, doi: 10.1109/IPPS.1997.580853.</p>
<p><strong>[Butterfly_Ref_1]<a id="butterfly_ref_1"></a></strong> J. Kim, J. Balfour and W.
Dally, "Flattened Butterfly Topology for On-Chip Networks," 40th Annual IEEE/ACM
International Symposium on Microarchitecture (MICRO 2007), Chicago, IL, 2007,
pp. 172-182, doi: 10.1109/MICRO.2007.29.</p></section><section class="print-page" id="noc-xls_noc_fully_connected_topology"><h1 id="noc-xls_noc_fully_connected_topology-fully-connected-topology-types">Fully-connected Topology Types <a id="fully_connected"></a></h1>
<p>The fully-connected topology is a topology where each router has a bidirectional
channel connecting it to each remaining router of the topology. One or more
endpoint nodes are connected to a router.</p>
<p><img alt="drawing" src="../noc/fully_connected_topology.png" /></p>
<p><strong>Figure Fully_Connected_example<a id="fully_connected_example"></a>. A
fully-connected topology with six routers.</strong></p>
<p>Figure <a href="#noc-xls_noc_fully_connected_topology-fully_connected_example">Fully_Connected_example</a> shows a
fully-connected topology with six routers.</p>
<h2 id="noc-xls_noc_fully_connected_topology-cheat-sheet">Cheat Sheet</h2>
<ul>
<li>The <a href="#noc-xls_noc_fully_connected_topology-fully_connected">fully-connected</a> topology is a topology where each
    router has a bidirectional connecting it to each remaining router of the
    topology.</li>
</ul></section><section class="print-page" id="noc-xls_noc_star_topology"><h1 id="noc-xls_noc_star_topology-star-topology-types">Star Topology Types</h1>
<h2 id="noc-xls_noc_star_topology-overview">Overview</h2>
<p>The star topology is a topology with a central router node.</p>
<h2 id="noc-xls_noc_star_topology-hierarchical-star-topology">Hierarchical Star Topology <a id="hierarchical_star"></a></h2>
<p>The hierarchical star topology is a hierarchical topology with a central router
node that is only connected to router nodes, and the endpoint nodes are only
connected to leaf routers. It is identical to a
<a href="#noc-xls_noc_tree_topology-bidirectional_tree">bidirectional tree topology</a>
with the exception that there are no endpoints connected to the root router. The
channels are unidirectional or bidirectional. In practice, it is common that all
channels of the network be bidirectional.</p>
<p><img alt="drawing" src="../noc/hierarchical_star.png" /></p>
<p><strong>Figure Hierarchical_Star_example<a id="hierarchical_star_example"></a>. A
hierarchical star topology example with eight endpoint nodes and five router
nodes.</strong></p>
<p>Figure <a href="#noc-xls_noc_star_topology-hierarchical_star_example">Hierarchical_Star_example</a> shows a
hierarchical star topology example with eight endpoint nodes and five router
nodes. Router 8 is the central router that is only connected to router nodes 9,
10, 11 and 12. The endpoints [0, 1], [2, 3], [4, 5] and [6, 7] are connected to
leaf routers 9, 10, 11 and 12 respectively. All the channels of the network are
bidirectional.</p>
<h2 id="noc-xls_noc_star_topology-star-topology">Star Topology <a id="star"></a></h2>
<p>The star topology is a topology with a single router: the central router node.
All communication flows through the central router (all traffic traverses
through the central router). The channels are bidirectional.</p>
<p><img alt="drawing" src="../noc/star.png" /></p>
<p><strong>Figure Star_example<a id="star_example"></a>. A star topology example with
four endpoint nodes and the central router.</strong></p>
<p>Figure <a href="#noc-xls_noc_star_topology-star_example">Star_example</a> shows a star topology example with four
endpoint nodes and the central router.</p>
<h2 id="noc-xls_noc_star_topology-single-router-topology">Single Router Topology <a id="single_router"></a></h2>
<p>The single router topology is the star topology with the channels being
unidirectional. The single router topology has a single router: the central
router node. All communication flows through the central router (all traffic
traverses through the central router).</p>
<p><img alt="drawing" src="../noc/single_router.png" /></p>
<p><strong>Figure Single_Router_example<a id="single_router_example"></a>. A single
router topology example with four endpoint nodes and the central router.</strong></p>
<p>Figure <a href="#noc-xls_noc_star_topology-single_router_example">Single_Router_example</a> shows a single router
topology example with four endpoint nodes and the central router. Compared to
Figure Star_example, the channels are unidirectional.</p>
<h2 id="noc-xls_noc_star_topology-cheat-sheet">Cheat Sheet</h2>
<ul>
<li>The <a href="#noc-xls_noc_star_topology-hierarchical_star">hierarchical star</a> topology is a hierarchical
    topology with a central router node that is only connected to router nodes,
    and the endpoint nodes are only connected to leaf routers.</li>
<li>The <a href="#noc-xls_noc_star_topology-star">star</a> topology is a topology with a single router: the central
    router node. All traffic traverses through the central router. The channels
    are bidirectional.</li>
<li>The <a href="#noc-xls_noc_star_topology-single_router">single router</a> topology is a topology with a single
    router: the central router node. All traffic traverses through the central
    router. The channels are unidirectional.</li>
</ul></section><h1 class='nav-section-title-end'>Ended: Topologies</h1><section class="print-page" id="noc-xls_noc_glossary"><h1 id="noc-xls_noc_glossary-xls-noc-glossary">XLS-NoC Glossary</h1>
<h2 id="noc-xls_noc_glossary-adaptive-routing">Adaptive Routing<a id="adaptive_routing"></a></h2>
<p>An adaptive <a href="#noc-xls_noc_glossary-routing_algorithm">routing algorithm</a> derives a route using any
information about the network’s state.</p>
<h2 id="noc-xls_noc_glossary-channel">Channel</h2>
<p>A channel interconnects a pair of nodes and is the medium that transfers data
amongst the pair. A node is either a router input, a router output or an
endpoint port. A channel may be unidirectional, transferring the data in a
single direction, or bidirectional, transferring the data in both directions.</p>
<h2 id="noc-xls_noc_glossary-endpoint">Endpoint</h2>
<p>A node connected to the network that communicates to other endpoints using the
network.</p>
<h2 id="noc-xls_noc_glossary-endpoint-port">Endpoint Port</h2>
<p>An endpoint port is a port that connects to an endpoint. There are two types of
endpoint ports: a send port and a receive port. A send port enables an endpoint
to send data to the network and a receive port enables an endpoint to receive
data from the network. The naming convention for a send port and receive port is
from the perspective of the endpoints.</p>
<h2 id="noc-xls_noc_glossary-deadlock">Deadlock</h2>
<p>A deadlock occurs when a set of agents holding resources are waiting on another
set of resources such that a cycle of waiting agents is formed, implying that
agents are unable to make progress.</p>
<p><img alt="drawing" src="../noc/deadlock.png" /></p>
<p><strong>Figure Deadlock_Example<a id="deadlock_example"></a>. A deadlock example with
two agents and two resources.</strong></p>
<p>Figure <a href="#noc-xls_noc_glossary-deadlock_example">Deadlock_Example</a> shows a deadlock example with two
agents and two resources. In the example, agent 0 is waiting for resource B that
is assigned to agent 1, and agent 1 is waiting for resource A that is assigned
to agent 0. The dependency cycle created with agent 0 and 1 demonstrate that the
agents are unable to make progress.</p>
<h2 id="noc-xls_noc_glossary-flit">Flit</h2>
<p>A flow control digit, or flit, is the smallest unit of resource allocation in a
router. Variable length packets are divided into one or more fixed length flits
to simplify the management and allocation of resources. Flits may be divided
further into phits when traversing a router.</p>
<h2 id="noc-xls_noc_glossary-flow-control">Flow Control</h2>
<p>Flow control is the scheduling and allocation of a network’s resources. For
example, a <a href="#noc-xls_noc_glossary-virtual_channel">virtual channel</a> can have a
<a href="#noc-xls_noc_glossary-wormhole_flow_control">wormhole flow control</a>.</p>
<h2 id="noc-xls_noc_glossary-hotspot-hot-spot">Hotspot (Hot-spot)</h2>
<p>A hotspot resource is one whose demand is significantly greater than other,
similar resources. For example, a particular destination terminal becomes a
hotspot in a shared memory multicomputer when many processors are simultaneously
reading from the same memory location (for example, a shared lock or data
structure). Another example is traffic congestion within an area of the network.</p>
<h2 id="noc-xls_noc_glossary-livelock">Livelock</h2>
<p>Livelock occurs when a packet is not able to make progress in the network and is
never delivered to its destination. Unlike deadlock, a livelocked packet
continues to move through the network.</p>
<p><img alt="drawing" src="../noc/livelock.png" /></p>
<p><strong>Figure Livelock_Example<a id="livelock_example"></a>. A example with
livelocked packet P1.</strong></p>
<p>Figure <a href="#noc-xls_noc_glossary-livelock_example">Livelock_Example</a> shows a livelock example. In the
example, there are two packets, P0 and P1. The destination router for the
packets is router R2. R1 uses an <a href="#noc-xls_noc_glossary-adaptive_routing">adaptive routing</a>
algorithm. At timestep 1, P0 and P1 are at router R0. Given the routing
algorithm at R0, R0 routes packet P0 to R2 and P1 to R1 (timestep 2). At
timestep 3, another instance of P0 is routed to R0 and P1 is routed to R2. At
timestep 4, P1 is routed to R0. After the arrival of P1 at R0. The state of R0
is identical to timestep1 where these sequence of events will repeat. In the
end, P1 does not arrive to its destination although it makes progress, thus
livelocked.</p>
<h2 id="noc-xls_noc_glossary-network-on-chip-noc">Network-On-Chip (NoC)</h2>
<p>At a high level, a Network-On-Chip (NoC) is a network designed for one chip. It
is composed of routers, channels and endpoint ports. It transports data between
endpoints connected to it. Although the design is intended for a single chip,
the logical description can be partitioned across multiple chips.</p>
<h2 id="noc-xls_noc_glossary-oblivious-routing">Oblivious Routing</h2>
<p>An oblivious <a href="#noc-xls_noc_glossary-routing_algorithm">routing algorithm</a> derives a route without
using any information about the network’s state, where, fundamentally, the route
is computed using solely the source and the destination.</p>
<h2 id="noc-xls_noc_glossary-packet">Packet</h2>
<p>Packets are the unit of routing within an interconnection network. Messages are
broken into one or more variable, but bounded, length packets for processing by
the network. All data contained within a packet follow the same route through
the network and packets are reassembled into messages at the destination node. A
packet is divided further into flits.</p>
<h2 id="noc-xls_noc_glossary-phit">Phit</h2>
<p>A physical digit, or phit, is the smallest unit of data processed (e.g.
traversing or accessed) by a router. One or more phits are combined to form a
flit.</p>
<h2 id="noc-xls_noc_glossary-port">Port</h2>
<p>A port is a physical gateway to a component (input port) or from a component
(output port).</p>
<h2 id="noc-xls_noc_glossary-router">Router</h2>
<p>A router receives packets on its inputs, determines the packets' destination
based on the routing algorithm, and forwards the packets to the appropriate
output.</p>
<h2 id="noc-xls_noc_glossary-routing-algorithm">Routing Algorithm<a id="routing_algorithm"></a></h2>
<p>The series of steps for choosing a path for a packet through the network. For a
packet, the routing algorithm determines the router's output from its input.</p>
<h2 id="noc-xls_noc_glossary-topology">Topology</h2>
<p>The static arrangement of router nodes, channels, and endpoint ports in a
network. The topology affects the routing in the network.</p>
<h2 id="noc-xls_noc_glossary-virtual-channel">Virtual Channel<a id="virtual_channel"></a></h2>
<p>A virtual channel (VC) is a logical representation of a channel at a router's
input or output. It is composed of flit buffers within the router. In a router
that handles virtual channels, a packet or flit is assigned to a virtual
channel. Hence, the presence of virtual channels at a router's input or output
enables the transfer of multiple packets through a single channel.</p>
<h2 id="noc-xls_noc_glossary-wormhole-flow-control">Wormhole Flow Control<a id="wormhole_flow_control"></a></h2>
<p>Wormhole flow control defines the allocation of a resource at the flit
granularity. Upon a successful allocation, the transfer of the flit is permitted
to commence.</p>
<h2 id="noc-xls_noc_glossary-references">References</h2>
<p>William James Dally and Brian Patrick Towles. 2004. Principles and Practices of
Interconnection Networks. Morgan Kaufmann Publishers Inc., San Francisco, CA,
USA.</p></section><h1 class='nav-section-title-end'>Ended: NoC</h1></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "/xls/", "features": [], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.ad660dcc.min.js"></script>
      
        <script src="../js/print-site.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>